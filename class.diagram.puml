@startuml
namespace admin {
    class DDLInfo << (S,Aquamarine) >> {
        + SchemaVer int64
        + ReorgHandle int64
        + Jobs []*model.Job

    }
    class RecordData << (S,Aquamarine) >> {
        + Handle int64
        + Values []types.Datum

    }
    class admin.jobArray << (T, #FF7700) >>  {
    }
    class jobArray << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class "[]*model.Job" as modelJob {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace aggfuncs {
    interface AggFunc  {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    interface SlidingWindowAggFunc  {
        + Slide(sctx sessionctx.Context, rows []chunk.Row, lastStart uint64, lastEnd uint64, shiftStart uint64, shiftEnd uint64, pr PartialResult) error

    }
    class aggfuncs.PartialResult << (T, #FF7700) >>  {
    }
    class aggfuncs.approxCountDistinctHashValue << (T, #FF7700) >>  {
    }
    class aggfuncs.partialResult4BitFunc << (T, #FF7700) >>  {
    }
    class aggfuncs.partialResult4Count << (T, #FF7700) >>  {
    }
    class approxCountDistinctFinal << (S,Aquamarine) >> {
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class approxCountDistinctOriginal << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error

    }
    class approxCountDistinctPartial1 << (S,Aquamarine) >> {
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class approxCountDistinctPartial2 << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error

    }
    class avgOriginal4Decimal << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error

    }
    class avgOriginal4DistinctDecimal << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class avgOriginal4DistinctFloat64 << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class avgOriginal4Float64 << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error

    }
    class avgPartial4Decimal << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class avgPartial4Float64 << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class baseAggFunc << (S,Aquamarine) >> {
        - args []expression.Expression
        - ordinal int

        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class baseApproxCountDistinct << (S,Aquamarine) >> {
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class baseAvgDecimal << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class baseAvgFloat64 << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class baseBitAggFunc << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class baseCount << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class baseGroupConcat4String << (S,Aquamarine) >> {
        - byItems []*util.ByItems
        - sep string
        - maxLen uint64
        - truncated *int32

        - handleTruncateError(sctx sessionctx.Context) error
        - truncatePartialResultIfNeed(sctx sessionctx.Context, buffer *bytes.Buffer) error

        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class baseLeadLag << (S,Aquamarine) >> {
        - defaultExpr expression.Expression
        - offset uint64

        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error

    }
    class baseMaxMinAggFunc << (S,Aquamarine) >> {
        - isMax bool

    }
    class basePartialResult4FirstRow << (S,Aquamarine) >> {
        - isNull bool
        - gotFirstRow bool

    }
    class basePartialResult4GroupConcat << (S,Aquamarine) >> {
        - valsBuf *bytes.Buffer
        - buffer *bytes.Buffer

    }
    class baseSum4Float64 << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class baseSumAggFunc << (S,Aquamarine) >> {
    }
    class baseVarPopAggFunc << (S,Aquamarine) >> {
    }
    class bitAndUint64 << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class bitOrUint64 << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class bitXorUint64 << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class countOriginal4Decimal << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + Slide(sctx sessionctx.Context, rows []chunk.Row, lastStart uint64, lastEnd uint64, shiftStart uint64, shiftEnd uint64, pr PartialResult) error

    }
    class countOriginal4Duration << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + Slide(sctx sessionctx.Context, rows []chunk.Row, lastStart uint64, lastEnd uint64, shiftStart uint64, shiftEnd uint64, pr PartialResult) error

    }
    class countOriginal4Int << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + Slide(sctx sessionctx.Context, rows []chunk.Row, lastStart uint64, lastEnd uint64, shiftStart uint64, shiftEnd uint64, pr PartialResult) error

    }
    class countOriginal4JSON << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + Slide(sctx sessionctx.Context, rows []chunk.Row, lastStart uint64, lastEnd uint64, shiftStart uint64, shiftEnd uint64, pr PartialResult) error

    }
    class countOriginal4Real << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + Slide(sctx sessionctx.Context, rows []chunk.Row, lastStart uint64, lastEnd uint64, shiftStart uint64, shiftEnd uint64, pr PartialResult) error

    }
    class countOriginal4String << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + Slide(sctx sessionctx.Context, rows []chunk.Row, lastStart uint64, lastEnd uint64, shiftStart uint64, shiftEnd uint64, pr PartialResult) error

    }
    class countOriginal4Time << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + Slide(sctx sessionctx.Context, rows []chunk.Row, lastStart uint64, lastEnd uint64, shiftStart uint64, shiftEnd uint64, pr PartialResult) error

    }
    class countOriginalWithDistinct << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error

    }
    class countOriginalWithDistinct4Decimal << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error

    }
    class countOriginalWithDistinct4Duration << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error

    }
    class countOriginalWithDistinct4Int << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error

    }
    class countOriginalWithDistinct4Real << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error

    }
    class countOriginalWithDistinct4String << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error

    }
    class countPartial << (S,Aquamarine) >> {
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class cumeDist << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class firstRow4Decimal << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class firstRow4Duration << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class firstRow4Enum << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class firstRow4Float32 << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class firstRow4Float64 << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class firstRow4Int << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class firstRow4JSON << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class firstRow4Set << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class firstRow4String << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class firstRow4Time << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class firstValue << (S,Aquamarine) >> {
        - tp *types.FieldType

        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class groupConcat << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error
        + SetTruncated(t *int32) 
        + GetTruncated() *int32

    }
    class groupConcatDistinct << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + SetTruncated(t *int32) 
        + GetTruncated() *int32

    }
    class groupConcatDistinctOrder << (S,Aquamarine) >> {
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class groupConcatOrder << (S,Aquamarine) >> {
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error
        + SetTruncated(t *int32) 
        + GetTruncated() *int32

    }
    class jsonObjectAgg << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class lag << (S,Aquamarine) >> {
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class lastValue << (S,Aquamarine) >> {
        - tp *types.FieldType

        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class lead << (S,Aquamarine) >> {
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class maxMin4Decimal << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class maxMin4Duration << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class maxMin4Float32 << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class maxMin4Float64 << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class maxMin4Int << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class maxMin4JSON << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class maxMin4String << (S,Aquamarine) >> {
        - retTp *types.FieldType

        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class maxMin4Time << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class maxMin4Uint << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class nthValue << (S,Aquamarine) >> {
        - tp *types.FieldType
        - nth uint64

        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class ntile << (S,Aquamarine) >> {
        - n uint64

        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(_ sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + AppendFinalResult2Chunk(_ sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class partialResult4ApproxCountDistinct << (S,Aquamarine) >> {
        - size uint32
        - sizeDegree uint8
        - skipDegree uint8
        - hasZero bool
        - buf []approxCountDistinctHashValue

        - alloc(newSizeDegree uint8) 
        - reset() 
        - bufSize() uint32
        - mask() uint32
        - place(x approxCountDistinctHashValue) uint32
        - resize(newSizeDegree uint8) 
        - readAndMerge(rb []byte) error
        - fixedSize() uint64
        - insertHash(hashValue approxCountDistinctHashValue) 
        - good(hash approxCountDistinctHashValue) bool
        - insertImpl(x approxCountDistinctHashValue) 
        - shrinkIfNeed() 
        - maxFill() uint32
        - rehash() 
        - reinsertImpl(x approxCountDistinctHashValue) 
        - merge(tar *partialResult4ApproxCountDistinct) 

        + InsertHash64(x uint64) 
        + Serialize() []byte

    }
    class partialResult4AvgDecimal << (S,Aquamarine) >> {
        - sum types.MyDecimal
        - count int64

    }
    class partialResult4AvgDistinctDecimal << (S,Aquamarine) >> {
        - valSet set.StringSet

    }
    class partialResult4AvgDistinctFloat64 << (S,Aquamarine) >> {
        - valSet set.Float64Set

    }
    class partialResult4AvgFloat64 << (S,Aquamarine) >> {
        - sum float64
        - count int64

    }
    class partialResult4CountDistinctDecimal << (S,Aquamarine) >> {
        - valSet set.StringSet

    }
    class partialResult4CountDistinctDuration << (S,Aquamarine) >> {
        - valSet set.Int64Set

    }
    class partialResult4CountDistinctInt << (S,Aquamarine) >> {
        - valSet set.Int64Set

    }
    class partialResult4CountDistinctReal << (S,Aquamarine) >> {
        - valSet set.Float64Set

    }
    class partialResult4CountDistinctString << (S,Aquamarine) >> {
        - valSet set.StringSet

    }
    class partialResult4CountWithDistinct << (S,Aquamarine) >> {
        - valSet set.StringSet

    }
    class partialResult4CumeDist << (S,Aquamarine) >> {
        - curIdx int
        - lastRank int
        - rows []chunk.Row

    }
    class partialResult4FirstRowDecimal << (S,Aquamarine) >> {
        - val types.MyDecimal

    }
    class partialResult4FirstRowDuration << (S,Aquamarine) >> {
        - val types.Duration

    }
    class partialResult4FirstRowEnum << (S,Aquamarine) >> {
        - val types.Enum

    }
    class partialResult4FirstRowFloat32 << (S,Aquamarine) >> {
        - val float32

    }
    class partialResult4FirstRowFloat64 << (S,Aquamarine) >> {
        - val float64

    }
    class partialResult4FirstRowInt << (S,Aquamarine) >> {
        - val int64

    }
    class partialResult4FirstRowJSON << (S,Aquamarine) >> {
        - val json.BinaryJSON

    }
    class partialResult4FirstRowSet << (S,Aquamarine) >> {
        - val types.Set

    }
    class partialResult4FirstRowString << (S,Aquamarine) >> {
        - val string

    }
    class partialResult4FirstRowTime << (S,Aquamarine) >> {
        - val types.Time

    }
    class partialResult4FirstValue << (S,Aquamarine) >> {
        - gotFirstValue bool
        - evaluator valueEvaluator

    }
    class partialResult4GroupConcat << (S,Aquamarine) >> {
    }
    class partialResult4GroupConcatDistinct << (S,Aquamarine) >> {
        - valSet set.StringSet
        - encodeBytesBuffer []byte

    }
    class partialResult4GroupConcatOrder << (S,Aquamarine) >> {
        - topN *topNRows

    }
    class partialResult4GroupConcatOrderDistinct << (S,Aquamarine) >> {
        - topN *topNRows
        - valSet set.StringSet
        - encodeBytesBuffer []byte

    }
    class partialResult4JsonObjectAgg << (S,Aquamarine) >> {
        - entries <font color=blue>map</font>[string]<font color=blue>interface</font>{}

    }
    class partialResult4LastValue << (S,Aquamarine) >> {
        - gotLastValue bool
        - evaluator valueEvaluator

    }
    class partialResult4LeadLag << (S,Aquamarine) >> {
        - rows []chunk.Row
        - curIdx uint64

    }
    class partialResult4MaxMinDecimal << (S,Aquamarine) >> {
        - val types.MyDecimal
        - isNull bool

    }
    class partialResult4MaxMinDuration << (S,Aquamarine) >> {
        - val types.Duration
        - isNull bool

    }
    class partialResult4MaxMinFloat32 << (S,Aquamarine) >> {
        - val float32
        - isNull bool

    }
    class partialResult4MaxMinFloat64 << (S,Aquamarine) >> {
        - val float64
        - isNull bool

    }
    class partialResult4MaxMinInt << (S,Aquamarine) >> {
        - val int64
        - isNull bool

    }
    class partialResult4MaxMinJSON << (S,Aquamarine) >> {
        - val json.BinaryJSON
        - isNull bool

    }
    class partialResult4MaxMinString << (S,Aquamarine) >> {
        - val string
        - isNull bool

    }
    class partialResult4MaxMinUint << (S,Aquamarine) >> {
        - val uint64
        - isNull bool

    }
    class partialResult4NthValue << (S,Aquamarine) >> {
        - seenRows uint64
        - evaluator valueEvaluator

    }
    class partialResult4Ntile << (S,Aquamarine) >> {
        - curIdx uint64
        - curGroupIdx uint64
        - remainder uint64
        - quotient uint64
        - numRows uint64

    }
    class partialResult4Rank << (S,Aquamarine) >> {
        - curIdx int64
        - lastRank int64
        - rows []chunk.Row

    }
    class partialResult4RowNumber << (S,Aquamarine) >> {
        - curIdx int64

    }
    class partialResult4SumDecimal << (S,Aquamarine) >> {
        - val types.MyDecimal
        - notNullRowCount int64

    }
    class partialResult4SumDistinctDecimal << (S,Aquamarine) >> {
        - val types.MyDecimal
        - isNull bool
        - valSet set.StringSet

    }
    class partialResult4SumDistinctFloat64 << (S,Aquamarine) >> {
        - val float64
        - isNull bool
        - valSet set.Float64Set

    }
    class partialResult4SumFloat64 << (S,Aquamarine) >> {
        - val float64
        - notNullRowCount int64

    }
    class partialResult4Time << (S,Aquamarine) >> {
        - val types.Time
        - isNull bool

    }
    class partialResult4VarPopDistinctFloat64 << (S,Aquamarine) >> {
        - count int64
        - sum float64
        - variance float64
        - valSet set.Float64Set

    }
    class partialResult4VarPopFloat64 << (S,Aquamarine) >> {
        - count int64
        - sum float64
        - variance float64

    }
    class percentRank << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(partial PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, partial PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, partial PartialResult, chk *chunk.Chunk) error

    }
    class rank << (S,Aquamarine) >> {
        - isDense bool

        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class rowComparer << (S,Aquamarine) >> {
        - cmpFuncs []chunk.CompareFunc
        - colIdx []int

        - compareRows(prev chunk.Row, curr chunk.Row) int

    }
    class rowNumber << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class sortRow << (S,Aquamarine) >> {
        - buffer *bytes.Buffer
        - byItems []*types.Datum

    }
    class sum4Decimal << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + Slide(sctx sessionctx.Context, rows []chunk.Row, lastStart uint64, lastEnd uint64, shiftStart uint64, shiftEnd uint64, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class sum4DistinctDecimal << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class sum4DistinctFloat64 << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error

    }
    class sum4Float64 << (S,Aquamarine) >> {
        + Slide(sctx sessionctx.Context, rows []chunk.Row, lastStart uint64, lastEnd uint64, shiftStart uint64, shiftEnd uint64, pr PartialResult) error

    }
    class sum4Float64HighPrecision << (S,Aquamarine) >> {
    }
    class topNRows << (S,Aquamarine) >> {
        - rows []sortRow
        - desc []bool
        - sctx sessionctx.Context
        - err error
        - currSize uint64
        - limitSize uint64
        - sepSize uint64

        - tryToAdd(row sortRow) bool
        - reset() 
        - concat(sep string, truncated bool) string

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}

    }
    class value4Decimal << (S,Aquamarine) >> {
        - val *types.MyDecimal
        - isNull bool

        - evaluateRow(ctx sessionctx.Context, expr expression.Expression, row chunk.Row) error
        - appendResult(chk *chunk.Chunk, colIdx int) 

    }
    class value4Duration << (S,Aquamarine) >> {
        - val types.Duration
        - isNull bool

        - evaluateRow(ctx sessionctx.Context, expr expression.Expression, row chunk.Row) error
        - appendResult(chk *chunk.Chunk, colIdx int) 

    }
    class value4Float32 << (S,Aquamarine) >> {
        - val float32
        - isNull bool

        - evaluateRow(ctx sessionctx.Context, expr expression.Expression, row chunk.Row) error
        - appendResult(chk *chunk.Chunk, colIdx int) 

    }
    class value4Float64 << (S,Aquamarine) >> {
        - val float64
        - isNull bool

        - evaluateRow(ctx sessionctx.Context, expr expression.Expression, row chunk.Row) error
        - appendResult(chk *chunk.Chunk, colIdx int) 

    }
    class value4Int << (S,Aquamarine) >> {
        - val int64
        - isNull bool

        - evaluateRow(ctx sessionctx.Context, expr expression.Expression, row chunk.Row) error
        - appendResult(chk *chunk.Chunk, colIdx int) 

    }
    class value4JSON << (S,Aquamarine) >> {
        - val json.BinaryJSON
        - isNull bool

        - evaluateRow(ctx sessionctx.Context, expr expression.Expression, row chunk.Row) error
        - appendResult(chk *chunk.Chunk, colIdx int) 

    }
    class value4String << (S,Aquamarine) >> {
        - val string
        - isNull bool

        - evaluateRow(ctx sessionctx.Context, expr expression.Expression, row chunk.Row) error
        - appendResult(chk *chunk.Chunk, colIdx int) 

    }
    class value4Time << (S,Aquamarine) >> {
        - val types.Time
        - isNull bool

        - evaluateRow(ctx sessionctx.Context, expr expression.Expression, row chunk.Row) error
        - appendResult(chk *chunk.Chunk, colIdx int) 

    }
    interface valueEvaluator  {
        - evaluateRow(ctx sessionctx.Context, expr expression.Expression, row chunk.Row) error
        - appendResult(chk *chunk.Chunk, colIdx int) 

    }
    class varPop4DistinctFloat64 << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error

    }
    class varPop4Float64 << (S,Aquamarine) >> {
        + AllocPartialResult() PartialResult
        + ResetPartialResult(pr PartialResult) 
        + AppendFinalResult2Chunk(sctx sessionctx.Context, pr PartialResult, chk *chunk.Chunk) error
        + UpdatePartialResult(sctx sessionctx.Context, rowsInGroup []chunk.Row, pr PartialResult) error
        + MergePartialResult(sctx sessionctx.Context, src PartialResult, dst PartialResult) error

    }
    class "unsafe.Pointer" as unsafePointer {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"aggfuncs.approxCountDistinctPartial2" *-- "aggfuncs.approxCountDistinctFinal"
"aggfuncs.baseApproxCountDistinct" *-- "aggfuncs.approxCountDistinctOriginal"
"aggfuncs.approxCountDistinctOriginal" *-- "aggfuncs.approxCountDistinctPartial1"
"aggfuncs.approxCountDistinctPartial1" *-- "aggfuncs.approxCountDistinctPartial2"
"aggfuncs.baseAvgDecimal" *-- "aggfuncs.avgOriginal4Decimal"
"aggfuncs.baseAggFunc" *-- "aggfuncs.avgOriginal4DistinctDecimal"
"aggfuncs.baseAggFunc" *-- "aggfuncs.avgOriginal4DistinctFloat64"
"aggfuncs.baseAvgFloat64" *-- "aggfuncs.avgOriginal4Float64"
"aggfuncs.baseAvgDecimal" *-- "aggfuncs.avgPartial4Decimal"
"aggfuncs.baseAvgFloat64" *-- "aggfuncs.avgPartial4Float64"
"aggfuncs.baseAggFunc" *-- "aggfuncs.baseApproxCountDistinct"
"aggfuncs.baseAggFunc" *-- "aggfuncs.baseAvgDecimal"
"aggfuncs.baseAggFunc" *-- "aggfuncs.baseAvgFloat64"
"aggfuncs.baseAggFunc" *-- "aggfuncs.baseBitAggFunc"
"aggfuncs.baseAggFunc" *-- "aggfuncs.baseCount"
"aggfuncs.baseAggFunc" *-- "aggfuncs.baseGroupConcat4String"
"aggfuncs.baseAggFunc" *-- "aggfuncs.baseLeadLag"
"aggfuncs.valueEvaluator" *-- "aggfuncs.baseLeadLag"
"aggfuncs.baseAggFunc" *-- "aggfuncs.baseMaxMinAggFunc"
"aggfuncs.baseSumAggFunc" *-- "aggfuncs.baseSum4Float64"
"aggfuncs.baseAggFunc" *-- "aggfuncs.baseSumAggFunc"
"aggfuncs.baseAggFunc" *-- "aggfuncs.baseVarPopAggFunc"
"aggfuncs.baseBitAggFunc" *-- "aggfuncs.bitAndUint64"
"aggfuncs.baseBitAggFunc" *-- "aggfuncs.bitOrUint64"
"aggfuncs.baseBitAggFunc" *-- "aggfuncs.bitXorUint64"
"aggfuncs.baseCount" *-- "aggfuncs.countOriginal4Decimal"
"aggfuncs.baseCount" *-- "aggfuncs.countOriginal4Duration"
"aggfuncs.baseCount" *-- "aggfuncs.countOriginal4Int"
"aggfuncs.baseCount" *-- "aggfuncs.countOriginal4JSON"
"aggfuncs.baseCount" *-- "aggfuncs.countOriginal4Real"
"aggfuncs.baseCount" *-- "aggfuncs.countOriginal4String"
"aggfuncs.baseCount" *-- "aggfuncs.countOriginal4Time"
"aggfuncs.baseCount" *-- "aggfuncs.countOriginalWithDistinct"
"aggfuncs.baseCount" *-- "aggfuncs.countOriginalWithDistinct4Decimal"
"aggfuncs.baseCount" *-- "aggfuncs.countOriginalWithDistinct4Duration"
"aggfuncs.baseCount" *-- "aggfuncs.countOriginalWithDistinct4Int"
"aggfuncs.baseCount" *-- "aggfuncs.countOriginalWithDistinct4Real"
"aggfuncs.baseCount" *-- "aggfuncs.countOriginalWithDistinct4String"
"aggfuncs.baseCount" *-- "aggfuncs.countPartial"
"aggfuncs.baseAggFunc" *-- "aggfuncs.cumeDist"
"aggfuncs.rowComparer" *-- "aggfuncs.cumeDist"
"aggfuncs.baseAggFunc" *-- "aggfuncs.firstRow4Decimal"
"aggfuncs.baseAggFunc" *-- "aggfuncs.firstRow4Duration"
"aggfuncs.baseAggFunc" *-- "aggfuncs.firstRow4Enum"
"aggfuncs.baseAggFunc" *-- "aggfuncs.firstRow4Float32"
"aggfuncs.baseAggFunc" *-- "aggfuncs.firstRow4Float64"
"aggfuncs.baseAggFunc" *-- "aggfuncs.firstRow4Int"
"aggfuncs.baseAggFunc" *-- "aggfuncs.firstRow4JSON"
"aggfuncs.baseAggFunc" *-- "aggfuncs.firstRow4Set"
"aggfuncs.baseAggFunc" *-- "aggfuncs.firstRow4String"
"aggfuncs.baseAggFunc" *-- "aggfuncs.firstRow4Time"
"aggfuncs.baseAggFunc" *-- "aggfuncs.firstValue"
"aggfuncs.baseGroupConcat4String" *-- "aggfuncs.groupConcat"
"aggfuncs.baseGroupConcat4String" *-- "aggfuncs.groupConcatDistinct"
"aggfuncs.baseGroupConcat4String" *-- "aggfuncs.groupConcatDistinctOrder"
"aggfuncs.baseGroupConcat4String" *-- "aggfuncs.groupConcatOrder"
"aggfuncs.baseAggFunc" *-- "aggfuncs.jsonObjectAgg"
"aggfuncs.baseLeadLag" *-- "aggfuncs.lag"
"aggfuncs.baseAggFunc" *-- "aggfuncs.lastValue"
"aggfuncs.baseLeadLag" *-- "aggfuncs.lead"
"aggfuncs.baseMaxMinAggFunc" *-- "aggfuncs.maxMin4Decimal"
"aggfuncs.baseMaxMinAggFunc" *-- "aggfuncs.maxMin4Duration"
"aggfuncs.baseMaxMinAggFunc" *-- "aggfuncs.maxMin4Float32"
"aggfuncs.baseMaxMinAggFunc" *-- "aggfuncs.maxMin4Float64"
"aggfuncs.baseMaxMinAggFunc" *-- "aggfuncs.maxMin4Int"
"aggfuncs.baseMaxMinAggFunc" *-- "aggfuncs.maxMin4JSON"
"aggfuncs.baseMaxMinAggFunc" *-- "aggfuncs.maxMin4String"
"aggfuncs.baseMaxMinAggFunc" *-- "aggfuncs.maxMin4Time"
"aggfuncs.baseMaxMinAggFunc" *-- "aggfuncs.maxMin4Uint"
"aggfuncs.baseAggFunc" *-- "aggfuncs.nthValue"
"aggfuncs.baseAggFunc" *-- "aggfuncs.ntile"
"aggfuncs.partialResult4AvgDecimal" *-- "aggfuncs.partialResult4AvgDistinctDecimal"
"aggfuncs.partialResult4AvgFloat64" *-- "aggfuncs.partialResult4AvgDistinctFloat64"
"aggfuncs.basePartialResult4FirstRow" *-- "aggfuncs.partialResult4FirstRowDecimal"
"aggfuncs.basePartialResult4FirstRow" *-- "aggfuncs.partialResult4FirstRowDuration"
"aggfuncs.basePartialResult4FirstRow" *-- "aggfuncs.partialResult4FirstRowEnum"
"aggfuncs.basePartialResult4FirstRow" *-- "aggfuncs.partialResult4FirstRowFloat32"
"aggfuncs.basePartialResult4FirstRow" *-- "aggfuncs.partialResult4FirstRowFloat64"
"aggfuncs.basePartialResult4FirstRow" *-- "aggfuncs.partialResult4FirstRowInt"
"aggfuncs.basePartialResult4FirstRow" *-- "aggfuncs.partialResult4FirstRowJSON"
"aggfuncs.basePartialResult4FirstRow" *-- "aggfuncs.partialResult4FirstRowSet"
"aggfuncs.basePartialResult4FirstRow" *-- "aggfuncs.partialResult4FirstRowString"
"aggfuncs.basePartialResult4FirstRow" *-- "aggfuncs.partialResult4FirstRowTime"
"aggfuncs.basePartialResult4GroupConcat" *-- "aggfuncs.partialResult4GroupConcat"
"aggfuncs.basePartialResult4GroupConcat" *-- "aggfuncs.partialResult4GroupConcatDistinct"
"aggfuncs.baseAggFunc" *-- "aggfuncs.percentRank"
"aggfuncs.rowComparer" *-- "aggfuncs.percentRank"
"aggfuncs.baseAggFunc" *-- "aggfuncs.rank"
"aggfuncs.rowComparer" *-- "aggfuncs.rank"
"aggfuncs.baseAggFunc" *-- "aggfuncs.rowNumber"
"aggfuncs.baseSumAggFunc" *-- "aggfuncs.sum4Decimal"
"aggfuncs.baseSumAggFunc" *-- "aggfuncs.sum4DistinctDecimal"
"aggfuncs.baseSumAggFunc" *-- "aggfuncs.sum4DistinctFloat64"
"aggfuncs.baseSum4Float64" *-- "aggfuncs.sum4Float64"
"aggfuncs.baseSum4Float64" *-- "aggfuncs.sum4Float64HighPrecision"
"aggfuncs.baseVarPopAggFunc" *-- "aggfuncs.varPop4DistinctFloat64"
"aggfuncs.baseVarPopAggFunc" *-- "aggfuncs.varPop4Float64"

"aggfuncs.AggFunc" <|-- "aggfuncs.baseSum4Float64"
"aggfuncs.SlidingWindowAggFunc" <|-- "aggfuncs.countOriginal4Decimal"
"aggfuncs.SlidingWindowAggFunc" <|-- "aggfuncs.countOriginal4Duration"
"aggfuncs.SlidingWindowAggFunc" <|-- "aggfuncs.countOriginal4Int"
"aggfuncs.SlidingWindowAggFunc" <|-- "aggfuncs.countOriginal4JSON"
"aggfuncs.SlidingWindowAggFunc" <|-- "aggfuncs.countOriginal4Real"
"aggfuncs.SlidingWindowAggFunc" <|-- "aggfuncs.countOriginal4String"
"aggfuncs.SlidingWindowAggFunc" <|-- "aggfuncs.countOriginal4Time"
"aggfuncs.AggFunc" <|-- "aggfuncs.firstRow4Decimal"
"aggfuncs.AggFunc" <|-- "aggfuncs.firstRow4Duration"
"aggfuncs.AggFunc" <|-- "aggfuncs.firstRow4Enum"
"aggfuncs.AggFunc" <|-- "aggfuncs.firstRow4Float32"
"aggfuncs.AggFunc" <|-- "aggfuncs.firstRow4Float64"
"aggfuncs.AggFunc" <|-- "aggfuncs.firstRow4Int"
"aggfuncs.AggFunc" <|-- "aggfuncs.firstRow4JSON"
"aggfuncs.AggFunc" <|-- "aggfuncs.firstRow4Set"
"aggfuncs.AggFunc" <|-- "aggfuncs.firstRow4String"
"aggfuncs.AggFunc" <|-- "aggfuncs.firstRow4Time"
"aggfuncs.AggFunc" <|-- "aggfuncs.groupConcatDistinctOrder"
"aggfuncs.AggFunc" <|-- "aggfuncs.groupConcatOrder"
"aggfuncs.AggFunc" <|-- "aggfuncs.jsonObjectAgg"
"aggfuncs.AggFunc" <|-- "aggfuncs.maxMin4Decimal"
"aggfuncs.AggFunc" <|-- "aggfuncs.maxMin4Duration"
"aggfuncs.AggFunc" <|-- "aggfuncs.maxMin4Float32"
"aggfuncs.AggFunc" <|-- "aggfuncs.maxMin4Float64"
"aggfuncs.AggFunc" <|-- "aggfuncs.maxMin4Int"
"aggfuncs.AggFunc" <|-- "aggfuncs.maxMin4JSON"
"aggfuncs.AggFunc" <|-- "aggfuncs.maxMin4String"
"aggfuncs.AggFunc" <|-- "aggfuncs.maxMin4Time"
"aggfuncs.AggFunc" <|-- "aggfuncs.maxMin4Uint"
"aggfuncs.AggFunc" <|-- "aggfuncs.sum4Decimal"
"aggfuncs.SlidingWindowAggFunc" <|-- "aggfuncs.sum4Decimal"
"aggfuncs.SlidingWindowAggFunc" <|-- "aggfuncs.sum4Float64"
"aggfuncs.valueEvaluator" <|-- "aggfuncs.value4Decimal"
"aggfuncs.valueEvaluator" <|-- "aggfuncs.value4Duration"
"aggfuncs.valueEvaluator" <|-- "aggfuncs.value4Float32"
"aggfuncs.valueEvaluator" <|-- "aggfuncs.value4Float64"
"aggfuncs.valueEvaluator" <|-- "aggfuncs.value4Int"
"aggfuncs.valueEvaluator" <|-- "aggfuncs.value4JSON"
"aggfuncs.valueEvaluator" <|-- "aggfuncs.value4String"
"aggfuncs.valueEvaluator" <|-- "aggfuncs.value4Time"
"aggfuncs.AggFunc" <|-- "aggfuncs.varPop4Float64"

namespace aggregation {
    class AggEvaluateContext << (S,Aquamarine) >> {
        + DistinctChecker *distinctChecker
        + Count int64
        + Value types.Datum
        + Buffer *bytes.Buffer
        + GotFirstRow bool

    }
    class AggFuncDesc << (S,Aquamarine) >> {
        + Mode AggFunctionMode
        + HasDistinct bool
        + OrderByItems []*util.ByItems

        - evalNullValueInOuterJoin4Count(ctx sessionctx.Context, schema *expression.Schema) (types.Datum, bool)
        - evalNullValueInOuterJoin4Sum(ctx sessionctx.Context, schema *expression.Schema) (types.Datum, bool)
        - evalNullValueInOuterJoin4BitAnd(ctx sessionctx.Context, schema *expression.Schema) (types.Datum, bool)
        - evalNullValueInOuterJoin4BitOr(ctx sessionctx.Context, schema *expression.Schema) (types.Datum, bool)

        + String() string
        + Equal(ctx sessionctx.Context, other *AggFuncDesc) bool
        + Clone() *AggFuncDesc
        + Split(ordinal []int) *AggFuncDesc
        + EvalNullValueInOuterJoin(ctx sessionctx.Context, schema *expression.Schema) (types.Datum, bool)
        + GetAggFunc(ctx sessionctx.Context) Aggregation

    }
    interface Aggregation  {
        + Update(evalCtx *AggEvaluateContext, sc *stmtctx.StatementContext, row chunk.Row) error
        + GetPartialResult(evalCtx *AggEvaluateContext) []types.Datum
        + GetResult(evalCtx *AggEvaluateContext) types.Datum
        + CreateContext(sc *stmtctx.StatementContext) *AggEvaluateContext
        + ResetContext(sc *stmtctx.StatementContext, evalCtx *AggEvaluateContext) 

    }
    class WindowFuncDesc << (S,Aquamarine) >> {
    }
    class aggFunction << (S,Aquamarine) >> {
        - updateSum(sc *stmtctx.StatementContext, evalCtx *AggEvaluateContext, row chunk.Row) error

        + CreateContext(sc *stmtctx.StatementContext) *AggEvaluateContext
        + ResetContext(sc *stmtctx.StatementContext, evalCtx *AggEvaluateContext) 

    }
    class aggregation.AggFunctionMode << (T, #FF7700) >>  {
    }
    class avgFunction << (S,Aquamarine) >> {
        - updateAvg(sc *stmtctx.StatementContext, evalCtx *AggEvaluateContext, row chunk.Row) error

        + ResetContext(sc *stmtctx.StatementContext, evalCtx *AggEvaluateContext) 
        + Update(evalCtx *AggEvaluateContext, sc *stmtctx.StatementContext, row chunk.Row) error
        + GetResult(evalCtx *AggEvaluateContext) types.Datum
        + GetPartialResult(evalCtx *AggEvaluateContext) []types.Datum

    }
    class baseFuncDesc << (S,Aquamarine) >> {
        + Name string
        + Args []expression.Expression
        + RetTp *types.FieldType

        - equal(ctx sessionctx.Context, other *baseFuncDesc) bool
        - clone() *baseFuncDesc
        - typeInfer(ctx sessionctx.Context) error
        - typeInfer4Count(ctx sessionctx.Context) 
        - typeInfer4ApproxCountDistinct(ctx sessionctx.Context) 
        - typeInfer4Sum(ctx sessionctx.Context) 
        - typeInfer4Avg(ctx sessionctx.Context) 
        - typeInfer4GroupConcat(ctx sessionctx.Context) 
        - typeInfer4MaxMin(ctx sessionctx.Context) 
        - typeInfer4BitFuncs(ctx sessionctx.Context) 
        - typeInfer4JsonFuncs(ctx sessionctx.Context) 
        - typeInfer4NumberFuncs() 
        - typeInfer4CumeDist() 
        - typeInfer4Ntile() 
        - typeInfer4PercentRank() 
        - typeInfer4LeadLag(ctx sessionctx.Context) 
        - typeInfer4VarPop(ctx sessionctx.Context) 

        + String() string
        + GetDefaultValue() types.Datum
        + WrapCastForAggArgs(ctx sessionctx.Context) 

    }
    class bitAndFunction << (S,Aquamarine) >> {
        + CreateContext(sc *stmtctx.StatementContext) *AggEvaluateContext
        + ResetContext(sc *stmtctx.StatementContext, evalCtx *AggEvaluateContext) 
        + Update(evalCtx *AggEvaluateContext, sc *stmtctx.StatementContext, row chunk.Row) error
        + GetResult(evalCtx *AggEvaluateContext) types.Datum
        + GetPartialResult(evalCtx *AggEvaluateContext) []types.Datum

    }
    class bitOrFunction << (S,Aquamarine) >> {
        + CreateContext(sc *stmtctx.StatementContext) *AggEvaluateContext
        + ResetContext(sc *stmtctx.StatementContext, evalCtx *AggEvaluateContext) 
        + Update(evalCtx *AggEvaluateContext, sc *stmtctx.StatementContext, row chunk.Row) error
        + GetResult(evalCtx *AggEvaluateContext) types.Datum
        + GetPartialResult(evalCtx *AggEvaluateContext) []types.Datum

    }
    class bitXorFunction << (S,Aquamarine) >> {
        + CreateContext(sc *stmtctx.StatementContext) *AggEvaluateContext
        + ResetContext(sc *stmtctx.StatementContext, evalCtx *AggEvaluateContext) 
        + Update(evalCtx *AggEvaluateContext, sc *stmtctx.StatementContext, row chunk.Row) error
        + GetResult(evalCtx *AggEvaluateContext) types.Datum
        + GetPartialResult(evalCtx *AggEvaluateContext) []types.Datum

    }
    class concatFunction << (S,Aquamarine) >> {
        - separator string
        - maxLen uint64
        - sepInited bool
        - truncated bool

        - writeValue(evalCtx *AggEvaluateContext, val types.Datum) 
        - initSeparator(sc *stmtctx.StatementContext, row chunk.Row) error

        + Update(evalCtx *AggEvaluateContext, sc *stmtctx.StatementContext, row chunk.Row) error
        + GetResult(evalCtx *AggEvaluateContext) types.Datum
        + ResetContext(sc *stmtctx.StatementContext, evalCtx *AggEvaluateContext) 
        + GetPartialResult(evalCtx *AggEvaluateContext) []types.Datum

    }
    class countFunction << (S,Aquamarine) >> {
        + Update(evalCtx *AggEvaluateContext, sc *stmtctx.StatementContext, row chunk.Row) error
        + ResetContext(sc *stmtctx.StatementContext, evalCtx *AggEvaluateContext) 
        + GetResult(evalCtx *AggEvaluateContext) types.Datum
        + GetPartialResult(evalCtx *AggEvaluateContext) []types.Datum

    }
    class distinctChecker << (S,Aquamarine) >> {
        - existingKeys *mvmap.MVMap
        - key []byte
        - vals [][]byte
        - sc *stmtctx.StatementContext

        + Check(values []types.Datum) (bool, error)

    }
    class firstRowFunction << (S,Aquamarine) >> {
        + Update(evalCtx *AggEvaluateContext, sc *stmtctx.StatementContext, row chunk.Row) error
        + GetResult(evalCtx *AggEvaluateContext) types.Datum
        + ResetContext(_ *stmtctx.StatementContext, evalCtx *AggEvaluateContext) 
        + GetPartialResult(evalCtx *AggEvaluateContext) []types.Datum

    }
    class maxMinFunction << (S,Aquamarine) >> {
        - isMax bool

        + GetResult(evalCtx *AggEvaluateContext) types.Datum
        + GetPartialResult(evalCtx *AggEvaluateContext) []types.Datum
        + Update(evalCtx *AggEvaluateContext, sc *stmtctx.StatementContext, row chunk.Row) error

    }
    class sumFunction << (S,Aquamarine) >> {
        + Update(evalCtx *AggEvaluateContext, sc *stmtctx.StatementContext, row chunk.Row) error
        + GetResult(evalCtx *AggEvaluateContext) types.Datum
        + GetPartialResult(evalCtx *AggEvaluateContext) []types.Datum

    }
}
"aggregation.baseFuncDesc" *-- "aggregation.AggFuncDesc"
"aggregation.baseFuncDesc" *-- "aggregation.WindowFuncDesc"
"aggregation.AggFuncDesc" *-- "aggregation.aggFunction"
"aggregation.aggFunction" *-- "aggregation.avgFunction"
"aggregation.aggFunction" *-- "aggregation.bitAndFunction"
"aggregation.aggFunction" *-- "aggregation.bitOrFunction"
"aggregation.aggFunction" *-- "aggregation.bitXorFunction"
"aggregation.aggFunction" *-- "aggregation.concatFunction"
"aggregation.aggFunction" *-- "aggregation.countFunction"
"aggregation.aggFunction" *-- "aggregation.firstRowFunction"
"aggregation.aggFunction" *-- "aggregation.maxMinFunction"
"aggregation.aggFunction" *-- "aggregation.sumFunction"

"aggregation.Aggregation" <|-- "aggregation.bitAndFunction"
"aggregation.Aggregation" <|-- "aggregation.bitOrFunction"
"aggregation.Aggregation" <|-- "aggregation.bitXorFunction"

namespace arena {
    interface Allocator  {
        + Alloc(capacity int) []byte
        + AllocWithLen(length int, capacity int) []byte
        + Reset() 

    }
    class SimpleAllocator << (S,Aquamarine) >> {
        - arena []byte
        - off int

        + Alloc(capacity int) []byte
        + AllocWithLen(length int, capacity int) []byte
        + Reset() 

    }
    class stdAllocator << (S,Aquamarine) >> {
        + Alloc(capacity int) []byte
        + AllocWithLen(length int, capacity int) []byte
        + Reset() 

    }
}

"arena.Allocator" <|-- "arena.SimpleAllocator"
"arena.Allocator" <|-- "arena.stdAllocator"

namespace autoid {
    interface AllocOption  {
        + ApplyOn( *allocator) 

    }
    interface Allocator  {
        + Alloc(tableID int64, n uint64, increment int64, offset int64) (int64, int64, error)
        + AllocSeqCache(sequenceID int64) (int64, int64, int64, error)
        + Rebase(tableID int64, newBase int64, allocIDs bool) error
        + RebaseSeq(table int64, newBase int64) (int64, bool, error)
        + Base() int64
        + End() int64
        + NextGlobalAutoID(tableID int64) (int64, error)
        + GetType() AllocatorType

    }
    class Allocators << (S,Aquamarine) >> {
        + Get(allocType AllocatorType) Allocator

    }
    class AutoRandomIDLayout << (S,Aquamarine) >> {
        + FieldType *types.FieldType
        + ShardBits uint64
        + TypeBitsLength uint64
        + IncrementalBits uint64
        + HasSignBit bool

        + IncrementalBitsCapacity() uint64
        + IncrementalMask() int64

    }
    class CustomAutoIncCacheOption << (S,Aquamarine) >> {
        + ApplyOn(alloc *allocator) 

    }
    class allocator << (S,Aquamarine) >> {
        - mu sync.Mutex
        - base int64
        - end int64
        - store kv.Storage
        - dbID int64
        - isUnsigned bool
        - lastAllocTime time.Time
        - step int64
        - customStep bool
        - allocType AllocatorType
        - sequence *model.SequenceInfo

        - rebase4Unsigned(tableID int64, requiredBase uint64, allocIDs bool) error
        - rebase4Signed(tableID int64, requiredBase int64, allocIDs bool) error
        - rebase4Sequence(tableID int64, requiredBase int64) (int64, bool, error)
        - alloc4Signed(tableID int64, n uint64, increment int64, offset int64) (int64, int64, error)
        - alloc4Unsigned(tableID int64, n uint64, increment int64, offset int64) (int64, int64, error)
        - alloc4Sequence(tableID int64) (int64, int64, int64, error)

        + Base() int64
        + End() int64
        + NextGlobalAutoID(tableID int64) (int64, error)
        + Rebase(tableID int64, requiredBase int64, allocIDs bool) error
        + RebaseSeq(tableID int64, requiredBase int64) (int64, bool, error)
        + GetType() AllocatorType
        + Alloc(tableID int64, n uint64, increment int64, offset int64) (int64, int64, error)
        + AllocSeqCache(tableID int64) (int64, int64, int64, error)

    }
    class autoid.AllocatorType << (T, #FF7700) >>  {
    }
    class autoid.Allocators << (T, #FF7700) >>  {
    }
    class autoid.CustomAutoIncCacheOption << (T, #FF7700) >>  {
    }
}

"autoid.AllocOption" <|-- "autoid.CustomAutoIncCacheOption"
"autoid.Allocator" <|-- "autoid.allocator"

namespace bindinfo {
    class BindHandle << (S,Aquamarine) >> {
        - sctx <font color=blue>struct</font>{sync.Mutex, sessionctx.Context}
        - bindInfo <font color=blue>struct</font>{sync.Mutex, atomic.Value, *parser.Parser, types.Time}
        - invalidBindRecordMap tmpBindRecordMap
        - pendingVerifyBindRecordMap tmpBindRecordMap

        - newBindRecord(row chunk.Row) (string, *BindRecord, error)
        - appendBindRecord(hash string, meta *BindRecord) 
        - removeBindRecord(hash string, meta *BindRecord) 
        - deleteBindInfoSQL(normdOrigSQL string, db string, bindSQL string) string
        - insertBindInfoSQL(orignalSQL string, db string, info Binding) string
        - logicalDeleteBindInfoSQL(originalSQL string, db string, updateTs types.Time, bindingSQL string) string
        - getOnePendingVerifyJob() (string, string, Binding)
        - getRunningDuration(sctx sessionctx.Context, db string, sql string, maxTime time.Duration) (time.Duration, error)

        + Update(fullLoad bool) error
        + CreateBindRecord(sctx sessionctx.Context, record *BindRecord) error
        + AddBindRecord(sctx sessionctx.Context, record *BindRecord) error
        + DropBindRecord(originalSQL string, db string, binding *Binding) error
        + DropInvalidBindRecord() 
        + AddDropInvalidBindTask(invalidBindRecord *BindRecord) 
        + Size() int
        + GetBindRecord(hash string, normdOrigSQL string, db string) *BindRecord
        + GetAllBindRecord() []*BindRecord
        + CaptureBaselines() 
        + AddEvolvePlanTask(originalSQL string, DB string, binding Binding) 
        + SaveEvolveTasksToStore() 
        + HandleEvolvePlanTask(sctx sessionctx.Context, adminEvolve bool) error
        + Clear() 
        + FlushBindings() error
        + ReloadBindings() error

    }
    class BindRecord << (S,Aquamarine) >> {
        + OriginalSQL string
        + Db string
        + Bindings []Binding

        - prepareHints(sctx sessionctx.Context) error
        - remove(deleted *BindRecord) *BindRecord
        - removeDeletedBindings() *BindRecord
        - shallowCopy() *BindRecord
        - isSame(other *BindRecord) bool
        - metrics() ([]float64, []int)

        + HasUsingBinding() bool
        + FindBinding(hint string) *Binding

    }
    class Binding << (S,Aquamarine) >> {
        + BindSQL string
        + Status string
        + CreateTime types.Time
        + UpdateTime types.Time
        + Source string
        + Charset string
        + Collation string
        + Hint *hint.HintsSet
        + ID string

        - isSame(rb *Binding) bool
        - size() float64

        + SinceUpdateTime() (time.Duration, error)

    }
    class SessionHandle << (S,Aquamarine) >> {
        - ch cache
        - parser *parser.Parser

        - appendBindRecord(hash string, meta *BindRecord) 

        + CreateBindRecord(sctx sessionctx.Context, record *BindRecord) error
        + DropBindRecord(originalSQL string, db string, binding *Binding) error
        + GetBindRecord(normdOrigSQL string, db string) *BindRecord
        + GetAllBindRecord() []*BindRecord
        + Close() 

    }
    class bindRecordUpdate << (S,Aquamarine) >> {
        - bindRecord *BindRecord
        - updateTime time.Time

    }
    class bindinfo.cache << (T, #FF7700) >>  {
    }
    class bindinfo.sessionBindInfoKeyType << (T, #FF7700) >>  {
    }
    class cache << (S,Aquamarine) >> {
        - removeDeletedBindRecord(hash string, meta *BindRecord) 
        - setBindRecord(hash string, meta *BindRecord) 
        - copy() cache
        - getBindRecord(hash string, normdOrigSQL string, db string) *BindRecord

    }
    class paramMarkerChecker << (S,Aquamarine) >> {
        - hasParamMarker bool

        + Enter(in ast.Node) (ast.Node, bool)
        + Leave(in ast.Node) (ast.Node, bool)

    }
    class sessionBindInfoKeyType << (S,Aquamarine) >> {
        + String() string

    }
    class tmpBindRecordMap << (S,Aquamarine) >> {
        - flushFunc <font color=blue>func</font>(*BindRecord) error

        - flushToStore() 

        + Add(bindRecord *BindRecord) 

    }
}
"atomic.Value" *-- "bindinfo.tmpBindRecordMap"
"sync.Mutex" *-- "bindinfo.tmpBindRecordMap"


namespace binloginfo {
    class BinlogInfo << (S,Aquamarine) >> {
        + Data *binlog.Binlog
        + Client *pump_client.PumpsClient

        + WriteBinlog(clusterID uint64) *WriteResult

    }
    class BinlogRecoverStatus << (S,Aquamarine) >> {
        + Skipped bool
        + SkippedCommitterCounter int32

    }
    class BinlogStatus << (S,Aquamarine) >> {
        + String() string

    }
    class WriteResult << (S,Aquamarine) >> {
        - skipped bool
        - err error

        + Skipped() bool
        + GetError() error

    }
    class binloginfo.BinlogStatus << (T, #FF7700) >>  {
    }
}


namespace bitmap {
    class ConcurrentBitmap << (S,Aquamarine) >> {
        - segments []uint32
        - bitLen int

        + BytesConsumed() int64
        + Set(bitIndex int) bool
        + UnsafeIsSet(bitIndex int) bool

    }
}


namespace cascades {
    class EliminateOuterJoinBelowAggregation << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class EliminateOuterJoinBelowProjection << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class EliminateProjection << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class EliminateSingleMaxMin << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    interface Enforcer  {
        + NewProperty(prop *property.PhysicalProperty) *property.PhysicalProperty
        + OnEnforce(reqProp *property.PhysicalProperty, child memo.Implementation) memo.Implementation
        + GetEnforceCost(g *memo.Group) float64

    }
    class EnumeratePaths << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class ImplApply << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplHashAgg << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplHashJoinBuildLeft << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplHashJoinBuildRight << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplIndexScan << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplLimit << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplMaxOneRow << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplMemTableScan << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplMergeJoin << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplProjection << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplSelection << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplShow << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplSort << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplTableDual << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplTableScan << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplTiKVSingleReadGather << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplTopN << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplTopNAsLimit << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplUnionAll << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class ImplWindow << (S,Aquamarine) >> {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    interface ImplementationRule  {
        + Match(expr *memo.GroupExpr, prop *property.PhysicalProperty) bool
        + OnImplement(expr *memo.GroupExpr, reqProp *property.PhysicalProperty) ([]memo.Implementation, error)

    }
    class InjectProjectionBelowTopN << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class MergeAdjacentLimit << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class MergeAdjacentProjection << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class MergeAdjacentSelection << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class MergeAdjacentTopN << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class MergeAggregationProjection << (S,Aquamarine) >> {
        + Match(old *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class Optimizer << (S,Aquamarine) >> {
        - transformationRuleBatches []TransformationRuleBatch
        - implementationRuleMap <font color=blue>map</font>[memo.Operand][]ImplementationRule

        - onPhasePreprocessing(sctx sessionctx.Context, plan core.LogicalPlan) (core.LogicalPlan, error)
        - onPhaseExploration(sctx sessionctx.Context, g *memo.Group) error
        - exploreGroup(g *memo.Group, round int, ruleBatch TransformationRuleBatch) error
        - findMoreEquiv(g *memo.Group, elem *list.Element, round int, ruleBatch TransformationRuleBatch) (bool, error)
        - fillGroupStats(g *memo.Group) error
        - onPhaseImplementation(sctx sessionctx.Context, g *memo.Group) (core.PhysicalPlan, float64, error)
        - implGroup(g *memo.Group, reqPhysProp *property.PhysicalProperty, costLimit float64) (memo.Implementation, error)
        - implGroupExpr(cur *memo.GroupExpr, reqPhysProp *property.PhysicalProperty) ([]memo.Implementation, error)

        + ResetTransformationRules(ruleBatches ...TransformationRuleBatch) *Optimizer
        + ResetImplementationRules(rules <font color=blue>map</font>[memo.Operand][]ImplementationRule) *Optimizer
        + GetImplementationRules(node core.LogicalPlan) []ImplementationRule
        + FindBestPlan(sctx sessionctx.Context, logical core.LogicalPlan) (core.PhysicalPlan, float64, error)

    }
    class OrderEnforcer << (S,Aquamarine) >> {
        + NewProperty(prop *property.PhysicalProperty) *property.PhysicalProperty
        + OnEnforce(reqProp *property.PhysicalProperty, child memo.Implementation) memo.Implementation
        + GetEnforceCost(g *memo.Group) float64

    }
    class PullSelectionUpApply << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushAggDownGather << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushLimitDownOuterJoin << (S,Aquamarine) >> {
        - pushLimitDownOuterJoinToChild(limit *core.LogicalLimit, outerGroup *memo.Group) *memo.Group

        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushLimitDownProjection << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushLimitDownTiKVSingleGather << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushLimitDownUnionAll << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushSelDownAggregation << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushSelDownIndexScan << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushSelDownJoin << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushSelDownProjection << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushSelDownSort << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushSelDownTableScan << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushSelDownTiKVSingleGather << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushSelDownUnionAll << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushSelDownWindow << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushTopNDownOuterJoin << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushTopNDownProjection << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushTopNDownTiKVSingleGather << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class PushTopNDownUnionAll << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class TransformAggToProj << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class TransformAggregateCaseToSelection << (S,Aquamarine) >> {
        - transform(agg *core.LogicalAggregation) (bool, []expression.Expression, []*aggregation.AggFuncDesc)
        - allowsSelection(aggFuncName string) bool
        - isOnlyOneNotNull(ctx sessionctx.Context, args []expression.Expression, argsNum int, outputIdx int) bool
        - isTwoOrThreeArgCase(expr expression.Expression) bool

        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class TransformApplyToJoin << (S,Aquamarine) >> {
        - extractCorColumnsBySchema(innerGroup *memo.Group, outerSchema *expression.Schema) []*expression.CorrelatedColumn
        - extractCorColumnsFromGroup(g *memo.Group) []*expression.CorrelatedColumn

        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class TransformLimitToTableDual << (S,Aquamarine) >> {
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class TransformLimitToTopN << (S,Aquamarine) >> {
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    interface Transformation  {
        + GetPattern() *memo.Pattern
        + Match(expr *memo.ExprIter) bool
        + OnTransform(old *memo.ExprIter) ([]*memo.GroupExpr, bool, bool, error)

    }
    class baseRule << (S,Aquamarine) >> {
        - pattern *memo.Pattern

        + Match(expr *memo.ExprIter) bool
        + GetPattern() *memo.Pattern

    }
    class cascades.TransformationRuleBatch << (T, #FF7700) >>  {
    }
    class outerJoinEliminator << (S,Aquamarine) >> {
        - prepareForEliminateOuterJoin(joinExpr *memo.GroupExpr) (bool, int, *memo.Group, *memo.Group, set.Int64Set)
        - isInnerJoinKeysContainUniqueKey(innerGroup *memo.Group, joinKeys *expression.Schema) (bool, error)

    }
    class "<font color=blue>map</font>[memo.Operand][]Transformation" as fontcolorbluemapfontmemoOperandTransformation {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"cascades.baseRule" *-- "cascades.EliminateOuterJoinBelowAggregation"
"cascades.outerJoinEliminator" *-- "cascades.EliminateOuterJoinBelowAggregation"
"cascades.baseRule" *-- "cascades.EliminateOuterJoinBelowProjection"
"cascades.outerJoinEliminator" *-- "cascades.EliminateOuterJoinBelowProjection"
"cascades.baseRule" *-- "cascades.EliminateProjection"
"cascades.baseRule" *-- "cascades.EliminateSingleMaxMin"
"cascades.baseRule" *-- "cascades.EnumeratePaths"
"cascades.baseRule" *-- "cascades.InjectProjectionBelowTopN"
"cascades.baseRule" *-- "cascades.MergeAdjacentLimit"
"cascades.baseRule" *-- "cascades.MergeAdjacentProjection"
"cascades.baseRule" *-- "cascades.MergeAdjacentSelection"
"cascades.baseRule" *-- "cascades.MergeAdjacentTopN"
"cascades.baseRule" *-- "cascades.MergeAggregationProjection"
"cascades.baseRule" *-- "cascades.PullSelectionUpApply"
"cascades.baseRule" *-- "cascades.PushAggDownGather"
"cascades.baseRule" *-- "cascades.PushLimitDownOuterJoin"
"cascades.baseRule" *-- "cascades.PushLimitDownProjection"
"cascades.baseRule" *-- "cascades.PushLimitDownTiKVSingleGather"
"cascades.baseRule" *-- "cascades.PushLimitDownUnionAll"
"cascades.baseRule" *-- "cascades.PushSelDownAggregation"
"cascades.baseRule" *-- "cascades.PushSelDownIndexScan"
"cascades.baseRule" *-- "cascades.PushSelDownJoin"
"cascades.baseRule" *-- "cascades.PushSelDownProjection"
"cascades.baseRule" *-- "cascades.PushSelDownSort"
"cascades.baseRule" *-- "cascades.PushSelDownTableScan"
"cascades.baseRule" *-- "cascades.PushSelDownTiKVSingleGather"
"cascades.baseRule" *-- "cascades.PushSelDownUnionAll"
"cascades.baseRule" *-- "cascades.PushSelDownWindow"
"cascades.baseRule" *-- "cascades.PushTopNDownOuterJoin"
"cascades.baseRule" *-- "cascades.PushTopNDownProjection"
"cascades.baseRule" *-- "cascades.PushTopNDownTiKVSingleGather"
"cascades.baseRule" *-- "cascades.PushTopNDownUnionAll"
"cascades.baseRule" *-- "cascades.TransformAggToProj"
"cascades.baseRule" *-- "cascades.TransformAggregateCaseToSelection"
"cascades.baseRule" *-- "cascades.TransformApplyToJoin"
"cascades.baseRule" *-- "cascades.TransformLimitToTableDual"
"cascades.baseRule" *-- "cascades.TransformLimitToTopN"

"cascades.ImplementationRule" <|-- "cascades.ImplApply"
"cascades.ImplementationRule" <|-- "cascades.ImplHashAgg"
"cascades.ImplementationRule" <|-- "cascades.ImplHashJoinBuildLeft"
"cascades.ImplementationRule" <|-- "cascades.ImplHashJoinBuildRight"
"cascades.ImplementationRule" <|-- "cascades.ImplIndexScan"
"cascades.ImplementationRule" <|-- "cascades.ImplLimit"
"cascades.ImplementationRule" <|-- "cascades.ImplMaxOneRow"
"cascades.ImplementationRule" <|-- "cascades.ImplMemTableScan"
"cascades.ImplementationRule" <|-- "cascades.ImplMergeJoin"
"cascades.ImplementationRule" <|-- "cascades.ImplProjection"
"cascades.ImplementationRule" <|-- "cascades.ImplSelection"
"cascades.ImplementationRule" <|-- "cascades.ImplShow"
"cascades.ImplementationRule" <|-- "cascades.ImplSort"
"cascades.ImplementationRule" <|-- "cascades.ImplTableDual"
"cascades.ImplementationRule" <|-- "cascades.ImplTableScan"
"cascades.ImplementationRule" <|-- "cascades.ImplTiKVSingleReadGather"
"cascades.ImplementationRule" <|-- "cascades.ImplTopN"
"cascades.ImplementationRule" <|-- "cascades.ImplTopNAsLimit"
"cascades.ImplementationRule" <|-- "cascades.ImplUnionAll"
"cascades.ImplementationRule" <|-- "cascades.ImplWindow"
"cascades.Enforcer" <|-- "cascades.OrderEnforcer"

namespace chunk {
    class Chunk << (S,Aquamarine) >> {
        - sel []int
        - columns []*Column
        - numVirtualRows int
        - capacity int
        - requiredRows int

        - preAlloc(row Row) uint32
        - insert(rowIdx int, row Row) 
        - appendSel(colIdx int) 

        + MemoryUsage() int64
        + RequiredRows() int
        + SetRequiredRows(requiredRows int, maxChunkSize int) *Chunk
        + IsFull() bool
        + Prune(usedColIdxs []int) *Chunk
        + MakeRef(srcColIdx int, dstColIdx int) 
        + MakeRefTo(dstColIdx int, src *Chunk, srcColIdx int) error
        + SwapColumn(colIdx int, other *Chunk, otherIdx int) error
        + SwapColumns(other *Chunk) 
        + SetNumVirtualRows(numVirtualRows int) 
        + Reset() 
        + CopyConstruct() *Chunk
        + GrowAndReset(maxChunkSize int) 
        + Capacity() int
        + NumCols() int
        + NumRows() int
        + GetRow(idx int) Row
        + AppendRow(row Row) 
        + AppendPartialRow(colOff int, row Row) 
        + AppendRowByColIdxs(row Row, colIdxs []int) int
        + AppendPartialRowByColIdxs(colOff int, row Row, colIdxs []int) int
        + Append(other *Chunk, begin int, end int) 
        + TruncateTo(numRows int) 
        + AppendNull(colIdx int) 
        + AppendInt64(colIdx int, i int64) 
        + AppendUint64(colIdx int, u uint64) 
        + AppendFloat32(colIdx int, f float32) 
        + AppendFloat64(colIdx int, f float64) 
        + AppendString(colIdx int, str string) 
        + AppendBytes(colIdx int, b []byte) 
        + AppendTime(colIdx int, t types.Time) 
        + AppendDuration(colIdx int, dur types.Duration) 
        + AppendMyDecimal(colIdx int, dec *types.MyDecimal) 
        + AppendEnum(colIdx int, enum types.Enum) 
        + AppendSet(colIdx int, set types.Set) 
        + AppendJSON(colIdx int, j json.BinaryJSON) 
        + AppendDatum(colIdx int, d *types.Datum) 
        + Column(colIdx int) *Column
        + SetCol(colIdx int, col *Column) *Column
        + Sel() []int
        + SetSel(sel []int) 
        + Reconstruct() 
        + LowerBound(colIdx int, d *types.Datum) (int, bool)
        + UpperBound(colIdx int, d *types.Datum) int

    }
    class Codec << (S,Aquamarine) >> {
        - colTypes []*types.FieldType

        - encodeColumn(buffer []byte, col *Column) []byte
        - decodeColumn(buffer []byte, col *Column, ordinal int) []byte
        - setAllNotNull(col *Column) 

        + Encode(chk *Chunk) []byte
        + Decode(buffer []byte) (*Chunk, []byte)
        + DecodeToChunk(buffer []byte, chk *Chunk) []byte

    }
    class Column << (S,Aquamarine) >> {
        - length int
        - nullBitmap []byte
        - offsets []int64
        - data []byte
        - elemBuf []byte

        - appendNameValue(name string, val uint64) 
        - typeSize() int
        - isFixed() bool
        - reset() 
        - appendNullBitmap(notNull bool) 
        - appendMultiSameNullBitmap(notNull bool, num int) 
        - finishAppendFixed() 
        - finishAppendVar() 
        - resize(n int, typeSize int, isNull bool) 
        - reserve(n int, estElemSize int) 
        - nullCount() int
        - castSliceHeader(header *reflect.SliceHeader, typeSize int) 
        - getNameValue(rowID int) (string, uint64)
        - reconstruct(sel []int) 

        + AppendDuration(dur types.Duration) 
        + AppendMyDecimal(dec *types.MyDecimal) 
        + AppendJSON(j json.BinaryJSON) 
        + AppendSet(set types.Set) 
        + Reset(eType types.EvalType) 
        + IsNull(rowIdx int) bool
        + CopyConstruct(dst *Column) *Column
        + AppendNull() 
        + AppendInt64(i int64) 
        + AppendUint64(u uint64) 
        + AppendFloat32(f float32) 
        + AppendFloat64(f float64) 
        + AppendString(str string) 
        + AppendBytes(b []byte) 
        + AppendTime(t types.Time) 
        + AppendEnum(enum types.Enum) 
        + SetNull(rowIdx int, isNull bool) 
        + SetNulls(begin int, end int, isNull bool) 
        + ResizeInt64(n int, isNull bool) 
        + ResizeUint64(n int, isNull bool) 
        + ResizeFloat32(n int, isNull bool) 
        + ResizeFloat64(n int, isNull bool) 
        + ResizeDecimal(n int, isNull bool) 
        + ResizeGoDuration(n int, isNull bool) 
        + ResizeTime(n int, isNull bool) 
        + ReserveString(n int) 
        + ReserveBytes(n int) 
        + ReserveJSON(n int) 
        + ReserveSet(n int) 
        + ReserveEnum(n int) 
        + Int64s() []int64
        + Uint64s() []uint64
        + Float32s() []float32
        + Float64s() []float64
        + GoDurations() []time.Duration
        + Decimals() []types.MyDecimal
        + Times() []types.Time
        + GetInt64(rowID int) int64
        + GetUint64(rowID int) uint64
        + GetFloat32(rowID int) float32
        + GetFloat64(rowID int) float64
        + GetDecimal(rowID int) *types.MyDecimal
        + GetString(rowID int) string
        + GetJSON(rowID int) json.BinaryJSON
        + GetBytes(rowID int) []byte
        + GetEnum(rowID int) types.Enum
        + GetSet(rowID int) types.Set
        + GetTime(rowID int) types.Time
        + GetDuration(rowID int, fillFsp int) types.Duration
        + GetRaw(rowID int) []byte
        + SetRaw(rowID int, bs []byte) 
        + CopyReconstruct(sel []int, dst *Column) *Column
        + MergeNulls(cols ...*Column) 

    }
    class Decoder << (S,Aquamarine) >> {
        - intermChk *Chunk
        - codec *Codec
        - remainedRows int

        - decodeColumn(chk *Chunk, ordinal int, requiredRows int) 

        + Decode(chk *Chunk) 
        + Reset(data []byte) 
        + IsFinished() bool
        + RemainedRows() int
        + ReuseIntermChk(chk *Chunk) 

    }
    interface Iterator  {
        + Begin() Row
        + Next() Row
        + End() Row
        + Len() int
        + Current() Row
        + ReachEnd() 
        + Error() error

    }
    class Iterator4Chunk << (S,Aquamarine) >> {
        - chk *Chunk
        - cursor int32
        - numRows int32

        + Begin() Row
        + Next() Row
        + Current() Row
        + End() Row
        + ReachEnd() 
        + Len() int
        + GetChunk() *Chunk
        + Error() error

    }
    class List << (S,Aquamarine) >> {
        - fieldTypes []*types.FieldType
        - initChunkSize int
        - maxChunkSize int
        - length int
        - chunks []*Chunk
        - freelist []*Chunk
        - memTracker *memory.Tracker
        - consumedIdx int

        - allocChunk() *Chunk
        - preAlloc4Row(row Row) RowPtr

        + GetMemTracker() *memory.Tracker
        + Len() int
        + NumChunks() int
        + FieldTypes() []*types.FieldType
        + NumRowsOfChunk(chkID int) int
        + GetChunk(chkIdx int) *Chunk
        + AppendRow(row Row) RowPtr
        + Add(chk *Chunk) 
        + GetRow(ptr RowPtr) Row
        + Reset() 
        + Clear() 
        + Insert(ptr RowPtr, row Row) 
        + Walk(walkFunc ListWalkFunc) error

    }
    class ListInDisk << (S,Aquamarine) >> {
        - fieldTypes []*types.FieldType
        - offsets [][]int64
        - offWrite int64
        - disk *os.File
        - bufWriter *bufio.Writer
        - bufFlushMutex sync.RWMutex
        - diskTracker *disk.Tracker
        - numRowsInDisk int

        - initDiskFile() error
        - flush() error

        + Len() int
        + GetDiskTracker() *disk.Tracker
        + Add(chk *Chunk) error
        + GetChunk(chkIdx int) (*Chunk, error)
        + GetRow(ptr RowPtr) (Row, error)
        + NumRowsOfChunk(chkID int) int
        + NumChunks() int
        + Close() error

    }
    class MutRow << (S,Aquamarine) >> {
        + ToRow() Row
        + Len() int
        + Clone() MutRow
        + SetRow(row Row) 
        + SetValues(vals ...<font color=blue>interface</font>{}) 
        + SetValue(colIdx int, val <font color=blue>interface</font>{}) 
        + SetDatums(datums ...types.Datum) 
        + SetDatum(colIdx int, d types.Datum) 
        + ShallowCopyPartialRow(colIdx int, row Row) 

    }
    class Pool << (S,Aquamarine) >> {
        - initCap int
        - varLenColPool *sync.Pool
        - fixLenColPool4 *sync.Pool
        - fixLenColPool8 *sync.Pool
        - fixLenColPool16 *sync.Pool
        - fixLenColPool40 *sync.Pool

        + GetChunk(fields []*types.FieldType) *Chunk
        + PutChunk(fields []*types.FieldType, chk *Chunk) 

    }
    class Row << (S,Aquamarine) >> {
        - c *Chunk
        - idx int

        - getNameValue(colIdx int) (string, uint64)

        + Chunk() *Chunk
        + IsEmpty() bool
        + Idx() int
        + Len() int
        + GetInt64(colIdx int) int64
        + GetUint64(colIdx int) uint64
        + GetFloat32(colIdx int) float32
        + GetFloat64(colIdx int) float64
        + GetString(colIdx int) string
        + GetBytes(colIdx int) []byte
        + GetTime(colIdx int) types.Time
        + GetDuration(colIdx int, fillFsp int) types.Duration
        + GetEnum(colIdx int) types.Enum
        + GetSet(colIdx int) types.Set
        + GetMyDecimal(colIdx int) *types.MyDecimal
        + GetJSON(colIdx int) json.BinaryJSON
        + GetDatumRow(fields []*types.FieldType) []types.Datum
        + GetDatum(colIdx int, tp *types.FieldType) types.Datum
        + GetRaw(colIdx int) []byte
        + IsNull(colIdx int) bool
        + CopyConstruct() Row

    }
    class RowContainer << (S,Aquamarine) >> {
        - m <font color=blue>struct</font>{sync.RWMutex, *List, *ListInDisk, error, uint32}
        - fieldType []*types.FieldType
        - chunkSize int
        - numRow int
        - memTracker *memory.Tracker
        - diskTracker *disk.Tracker
        - actionSpill *SpillDiskAction

        - alreadySpilled() bool

        + SpillToDisk() 
        + Reset() error
        + AlreadySpilledSafe() bool
        + NumRow() int
        + NumRowsOfChunk(chkID int) int
        + NumChunks() int
        + Add(chk *Chunk) error
        + AllocChunk() *Chunk
        + GetChunk(chkIdx int) (*Chunk, error)
        + GetRow(ptr RowPtr) (Row, error)
        + GetMemTracker() *memory.Tracker
        + GetDiskTracker() *disk.Tracker
        + Close() error
        + ActionSpill() *SpillDiskAction
        + ActionSpillForTest() *SpillDiskAction

    }
    class RowPtr << (S,Aquamarine) >> {
        + ChkIdx uint32
        + RowIdx uint32

    }
    class SortAndSpillDiskAction << (S,Aquamarine) >> {
        - c *SortedRowContainer
        - fallbackAction memory.ActionOnExceed
        - m sync.Mutex
        - testSyncInputFunc <font color=blue>func</font>() 
        - testSyncOutputFunc <font color=blue>func</font>() 
        - testWg sync.WaitGroup

        + Action(t *memory.Tracker) 
        + SetFallback(fallback memory.ActionOnExceed) 
        + SetLogHook(hook <font color=blue>func</font>(uint64) ) 
        + ResetRowContainer(c *SortedRowContainer) 
        + WaitForTest() 

    }
    class SortedRowContainer << (S,Aquamarine) >> {
        - ptrM <font color=blue>struct</font>{sync.RWMutex, []RowPtr}
        - keyColumns []int
        - keyCmpFuncs []CompareFunc
        - actionSpill *SortAndSpillDiskAction

        + ByItemsDesc []bool

        - lessRow(rowI Row, rowJ Row) bool
        - keyColumnsLess(i int, j int) bool
        - sortAndSpillToDisk() 

        + Close() error
        + Sort() 
        + Add(chk *Chunk) error
        + GetSortedRow(idx int) (Row, error)
        + ActionSpill() *SortAndSpillDiskAction
        + ActionSpillForTest() *SortAndSpillDiskAction

    }
    class SpillDiskAction << (S,Aquamarine) >> {
        - c *RowContainer
        - fallbackAction memory.ActionOnExceed
        - m sync.Mutex
        - testSyncInputFunc <font color=blue>func</font>() 
        - testSyncOutputFunc <font color=blue>func</font>() 
        - testWg sync.WaitGroup

        + Action(t *memory.Tracker) 
        + SetFallback(fallback memory.ActionOnExceed) 
        + SetLogHook(hook <font color=blue>func</font>(uint64) ) 
        + ResetRowContainer(c *RowContainer) 
        + WaitForTest() 

    }
    class chunk.CompareFunc << (T, #FF7700) >>  {
    }
    class chunk.ListWalkFunc << (T, #FF7700) >>  {
    }
    class chunk.MutRow << (T, #FF7700) >>  {
    }
    class chunkInDisk << (S,Aquamarine) >> {
        - offWrite int64
        - offsetsOfRows []int64

        - getOffsetsOfRows() []int64

        + WriteTo(w io.Writer) (int64, error)

    }
    class diskFormatRow << (S,Aquamarine) >> {
        - sizesOfColumns []int64
        - cells [][]byte

        - toMutRow(fields []*types.FieldType) MutRow

    }
    class iterator4List << (S,Aquamarine) >> {
        - li *List
        - chkCursor int
        - rowCursor int

        + Begin() Row
        + Next() Row
        + Current() Row
        + End() Row
        + ReachEnd() 
        + Len() int
        + Error() error

    }
    class iterator4RowContainer << (S,Aquamarine) >> {
        - c *RowContainer
        - chkIdx int
        - rowIdx int
        - err error

        - setNextPtr() 

        + Len() int
        + Begin() Row
        + Next() Row
        + Current() Row
        + End() Row
        + ReachEnd() 
        + Error() error

    }
    class iterator4RowPtr << (S,Aquamarine) >> {
        - li *List
        - ptrs []RowPtr
        - cursor int

        + Begin() Row
        + Next() Row
        + Current() Row
        + End() Row
        + ReachEnd() 
        + Len() int
        + Error() error

    }
    class iterator4Slice << (S,Aquamarine) >> {
        - rows []Row
        - cursor int

        + Begin() Row
        + Next() Row
        + Current() Row
        + End() Row
        + ReachEnd() 
        + Len() int
        + Error() error

    }
    class multiIterator << (S,Aquamarine) >> {
        - iters []Iterator
        - numIter int
        - length int
        - curPtr int
        - curIter Iterator
        - err error

        + Len() int
        + Begin() Row
        + Next() Row
        + Current() Row
        + End() Row
        + ReachEnd() 
        + Error() error

    }
    class rowInDisk << (S,Aquamarine) >> {
        - numCol int

        + WriteTo(w io.Writer) (int64, error)
        + ReadFrom(r io.Reader) (int64, error)

    }
}
"chunk.RowContainer" *-- "chunk.SortedRowContainer"
"chunk.Chunk" *-- "chunk.chunkInDisk"
"chunk.diskFormatRow" *-- "chunk.rowInDisk"

"chunk.Iterator" <|-- "chunk.Iterator4Chunk"
"executor.Closeable" <|-- "chunk.ListInDisk"
"executor.Closeable" <|-- "chunk.RowContainer"
"memory.ActionOnExceed" <|-- "chunk.SortAndSpillDiskAction"
"executor.Closeable" <|-- "chunk.SortedRowContainer"
"memory.ActionOnExceed" <|-- "chunk.SpillDiskAction"
"chunk.Iterator" <|-- "chunk.iterator4List"
"chunk.Iterator" <|-- "chunk.iterator4RowContainer"
"chunk.Iterator" <|-- "chunk.iterator4RowPtr"
"chunk.Iterator" <|-- "chunk.iterator4Slice"
"chunk.Iterator" <|-- "chunk.multiIterator"

namespace codec {
    class Decoder << (S,Aquamarine) >> {
        - chk *chunk.Chunk
        - timezone *time.Location
        - buf []byte

        + DecodeOne(b []byte, colIdx int, ft *types.FieldType) ([]byte, error)

    }
}


namespace collate {
    interface Collator  {
        + Compare(a string, b string) int
        + Key(str string) []byte
        + Pattern() WildcardPattern

    }
    interface WildcardPattern  {
        + Compile(patternStr string, escape byte) 
        + DoMatch(str string) bool

    }
    class binCollator << (S,Aquamarine) >> {
        + Compare(a string, b string) int
        + Key(str string) []byte
        + Pattern() WildcardPattern

    }
    class binPaddingCollator << (S,Aquamarine) >> {
        + Compare(a string, b string) int
        + Key(str string) []byte
        + Pattern() WildcardPattern

    }
    class binPattern << (S,Aquamarine) >> {
        - patChars []byte
        - patTypes []byte

        + Compile(patternStr string, escape byte) 
        + DoMatch(str string) bool

    }
    class ciPattern << (S,Aquamarine) >> {
        - patChars []uint16
        - patTypes []byte

        + Compile(patternStr string, escape byte) 
        + DoMatch(str string) bool

    }
    class generalCICollator << (S,Aquamarine) >> {
        + Compare(a string, b string) int
        + Key(str string) []byte
        + Pattern() WildcardPattern

    }
}

"collate.Collator" <|-- "collate.binCollator"
"collate.Collator" <|-- "collate.binPaddingCollator"
"collate.WildcardPattern" <|-- "collate.binPattern"
"collate.WildcardPattern" <|-- "collate.ciPattern"
"collate.Collator" <|-- "collate.generalCICollator"

namespace config {
    class Binlog << (S,Aquamarine) >> {
        + Enable bool
        + IgnoreError bool
        + WriteTimeout string
        + BinlogSocket string
        + Strategy string

    }
    class Config << (S,Aquamarine) >> {
        + Host string
        + AdvertiseAddress string
        + Port uint
        + Cors string
        + Store string
        + Path string
        + Socket string
        + Lease string
        + RunDDL bool
        + SplitTable bool
        + TokenLimit uint
        + OOMUseTmpStorage bool
        + TempStoragePath string
        + OOMAction string
        + MemQuotaQuery int64
        + TempStorageQuota int64
        + EnableStreaming bool
        + EnableBatchDML bool
        + TxnLocalLatches TxnLocalLatches
        + LowerCaseTableNames int
        + ServerVersion string
        + Log Log
        + Security Security
        + Status Status
        + Performance Performance
        + PreparedPlanCache PreparedPlanCache
        + OpenTracing OpenTracing
        + ProxyProtocol ProxyProtocol
        + TiKVClient TiKVClient
        + Binlog Binlog
        + CompatibleKillQuery bool
        + Plugin Plugin
        + PessimisticTxn PessimisticTxn
        + CheckMb4ValueInUTF8 bool
        + MaxIndexLength int
        + AlterPrimaryKey bool
        + TreatOldVersionUTF8AsUTF8MB4 bool
        + EnableTableLock bool
        + DelayCleanTableLock uint64
        + SplitRegionMaxNum uint64
        + StmtSummary StmtSummary
        + RepairMode bool
        + RepairTableList []string
        + IsolationRead IsolationRead
        + MaxServerConnections uint32
        + NewCollationsEnabledOnFirstBootstrap bool
        + Experimental Experimental
        + EnableCollectExecutionInfo bool
        + EnableTelemetry bool

        + UpdateTempStoragePath() 
        + Load(confFile string) error
        + Valid() error

    }
    class CoprocessorCache << (S,Aquamarine) >> {
        + Enable bool
        + CapacityMB float64
        + AdmissionMaxResultMB float64
        + AdmissionMinProcessMs uint64

    }
    class ErrConfigValidationFailed << (S,Aquamarine) >> {
        - confFile string

        + UndecodedItems []string

        + Error() string

    }
    class Experimental << (S,Aquamarine) >> {
        + AllowAutoRandom bool
        + AllowsExpressionIndex bool

    }
    class IsolationRead << (S,Aquamarine) >> {
        + Engines []string

    }
    class Log << (S,Aquamarine) >> {
        + Level string
        + Format string
        + DisableTimestamp nullableBool
        + EnableTimestamp nullableBool
        + DisableErrorStack nullableBool
        + EnableErrorStack nullableBool
        + File logutil.FileLogConfig
        + EnableSlowLog bool
        + SlowQueryFile string
        + SlowThreshold uint64
        + ExpensiveThreshold uint
        + QueryLogMaxLen uint64
        + RecordPlanInSlowLog uint32

        - getDisableTimestamp() bool
        - getDisableErrorStack() bool

        + ToLogConfig() *logutil.LogConfig

    }
    class OpenTracing << (S,Aquamarine) >> {
        + Enable bool
        + RPCMetrics bool
        + Sampler OpenTracingSampler
        + Reporter OpenTracingReporter

        + ToTracingConfig() *config.Configuration

    }
    class OpenTracingReporter << (S,Aquamarine) >> {
        + QueueSize int
        + BufferFlushInterval time.Duration
        + LogSpans bool
        + LocalAgentHostPort string

    }
    class OpenTracingSampler << (S,Aquamarine) >> {
        + Type string
        + Param float64
        + SamplingServerURL string
        + MaxOperations int
        + SamplingRefreshInterval time.Duration

    }
    class Performance << (S,Aquamarine) >> {
        + MaxProcs uint
        + MaxMemory uint64
        + StatsLease string
        + StmtCountLimit uint
        + FeedbackProbability float64
        + QueryFeedbackLimit uint
        + PseudoEstimateRatio float64
        + ForcePriority string
        + BindInfoLease string
        + TxnTotalSizeLimit uint64
        + TCPKeepAlive bool
        + CrossJoin bool
        + RunAutoAnalyze bool
        + DistinctAggPushDown bool
        + CommitterConcurrency int
        + MaxTxnTTL uint64

    }
    class PessimisticTxn << (S,Aquamarine) >> {
        + Enable bool
        + MaxRetryCount uint

    }
    class PlanCache << (S,Aquamarine) >> {
        + Enabled bool
        + Capacity uint
        + Shards uint

    }
    class Plugin << (S,Aquamarine) >> {
        + Dir string
        + Load string

    }
    class PreparedPlanCache << (S,Aquamarine) >> {
        + Enabled bool
        + Capacity uint
        + MemoryGuardRatio float64

    }
    class ProxyProtocol << (S,Aquamarine) >> {
        + Networks string
        + HeaderTimeout uint

    }
    class Security << (S,Aquamarine) >> {
        + SkipGrantTable bool
        + SSLCA string
        + SSLCert string
        + SSLKey string
        + RequireSecureTransport bool
        + ClusterSSLCA string
        + ClusterSSLCert string
        + ClusterSSLKey string
        + ClusterVerifyCN []string

        + ToTLSConfig() (*tls.Config, error)

    }
    class Status << (S,Aquamarine) >> {
        + StatusHost string
        + MetricsAddr string
        + StatusPort uint
        + MetricsInterval uint
        + ReportStatus bool
        + RecordQPSbyDB bool

    }
    class StmtSummary << (S,Aquamarine) >> {
        + Enable bool
        + EnableInternalQuery bool
        + MaxStmtCount uint
        + MaxSQLLength uint
        + RefreshInterval int
        + HistorySize int

    }
    class TiKVClient << (S,Aquamarine) >> {
        + GrpcConnectionCount uint
        + GrpcKeepAliveTime uint
        + GrpcKeepAliveTimeout uint
        + CommitTimeout string
        + MaxBatchSize uint
        + OverloadThreshold uint
        + MaxBatchWaitTime time.Duration
        + BatchWaitSize uint
        + EnableChunkRPC bool
        + RegionCacheTTL uint
        + StoreLimit int64
        + StoreLivenessTimeout string
        + CoprCache CoprocessorCache

    }
    class TxnLocalLatches << (S,Aquamarine) >> {
        + Enabled bool
        + Capacity uint

    }
    class config.ConfReloadFunc << (T, #FF7700) >>  {
    }
    class nullableBool << (S,Aquamarine) >> {
        + IsValid bool
        + IsTrue bool

        - toBool() bool

        + MarshalJSON() ([]byte, error)
        + UnmarshalText(text []byte) error
        + MarshalText() ([]byte, error)
        + UnmarshalJSON(data []byte) error

    }
}


namespace core {
    class AdminPlugins << (S,Aquamarine) >> {
        + Action AdminPluginsAction
        + Plugins []string

    }
    class AdminResetTelemetryID << (S,Aquamarine) >> {
    }
    class AdminShowTelemetry << (S,Aquamarine) >> {
    }
    class AggInfo << (S,Aquamarine) >> {
        + AggFuncs []*aggregation.AggFuncDesc
        + GroupByItems []expression.Expression
        + Schema *expression.Schema

    }
    class AggregateFuncExtractor << (S,Aquamarine) >> {
        - inAggregateFuncExpr bool

        + AggFuncs []*ast.AggregateFuncExpr

        + Enter(n ast.Node) (ast.Node, bool)
        + Leave(n ast.Node) (ast.Node, bool)

    }
    class Analyze << (S,Aquamarine) >> {
        + ColTasks []AnalyzeColumnsTask
        + IdxTasks []AnalyzeIndexTask
        + Opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64

    }
    class AnalyzeColumnsTask << (S,Aquamarine) >> {
        + PKInfo *model.ColumnInfo
        + ColsInfo []*model.ColumnInfo
        + TblInfo *model.TableInfo

    }
    class AnalyzeIndexTask << (S,Aquamarine) >> {
        + IndexInfo *model.IndexInfo
        + TblInfo *model.TableInfo

    }
    class BatchPointGetPlan << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - dbName string

        + TblInfo *model.TableInfo
        + IndexInfo *model.IndexInfo
        + Handles []int64
        + HandleParams []*parser_driver.ParamMarkerExpr
        + IndexValues [][]types.Datum
        + IndexValueParams [][]*parser_driver.ParamMarkerExpr
        + PartitionColPos int
        + KeepOrder bool
        + Desc bool
        + Lock bool
        + LockWaitTime int64
        + Columns []*model.ColumnInfo

        - attach2Task( ...task) task
        - statsInfo() *property.StatsInfo

        + ToPB(ctx sessionctx.Context) (*tipb.Executor, error)
        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + AccessObject() string
        + OperatorInfo(normalized bool) string
        + GetChildReqProps(idx int) *property.PhysicalProperty
        + StatsCount() float64
        + Children() []PhysicalPlan
        + SetChildren( ...PhysicalPlan) 
        + SetChild(i int, child PhysicalPlan) 
        + ResolveIndices() error
        + OutputNames() types.NameSlice
        + SetOutputNames(names types.NameSlice) 
        + GetCost(cols []*expression.Column) float64
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, schema *expression.Schema, names []*types.FieldName, offset int) *BatchPointGetPlan

    }
    class CachedPrepareStmt << (S,Aquamarine) >> {
        + PreparedAst *ast.Prepared
        + VisitInfos []visitInfo
        + ColumnInfos <font color=blue>interface</font>{}
        + Executor <font color=blue>interface</font>{}
        + NormalizedSQL string
        + NormalizedPlan string
        + SQLDigest string
        + PlanDigest string

    }
    class CancelDDLJobs << (S,Aquamarine) >> {
        + JobIDs []int64

    }
    class Change << (S,Aquamarine) >> {
    }
    class CheckIndexRange << (S,Aquamarine) >> {
        + Table *ast.TableName
        + IndexName string
        + HandleRanges []ast.HandleRange

    }
    class CheckTable << (S,Aquamarine) >> {
        + DBName string
        + Table table.Table
        + IndexInfos []*model.IndexInfo
        + IndexLookUpReaders []*PhysicalIndexLookUpReader
        + CheckIndex bool

    }
    class ChecksumTable << (S,Aquamarine) >> {
        + Tables []*ast.TableName

    }
    class CleanupIndex << (S,Aquamarine) >> {
        + Table *ast.TableName
        + IndexName string

    }
    class ClusterLogTableExtractor << (S,Aquamarine) >> {
        + SkipRequest bool
        + NodeTypes set.StringSet
        + Instances set.StringSet
        + StartTime int64
        + EndTime int64
        + Patterns []string
        + LogLevels set.StringSet

        - explainInfo(p *PhysicalMemTable) string

        + Extract(ctx sessionctx.Context, schema *expression.Schema, names []*types.FieldName, predicates []expression.Expression) []expression.Expression

    }
    class ClusterTableExtractor << (S,Aquamarine) >> {
        + SkipRequest bool
        + NodeTypes set.StringSet
        + Instances set.StringSet

        - explainInfo(p *PhysicalMemTable) string

        + Extract(_ sessionctx.Context, schema *expression.Schema, names []*types.FieldName, predicates []expression.Expression) []expression.Expression

    }
    class ColWithCmpFuncManager << (S,Aquamarine) >> {
        - colLength int
        - opArg []expression.Expression
        - affectedColSchema *expression.Schema
        - compareFuncs []chunk.CompareFunc

        + TargetCol *expression.Column
        + OpType []string
        + TmpConstant []*expression.Constant

        - appendNewExpr(opName string, arg expression.Expression, affectedCols []*expression.Column) 
        - resolveIndices(schema *expression.Schema) error

        + CompareRow(lhs chunk.Row, rhs chunk.Row) int
        + BuildRangesByRow(ctx sessionctx.Context, row chunk.Row) ([]*ranger.Range, error)
        + String() string

    }
    class DDL << (S,Aquamarine) >> {
        + Statement ast.DDLNode

    }
    class DataSource << (S,Aquamarine) >> {
        - indexHints []*ast.IndexHint
        - table table.Table
        - tableInfo *model.TableInfo
        - indexMergeHints []*ast.IndexHint
        - pushedDownConds []expression.Expression
        - allConds []expression.Expression
        - statisticTable *statistics.Table
        - tableStats *property.StatsInfo
        - possibleAccessPaths []*util.AccessPath
        - isPartition bool
        - physicalTableID int64
        - partitionNames []model.CIStr
        - handleCol *expression.Column
        - preferStoreType int

        + Columns []*model.ColumnInfo
        + DBName model.CIStr
        + TableAsName *model.CIStr
        + TblCols []*expression.Column
        + TblColHists *statistics.HistColl

        - tryToGetDualTask() (task, error)
        - getTableCandidate(path *util.AccessPath, prop *property.PhysicalProperty) *candidatePath
        - getIndexCandidate(path *util.AccessPath, prop *property.PhysicalProperty, isSingleScan bool) *candidatePath
        - getIndexMergeCandidate(path *util.AccessPath) *candidatePath
        - skylinePruning(prop *property.PhysicalProperty) []*candidatePath
        - findBestTask(prop *property.PhysicalProperty) (task, error)
        - canConvertToPointGet(candidate *candidatePath) bool
        - convertToIndexMergeScan(prop *property.PhysicalProperty, candidate *candidatePath) (task, error)
        - convertToPartialIndexScan(prop *property.PhysicalProperty, path *util.AccessPath) (PhysicalPlan, float64, float64)
        - convertToPartialTableScan(prop *property.PhysicalProperty, path *util.AccessPath) (PhysicalPlan, float64, float64)
        - buildIndexMergeTableScan(prop *property.PhysicalProperty, tableFilters []expression.Expression, totalRowCount float64) (PhysicalPlan, float64)
        - convertToIndexScan(prop *property.PhysicalProperty, candidate *candidatePath) (task, error)
        - crossEstimateRowCount(path *util.AccessPath, expectedCnt float64, desc bool) (float64, bool, float64)
        - convertToTableScan(prop *property.PhysicalProperty, candidate *candidatePath) (task, error)
        - convertToPointGet(prop *property.PhysicalProperty, candidate *candidatePath) task
        - convertToBatchPointGet(prop *property.PhysicalProperty, candidate *candidatePath) task
        - getOriginalPhysicalTableScan(prop *property.PhysicalProperty, path *util.AccessPath, isMatchProp bool) (*PhysicalTableScan, float64, float64)
        - getOriginalPhysicalIndexScan(prop *property.PhysicalProperty, path *util.AccessPath, isMatchProp bool, isSingleScan bool) (*PhysicalIndexScan, float64, float64)
        - buildTableGather() LogicalPlan
        - buildIndexGather(path *util.AccessPath) LogicalPlan
        - deriveTablePathStats(path *util.AccessPath, conds []expression.Expression, isIm bool) (bool, error)
        - fillIndexPath(path *util.AccessPath, conds []expression.Expression) error
        - deriveIndexPathStats(path *util.AccessPath, conds []expression.Expression, isIm bool) bool
        - getPKIsHandleCol() *expression.Column
        - getHandleCol() *expression.Column
        - setPreferredStoreType(hintInfo *tableHintInfo) 
        - newExtraHandleSchemaCol() *expression.Column
        - getColumnNDV(colID int64) float64
        - initStats() 
        - deriveStatsByFilter(conds expression.CNFExprs, filledPaths []*util.AccessPath) *property.StatsInfo
        - generateAndPruneIndexMergePath(needPrune bool) 
        - generateIndexMergeOrPaths() 
        - isInIndexMergeHints(name string) bool
        - accessPathsForConds(conditions []expression.Expression, usedIndexCount int) []*util.AccessPath
        - buildIndexMergePartialPath(indexAccessPaths []*util.AccessPath) *util.AccessPath
        - buildIndexMergeOrPath(partialPaths []*util.AccessPath, current int) *util.AccessPath

        + PruneColumns(parentUsedCols []*expression.Column) error
        + ExtractCorrelatedCols() []*expression.CorrelatedColumn
        + Convert2Gathers() []LogicalPlan
        + TableInfo() *model.TableInfo
        + ExplainInfo() string
        + PredicatePushDown(predicates []expression.Expression) ([]expression.Expression, LogicalPlan)
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + Init(ctx sessionctx.Context, offset int) *DataSource
        + PreparePossibleProperties(schema *expression.Schema, childrenProperties ...[][]*expression.Column) [][]*expression.Column
        + BuildKeyInfo(selfSchema *expression.Schema, childSchema []*expression.Schema) 

    }
    class Deallocate << (S,Aquamarine) >> {
        + Name string

    }
    class Delete << (S,Aquamarine) >> {
        + IsMultiTable bool
        + SelectPlan PhysicalPlan
        + TblColPosInfos TblColPosInfoSlice

        - cleanTblID2HandleMap(tablesToDelete <font color=blue>map</font>[int64][]*ast.TableName, tblID2Handle <font color=blue>map</font>[int64][]*expression.Column, outputNames []*types.FieldName) <font color=blue>map</font>[int64][]*expression.Column
        - matchingDeletingTable(names []*ast.TableName, name *types.FieldName) bool

        + Init(ctx sessionctx.Context) *Delete

    }
    class ErrExprLoc << (S,Aquamarine) >> {
        + Offset int
        + Loc string

    }
    class Execute << (S,Aquamarine) >> {
        + Name string
        + UsingVars []expression.Expression
        + PrepareParams []types.Datum
        + ExecID uint32
        + Stmt ast.StmtNode
        + StmtType string
        + Plan Plan

        - checkPreparedPriv(ctx context.Context, sctx sessionctx.Context, preparedObj *CachedPrepareStmt, is infoschema.InfoSchema) error
        - setFoundInPlanCache(sctx sessionctx.Context, opt bool) error
        - getPhysicalPlan(ctx context.Context, sctx sessionctx.Context, is infoschema.InfoSchema, preparedStmt *CachedPrepareStmt) error
        - tryCachePointPlan(ctx context.Context, sctx sessionctx.Context, preparedStmt *CachedPrepareStmt, is infoschema.InfoSchema, p Plan) error
        - rebuildRange(p Plan) error
        - buildRangeForIndexScan(sctx sessionctx.Context, is *PhysicalIndexScan) ([]*ranger.Range, error)

        + OptimizePreparedPlan(ctx context.Context, sctx sessionctx.Context, is infoschema.InfoSchema) error

    }
    class Explain << (S,Aquamarine) >> {
        - explainedPlans <font color=blue>map</font>[int]bool

        + TargetPlan Plan
        + Format string
        + Analyze bool
        + ExecStmt ast.StmtNode
        + Rows [][]string

        - prepareSchema() error
        - explainPlanInRowFormat(p Plan, taskType string, driverSide string, indent string, isLastChild bool) error
        - prepareOperatorInfo(p Plan, taskType string, driverSide string, indent string, isLastChild bool) 
        - prepareDotInfo(p PhysicalPlan) 
        - prepareTaskDot(p PhysicalPlan, taskTp string, buffer *bytes.Buffer) 

        + RenderResult() error

    }
    class FrameBound << (S,Aquamarine) >> {
        + Type ast.BoundType
        + UnBounded bool
        + Num uint64
        + CalcFuncs []expression.Expression
        + CmpFuncs []expression.CompareFunc

    }
    class IndexAdvise << (S,Aquamarine) >> {
        + IsLocal bool
        + Path string
        + MaxMinutes uint64
        + MaxIndexNum *ast.MaxIndexNumClause
        + LinesInfo *ast.LinesClause

    }
    class Insert << (S,Aquamarine) >> {
        - tableSchema *expression.Schema
        - tableColNames types.NameSlice
        - names4OnDuplicate types.NameSlice

        + Table table.Table
        + Columns []*ast.ColumnName
        + Lists [][]expression.Expression
        + SetList []*expression.Assignment
        + OnDuplicate []*expression.Assignment
        + Schema4OnDuplicate *expression.Schema
        + GenCols InsertGeneratedColumns
        + SelectPlan PhysicalPlan
        + IsReplace bool
        + NeedFillDefaultValue bool
        + AllAssignmentsAreConstant bool

        - resolveOnDuplicate(onDup []*ast.Assignment, tblInfo *model.TableInfo, yield <font color=blue>func</font>(ast.ExprNode) (expression.Expression, error)) (<font color=blue>map</font>[string]<font color=blue>struct</font>{}, error)

        + Init(ctx sessionctx.Context) *Insert
        + ResolveIndices() error

    }
    class InsertGeneratedColumns << (S,Aquamarine) >> {
        + Columns []*ast.ColumnName
        + Exprs []expression.Expression
        + OnDuplicates []*expression.Assignment

    }
    class InspectionResultTableExtractor << (S,Aquamarine) >> {
        + SkipInspection bool
        + Rules set.StringSet
        + Items set.StringSet

        - explainInfo(p *PhysicalMemTable) string

        + Extract(_ sessionctx.Context, schema *expression.Schema, names []*types.FieldName, predicates []expression.Expression) []expression.Expression

    }
    class InspectionRuleTableExtractor << (S,Aquamarine) >> {
        + SkipRequest bool
        + Types set.StringSet

        - explainInfo(p *PhysicalMemTable) string

        + Extract(_ sessionctx.Context, schema *expression.Schema, names []*types.FieldName, predicates []expression.Expression) []expression.Expression

    }
    class InspectionSummaryTableExtractor << (S,Aquamarine) >> {
        + SkipInspection bool
        + Rules set.StringSet
        + MetricNames set.StringSet
        + Quantiles []float64

        - explainInfo(p *PhysicalMemTable) string

        + Extract(_ sessionctx.Context, schema *expression.Schema, names []*types.FieldName, predicates []expression.Expression) []expression.Expression

    }
    class JoinType << (S,Aquamarine) >> {
        + IsOuterJoin() bool
        + String() string

    }
    class LoadData << (S,Aquamarine) >> {
        + IsLocal bool
        + OnDuplicate ast.OnDuplicateKeyHandlingType
        + Path string
        + Table *ast.TableName
        + Columns []*ast.ColumnName
        + FieldsInfo *ast.FieldsClause
        + LinesInfo *ast.LinesClause
        + IgnoreLines uint64
        + GenCols InsertGeneratedColumns

    }
    class LoadStats << (S,Aquamarine) >> {
        + Path string

    }
    class LogicalAggregation << (S,Aquamarine) >> {
        - groupByCols []*expression.Column
        - aggHints aggHintInfo
        - possibleProperties [][]*expression.Column
        - inputCount float64

        + AggFuncs []*aggregation.AggFuncDesc
        + GroupByItems []expression.Expression

        - replaceExprColumns(replace <font color=blue>map</font>[string]*expression.Column) 
        - canPushToCop() bool
        - getEnforcedStreamAggs(prop *property.PhysicalProperty) []PhysicalPlan
        - distinctArgsMeetsProperty() bool
        - getStreamAggs(prop *property.PhysicalProperty) []PhysicalPlan
        - getHashAggs(prop *property.PhysicalProperty) []PhysicalPlan
        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)
        - collectGroupByColumns() 
        - canPullUp() bool

        + PruneColumns(parentUsedCols []*expression.Column) error
        + HasDistinct() bool
        + CopyAggHints(agg *LogicalAggregation) 
        + IsPartialModeAgg() bool
        + IsCompleteModeAgg() bool
        + GetGroupByCols() []*expression.Column
        + ExtractCorrelatedCols() []*expression.CorrelatedColumn
        + GetUsedCols() []*expression.Column
        + ResetHintIfConflicted() (bool, bool)
        + ExplainInfo() string
        + PredicatePushDown(predicates []expression.Expression) ([]expression.Expression, LogicalPlan)
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + Init(ctx sessionctx.Context, offset int) *LogicalAggregation
        + PreparePossibleProperties(schema *expression.Schema, childrenProperties ...[][]*expression.Column) [][]*expression.Column
        + BuildKeyInfo(selfSchema *expression.Schema, childSchema []*expression.Schema) 

    }
    class LogicalApply << (S,Aquamarine) >> {
        + CorCols []*expression.CorrelatedColumn

        - replaceExprColumns(replace <font color=blue>map</font>[string]*expression.Column) 
        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)
        - canPullUpAgg() bool
        - deCorColFromEqExpr(expr expression.Expression) expression.Expression

        + PruneColumns(parentUsedCols []*expression.Column) error
        + ExtractCorrelatedCols() []*expression.CorrelatedColumn
        + GetHashJoin(prop *property.PhysicalProperty) *PhysicalHashJoin
        + ExplainInfo() string
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + Init(ctx sessionctx.Context, offset int) *LogicalApply

    }
    class LogicalIndexScan << (S,Aquamarine) >> {
        + Source *DataSource
        + IsDoubleRead bool
        + EqCondCount int
        + AccessConds expression.CNFExprs
        + Ranges []*ranger.Range
        + Index *model.IndexInfo
        + Columns []*model.ColumnInfo
        + FullIdxCols []*expression.Column
        + FullIdxColLens []int
        + IdxCols []*expression.Column
        + IdxColLens []int

        - getPKIsHandleCol(schema *expression.Schema) *expression.Column

        + GetPhysicalIndexScan(schema *expression.Schema, stats *property.StatsInfo) *PhysicalIndexScan
        + MatchIndexProp(prop *property.PhysicalProperty) bool
        + ExplainInfo() string
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + Init(ctx sessionctx.Context, offset int) *LogicalIndexScan
        + PreparePossibleProperties(schema *expression.Schema, childrenProperties ...[][]*expression.Column) [][]*expression.Column
        + BuildKeyInfo(selfSchema *expression.Schema, childSchema []*expression.Schema) 

    }
    class LogicalJoin << (S,Aquamarine) >> {
        - reordered bool
        - cartesianJoin bool
        - hintInfo *tableHintInfo
        - preferJoinType uint
        - leftProperties [][]*expression.Column
        - rightProperties [][]*expression.Column
        - redundantSchema *expression.Schema
        - redundantNames types.NameSlice
        - equalCondOutCnt float64

        + JoinType JoinType
        + StraightJoin bool
        + EqualConditions []*expression.ScalarFunction
        + LeftConditions expression.CNFExprs
        + RightConditions expression.CNFExprs
        + OtherConditions expression.CNFExprs
        + DefaultValues []types.Datum

        - replaceExprColumns(replace <font color=blue>map</font>[string]*expression.Column) 
        - extractUsedCols(parentUsedCols []*expression.Column) ([]*expression.Column, []*expression.Column)
        - mergeSchema() 
        - columnSubstitute(schema *expression.Schema, exprs []expression.Expression) 
        - moveEqualToOtherConditions(offsets []int) []expression.Expression
        - checkJoinKeyCollation(leftKeys []*expression.Column, rightKeys []*expression.Column) bool
        - getEnforcedMergeJoin(prop *property.PhysicalProperty, schema *expression.Schema, statsInfo *property.StatsInfo) []PhysicalPlan
        - getHashJoins(prop *property.PhysicalProperty) []PhysicalPlan
        - getHashJoin(prop *property.PhysicalProperty, innerIdx int, useOuterToBuild bool) *PhysicalHashJoin
        - constructIndexJoin(prop *property.PhysicalProperty, outerIdx int, innerTask task, ranges []*ranger.Range, keyOff2IdxOff []int, path *util.AccessPath, compareFilters *ColWithCmpFuncManager) []PhysicalPlan
        - constructIndexMergeJoin(prop *property.PhysicalProperty, outerIdx int, innerTask task, ranges []*ranger.Range, keyOff2IdxOff []int, path *util.AccessPath, compareFilters *ColWithCmpFuncManager) []PhysicalPlan
        - constructIndexHashJoin(prop *property.PhysicalProperty, outerIdx int, innerTask task, ranges []*ranger.Range, keyOff2IdxOff []int, path *util.AccessPath, compareFilters *ColWithCmpFuncManager) []PhysicalPlan
        - getIndexJoinByOuterIdx(prop *property.PhysicalProperty, outerIdx int) []PhysicalPlan
        - buildIndexJoinInner2TableScan(prop *property.PhysicalProperty, ds *DataSource, innerJoinKeys []*expression.Column, outerJoinKeys []*expression.Column, outerIdx int, us *LogicalUnionScan, avgInnerRowCnt float64) []PhysicalPlan
        - buildIndexJoinInner2IndexScan(prop *property.PhysicalProperty, ds *DataSource, innerJoinKeys []*expression.Column, outerJoinKeys []*expression.Column, outerIdx int, us *LogicalUnionScan, avgInnerRowCnt float64) []PhysicalPlan
        - constructInnerTableScanTask(ds *DataSource, pk *expression.Column, outerJoinKeys []*expression.Column, us *LogicalUnionScan, keepOrder bool, desc bool, rowCount float64) task
        - constructInnerUnionScan(us *LogicalUnionScan, reader PhysicalPlan) PhysicalPlan
        - constructInnerIndexScanTask(ds *DataSource, path *util.AccessPath, filterConds []expression.Expression, outerJoinKeys []*expression.Column, us *LogicalUnionScan, rangeInfo string, keepOrder bool, desc bool, rowCount float64, maxOneRow bool) task
        - tryToGetIndexJoin(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)
        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)
        - pushDownConstExpr(expr expression.Expression, leftCond []expression.Expression, rightCond []expression.Expression, filterCond bool) ([]expression.Expression, []expression.Expression)
        - extractOnCondition(conditions []expression.Expression, deriveLeft bool, deriveRight bool) ([]*expression.ScalarFunction, []expression.Expression, []expression.Expression, []expression.Expression)
        - setPreferredJoinType(hintInfo *tableHintInfo) 
        - pushDownTopNToChild(topN *LogicalTopN, idx int) LogicalPlan
        - pushDownTopN(topN *LogicalTopN) LogicalPlan
        - updateEQCond() 
        - getProj(idx int) *LogicalProjection
        - outerJoinPropConst(predicates []expression.Expression) []expression.Expression

        + PruneColumns(parentUsedCols []*expression.Column) error
        + Shallow() *LogicalJoin
        + GetJoinKeys() []*expression.Column
        + AttachOnConds(onConds []expression.Expression) 
        + AppendJoinConds(eq []*expression.ScalarFunction, left []expression.Expression, right []expression.Expression, other []expression.Expression) 
        + ExtractCorrelatedCols() []*expression.CorrelatedColumn
        + ExtractJoinKeys(childIdx int) *expression.Schema
        + GetMergeJoin(prop *property.PhysicalProperty, schema *expression.Schema, statsInfo *property.StatsInfo, leftStatsInfo *property.StatsInfo, rightStatsInfo *property.StatsInfo) []PhysicalPlan
        + ExplainInfo() string
        + ExtractOnCondition(conditions []expression.Expression, leftSchema *expression.Schema, rightSchema *expression.Schema, deriveLeft bool, deriveRight bool) ([]*expression.ScalarFunction, []expression.Expression, []expression.Expression, []expression.Expression)
        + PredicatePushDown(predicates []expression.Expression) ([]expression.Expression, LogicalPlan)
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + Init(ctx sessionctx.Context, offset int) *LogicalJoin
        + PreparePossibleProperties(schema *expression.Schema, childrenProperties ...[][]*expression.Column) [][]*expression.Column
        + BuildKeyInfo(selfSchema *expression.Schema, childSchema []*expression.Schema) 

    }
    class LogicalLimit << (S,Aquamarine) >> {
        + Offset uint64
        + Count uint64

        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)
        - convertToTopN() *LogicalTopN
        - pushDownTopN(topN *LogicalTopN) LogicalPlan

        + ExplainInfo() string
        + PredicatePushDown(predicates []expression.Expression) ([]expression.Expression, LogicalPlan)
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + HashCode() []byte
        + Init(ctx sessionctx.Context, offset int) *LogicalLimit
        + BuildKeyInfo(selfSchema *expression.Schema, childSchema []*expression.Schema) 

    }
    class LogicalLock << (S,Aquamarine) >> {
        - tblID2Handle <font color=blue>map</font>[int64][]*expression.Column
        - partitionedTable []table.PartitionedTable

        + Lock ast.SelectLockType

        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)
        - pushDownTopN(topN *LogicalTopN) LogicalPlan

        + PruneColumns(parentUsedCols []*expression.Column) error
        + Init(ctx sessionctx.Context) *LogicalLock

    }
    class LogicalMaxOneRow << (S,Aquamarine) >> {
        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)

        + PredicatePushDown(predicates []expression.Expression) ([]expression.Expression, LogicalPlan)
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + Init(ctx sessionctx.Context, offset int) *LogicalMaxOneRow
        + Schema() *expression.Schema

    }
    class LogicalMemTable << (S,Aquamarine) >> {
        + Extractor MemTablePredicateExtractor
        + DBName model.CIStr
        + TableInfo *model.TableInfo
        + QueryTimeRange QueryTimeRange

        - findBestTask(prop *property.PhysicalProperty) (task, error)

        + PredicatePushDown(predicates []expression.Expression) ([]expression.Expression, LogicalPlan)
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + Init(ctx sessionctx.Context, offset int) *LogicalMemTable

    }
    class LogicalPartitionUnionAll << (S,Aquamarine) >> {
        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)

        + Init(ctx sessionctx.Context, offset int) *LogicalPartitionUnionAll

    }
    interface LogicalPlan  {
        - findBestTask(prop *property.PhysicalProperty) (task, error)
        - pushDownTopN(topN *LogicalTopN) LogicalPlan
        - recursiveDeriveStats() (*property.StatsInfo, error)
        - exhaustPhysicalPlans( *property.PhysicalProperty) ([]PhysicalPlan, bool)

        + HashCode() []byte
        + PredicatePushDown( []expression.Expression) ([]expression.Expression, LogicalPlan)
        + PruneColumns( []*expression.Column) error
        + BuildKeyInfo(selfSchema *expression.Schema, childSchema []*expression.Schema) 
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + PreparePossibleProperties(schema *expression.Schema, childrenProperties ...[][]*expression.Column) [][]*expression.Column
        + ExtractCorrelatedCols() []*expression.CorrelatedColumn
        + MaxOneRow() bool
        + Children() []LogicalPlan
        + SetChildren( ...LogicalPlan) 
        + SetChild(i int, child LogicalPlan) 

    }
    class LogicalProjection << (S,Aquamarine) >> {
        - calculateGenCols bool

        + Exprs []expression.Expression
        + CalculateNoDelay bool
        + AvoidColumnEvaluator bool

        - replaceExprColumns(replace <font color=blue>map</font>[string]*expression.Column) 
        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)
        - pushDownTopN(topN *LogicalTopN) LogicalPlan
        - appendExpr(expr expression.Expression) *expression.Column
        - buildSchemaByExprs(selfSchema *expression.Schema) *expression.Schema

        + PruneColumns(parentUsedCols []*expression.Column) error
        + ExtractCorrelatedCols() []*expression.CorrelatedColumn
        + GetUsedCols() []*expression.Column
        + TryToGetChildProp(prop *property.PhysicalProperty) (*property.PhysicalProperty, bool)
        + ExplainInfo() string
        + PredicatePushDown(predicates []expression.Expression) ([]expression.Expression, LogicalPlan)
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + HashCode() []byte
        + Init(ctx sessionctx.Context, offset int) *LogicalProjection
        + PreparePossibleProperties(schema *expression.Schema, childrenProperties ...[][]*expression.Column) [][]*expression.Column
        + BuildKeyInfo(selfSchema *expression.Schema, childSchema []*expression.Schema) 

    }
    class LogicalSelection << (S,Aquamarine) >> {
        + Conditions []expression.Expression

        - replaceExprColumns(replace <font color=blue>map</font>[string]*expression.Column) 
        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)
        - checkMaxOneRowCond(unique expression.Expression, constOrCorCol expression.Expression, childSchema *expression.Schema) bool

        + PruneColumns(parentUsedCols []*expression.Column) error
        + ExtractCorrelatedCols() []*expression.CorrelatedColumn
        + ExplainInfo() string
        + PredicatePushDown(predicates []expression.Expression) ([]expression.Expression, LogicalPlan)
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + HashCode() []byte
        + Init(ctx sessionctx.Context, offset int) *LogicalSelection
        + PreparePossibleProperties(schema *expression.Schema, childrenProperties ...[][]*expression.Column) [][]*expression.Column
        + BuildKeyInfo(selfSchema *expression.Schema, childSchema []*expression.Schema) 

    }
    class LogicalShow << (S,Aquamarine) >> {
        - findBestTask(prop *property.PhysicalProperty) (task, error)

        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + Init(ctx sessionctx.Context) *LogicalShow

    }
    class LogicalShowDDLJobs << (S,Aquamarine) >> {
        + JobNumber int64

        - findBestTask(prop *property.PhysicalProperty) (task, error)

        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + Init(ctx sessionctx.Context) *LogicalShowDDLJobs

    }
    class LogicalSort << (S,Aquamarine) >> {
        + ByItems []*util.ByItems

        - replaceExprColumns(replace <font color=blue>map</font>[string]*expression.Column) 
        - getPhysicalSort(prop *property.PhysicalProperty) *PhysicalSort
        - getNominalSort(reqProp *property.PhysicalProperty) *NominalSort
        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)
        - pushDownTopN(topN *LogicalTopN) LogicalPlan

        + PruneColumns(parentUsedCols []*expression.Column) error
        + ExtractCorrelatedCols() []*expression.CorrelatedColumn
        + ExplainInfo() string
        + Init(ctx sessionctx.Context, offset int) *LogicalSort
        + PreparePossibleProperties(schema *expression.Schema, childrenProperties ...[][]*expression.Column) [][]*expression.Column

    }
    class LogicalTableDual << (S,Aquamarine) >> {
        + RowCount int

        - findBestTask(prop *property.PhysicalProperty) (task, error)

        + PruneColumns(parentUsedCols []*expression.Column) error
        + ExplainInfo() string
        + PredicatePushDown(predicates []expression.Expression) ([]expression.Expression, LogicalPlan)
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + HashCode() []byte
        + Init(ctx sessionctx.Context, offset int) *LogicalTableDual

    }
    class LogicalTableScan << (S,Aquamarine) >> {
        + Source *DataSource
        + Handle *expression.Column
        + AccessConds expression.CNFExprs
        + Ranges []*ranger.Range

        + GetPhysicalScan(schema *expression.Schema, stats *property.StatsInfo) *PhysicalTableScan
        + ExplainInfo() string
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + Init(ctx sessionctx.Context, offset int) *LogicalTableScan
        + PreparePossibleProperties(schema *expression.Schema, childrenProperties ...[][]*expression.Column) [][]*expression.Column
        + BuildKeyInfo(selfSchema *expression.Schema, childSchema []*expression.Schema) 

    }
    class LogicalTopN << (S,Aquamarine) >> {
        + ByItems []*util.ByItems
        + Offset uint64
        + Count uint64

        - replaceExprColumns(replace <font color=blue>map</font>[string]*expression.Column) 
        - isLimit() bool
        - getPhysTopN() []PhysicalPlan
        - getPhysLimits() []PhysicalPlan
        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)
        - setChild(p LogicalPlan) LogicalPlan

        + PruneColumns(parentUsedCols []*expression.Column) error
        + ExtractCorrelatedCols() []*expression.CorrelatedColumn
        + ExplainInfo() string
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + Init(ctx sessionctx.Context, offset int) *LogicalTopN
        + PreparePossibleProperties(schema *expression.Schema, childrenProperties ...[][]*expression.Column) [][]*expression.Column

    }
    class LogicalUnionAll << (S,Aquamarine) >> {
        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)
        - pushDownTopN(topN *LogicalTopN) LogicalPlan

        + PruneColumns(parentUsedCols []*expression.Column) error
        + PredicatePushDown(predicates []expression.Expression) ([]expression.Expression, LogicalPlan)
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + Init(ctx sessionctx.Context, offset int) *LogicalUnionAll

    }
    class LogicalUnionScan << (S,Aquamarine) >> {
        - conditions []expression.Expression
        - handleCol *expression.Column

        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)

        + PruneColumns(parentUsedCols []*expression.Column) error
        + ExplainInfo() string
        + PredicatePushDown(predicates []expression.Expression) ([]expression.Expression, LogicalPlan)
        + Init(ctx sessionctx.Context, offset int) *LogicalUnionScan

    }
    class LogicalWindow << (S,Aquamarine) >> {
        + WindowFuncDescs []*aggregation.WindowFuncDesc
        + PartitionBy []property.Item
        + OrderBy []property.Item
        + Frame *WindowFrame

        - replaceExprColumns(replace <font color=blue>map</font>[string]*expression.Column) 
        - extractUsedCols(parentUsedCols []*expression.Column) []*expression.Column
        - exhaustPhysicalPlans(prop *property.PhysicalProperty) ([]PhysicalPlan, bool)

        + PruneColumns(parentUsedCols []*expression.Column) error
        + ExtractCorrelatedCols() []*expression.CorrelatedColumn
        + GetWindowResultColumns() []*expression.Column
        + GetPartitionByCols() []*expression.Column
        + PredicatePushDown(predicates []expression.Expression) ([]expression.Expression, LogicalPlan)
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + Init(ctx sessionctx.Context, offset int) *LogicalWindow
        + PreparePossibleProperties(schema *expression.Schema, childrenProperties ...[][]*expression.Column) [][]*expression.Column

    }
    interface MemTablePredicateExtractor  {
        - explainInfo(p *PhysicalMemTable) string

        + Extract( sessionctx.Context,  *expression.Schema,  []*types.FieldName,  []expression.Expression) []expression.Expression

    }
    class MetricSummaryTableExtractor << (S,Aquamarine) >> {
        + SkipRequest bool
        + MetricsNames set.StringSet
        + Quantiles []float64

        - explainInfo(p *PhysicalMemTable) string

        + Extract(_ sessionctx.Context, schema *expression.Schema, names []*types.FieldName, predicates []expression.Expression) []expression.Expression

    }
    class MetricTableExtractor << (S,Aquamarine) >> {
        + SkipRequest bool
        + StartTime time.Time
        + EndTime time.Time
        + LabelConditions <font color=blue>map</font>[string]set.StringSet
        + Quantiles []float64

        - getTimeRange(start int64, end int64) (time.Time, time.Time)
        - explainInfo(p *PhysicalMemTable) string

        + Extract(ctx sessionctx.Context, schema *expression.Schema, names []*types.FieldName, predicates []expression.Expression) []expression.Expression
        + GetMetricTablePromQL(sctx sessionctx.Context, lowerTableName string) string

    }
    class NominalSort << (S,Aquamarine) >> {
        + ByItems []*util.ByItems
        + OnlyColumn bool

        - attach2Task(tasks ...task) task

        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *NominalSort

    }
    class PBPlanBuilder << (S,Aquamarine) >> {
        - sctx sessionctx.Context
        - tps []*types.FieldType
        - is infoschema.InfoSchema

        - pbToPhysicalPlan(e *tipb.Executor) (PhysicalPlan, error)
        - pbToTableScan(e *tipb.Executor) (PhysicalPlan, error)
        - buildTableScanSchema(tblInfo *model.TableInfo, columns []*model.ColumnInfo) *expression.Schema
        - pbToSelection(e *tipb.Executor) (PhysicalPlan, error)
        - pbToTopN(e *tipb.Executor) (PhysicalPlan, error)
        - pbToLimit(e *tipb.Executor) (PhysicalPlan, error)
        - pbToAgg(e *tipb.Executor, isStreamAgg bool) (PhysicalPlan, error)
        - buildAggSchema(aggFuncs []*aggregation.AggFuncDesc, groupBys []expression.Expression) *expression.Schema
        - getAggInfo(executor *tipb.Executor) ([]*aggregation.AggFuncDesc, []expression.Expression, error)
        - convertColumnInfo(tblInfo *model.TableInfo, pbColumns []*tipb.ColumnInfo) ([]*model.ColumnInfo, error)
        - predicatePushDown(p PhysicalPlan, predicates []expression.Expression) ([]expression.Expression, PhysicalPlan)

        + Build(executors []*tipb.Executor) (PhysicalPlan, error)

    }
    class PSTMTPlanCacheValue << (S,Aquamarine) >> {
        + Plan Plan
        + OutPutNames []*types.FieldName
        + TblInfo2UnionScan <font color=blue>map</font>[*model.TableInfo]bool

    }
    class PhysicalApply << (S,Aquamarine) >> {
        + OuterSchema []*expression.CorrelatedColumn

        - attach2Task(tasks ...task) task

        + GetCost(lCount float64, rCount float64, lCost float64, rCost float64) float64
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalApply
        + ResolveIndices() error

    }
    class PhysicalHashAgg << (S,Aquamarine) >> {
        - cpuCostDivisor(hasDistinct bool) (float64, float64)
        - attach2Task(tasks ...task) task

        + GetCost(inputRows float64, isRoot bool) float64
        + ToPB(ctx sessionctx.Context) (*tipb.Executor, error)

    }
    class PhysicalHashJoin << (S,Aquamarine) >> {
        + Concurrency uint
        + EqualConditions []*expression.ScalarFunction
        + UseOuterToBuild bool

        - attach2Task(tasks ...task) task
        - explainInfo(normalized bool) string

        + GetCost(lCnt float64, rCnt float64) float64
        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalHashJoin
        + ResolveIndices() error

    }
    class PhysicalIndexHashJoin << (S,Aquamarine) >> {
        + KeepOuterOrder bool

        - attach2Task(tasks ...task) task

        + GetCost(outerTask task, innerTask task) float64
        + Init(ctx sessionctx.Context) *PhysicalIndexHashJoin

    }
    class PhysicalIndexJoin << (S,Aquamarine) >> {
        - outerSchema *expression.Schema
        - innerTask task

        + Ranges []*ranger.Range
        + KeyOff2IdxOff []int
        + IdxColLens []int
        + CompareFilters *ColWithCmpFuncManager

        - attach2Task(tasks ...task) task
        - explainInfo(normalized bool) string

        + GetCost(outerTask task, innerTask task) float64
        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalIndexJoin
        + ResolveIndices() error

    }
    class PhysicalIndexLookUpReader << (S,Aquamarine) >> {
        - indexPlan PhysicalPlan
        - tablePlan PhysicalPlan

        + IndexPlans []PhysicalPlan
        + TablePlans []PhysicalPlan
        + ExtraHandleCol *expression.Column
        + PushedLimit *PushedDownLimit

        + ExplainInfo() string
        + Init(ctx sessionctx.Context, offset int) *PhysicalIndexLookUpReader
        + ResolveIndices() error

    }
    class PhysicalIndexMergeJoin << (S,Aquamarine) >> {
        + KeyOff2KeyOffOrderByIdx []int
        + CompareFuncs []expression.CompareFunc
        + OuterCompareFuncs []expression.CompareFunc
        + NeedOuterSort bool
        + Desc bool

        - attach2Task(tasks ...task) task

        + GetCost(outerTask task, innerTask task) float64
        + Init(ctx sessionctx.Context) *PhysicalIndexMergeJoin

    }
    class PhysicalIndexMergeReader << (S,Aquamarine) >> {
        - partialPlans []PhysicalPlan
        - tablePlan PhysicalPlan

        + PartialPlans [][]PhysicalPlan
        + TablePlans []PhysicalPlan

        + ExplainInfo() string
        + Init(ctx sessionctx.Context, offset int) *PhysicalIndexMergeReader
        + ResolveIndices() error

    }
    class PhysicalIndexReader << (S,Aquamarine) >> {
        - indexPlan PhysicalPlan

        + IndexPlans []PhysicalPlan
        + OutputColumns []*expression.Column

        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + Init(ctx sessionctx.Context, offset int) *PhysicalIndexReader
        + SetSchema(_ *expression.Schema) 
        + SetChildren(children ...PhysicalPlan) 
        + ResolveIndices() error

    }
    class PhysicalIndexScan << (S,Aquamarine) >> {
        - dataSourceSchema *expression.Schema
        - rangeInfo string
        - physicalTableID int64
        - isPartition bool

        + AccessCondition []expression.Expression
        + Table *model.TableInfo
        + Index *model.IndexInfo
        + IdxCols []*expression.Column
        + IdxColLens []int
        + Ranges []*ranger.Range
        + Columns []*model.ColumnInfo
        + DBName model.CIStr
        + TableAsName *model.CIStr
        + Hist *statistics.Histogram
        + GenExprs <font color=blue>map</font>[model.TableColumnID]expression.Expression
        + Desc bool
        + KeepOrder bool
        + DoubleRead bool

        - indexScanRowSize(idx *model.IndexInfo, ds *DataSource, isForScan bool) float64
        - initSchema(idx *model.IndexInfo, idxExprCols []*expression.Column, isDoubleRead bool) 
        - addPushedDownSelection(copTask *copTask, p *DataSource, path *util.AccessPath, finalStats *property.StatsInfo) 
        - haveCorCol() bool
        - isFullScan() bool

        + ExplainID() fmt.Stringer
        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + AccessObject() string
        + OperatorInfo(normalized bool) string
        + Init(ctx sessionctx.Context, offset int) *PhysicalIndexScan
        + IsPartition() (bool, int64)
        + IsPointGetByUniqueKey(sc *stmtctx.StatementContext) bool
        + ToPB(ctx sessionctx.Context) (*tipb.Executor, error)

    }
    class PhysicalLimit << (S,Aquamarine) >> {
        + Offset uint64
        + Count uint64

        - attach2Task(tasks ...task) task
        - sinkIntoIndexLookUp(t task) bool

        + ExplainInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalLimit
        + ToPB(ctx sessionctx.Context) (*tipb.Executor, error)

    }
    class PhysicalLock << (S,Aquamarine) >> {
        + Lock ast.SelectLockType
        + TblID2Handle <font color=blue>map</font>[int64][]*expression.Column
        + PartitionedTable []table.PartitionedTable

        + ExplainInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, props ...*property.PhysicalProperty) *PhysicalLock
        + ResolveIndices() error

    }
    class PhysicalMaxOneRow << (S,Aquamarine) >> {
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalMaxOneRow

    }
    class PhysicalMemTable << (S,Aquamarine) >> {
        + DBName model.CIStr
        + Table *model.TableInfo
        + Columns []*model.ColumnInfo
        + Extractor MemTablePredicateExtractor
        + QueryTimeRange QueryTimeRange

        + ExplainInfo() string
        + AccessObject() string
        + OperatorInfo(_ bool) string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int) *PhysicalMemTable

    }
    class PhysicalMergeJoin << (S,Aquamarine) >> {
        + CompareFuncs []expression.CompareFunc
        + Desc bool

        - attach2Task(tasks ...task) task
        - tryToGetChildReqProp(prop *property.PhysicalProperty) ([]*property.PhysicalProperty, bool)
        - initCompareFuncs() 
        - explainInfo(normalized bool) string

        + GetCost(lCnt float64, rCnt float64) float64
        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int) *PhysicalMergeJoin
        + ResolveIndices() error

    }
    interface PhysicalPlan  {
        - attach2Task( ...task) task

        + ToPB(ctx sessionctx.Context) (*tipb.Executor, error)
        + GetChildReqProps(idx int) *property.PhysicalProperty
        + StatsCount() float64
        + Children() []PhysicalPlan
        + SetChildren( ...PhysicalPlan) 
        + SetChild(i int, child PhysicalPlan) 
        + ResolveIndices() error
        + Stats() *property.StatsInfo
        + ExplainNormalizedInfo() string

    }
    class PhysicalProjection << (S,Aquamarine) >> {
        + Exprs []expression.Expression
        + CalculateNoDelay bool
        + AvoidColumnEvaluator bool

        - attach2Task(tasks ...task) task

        + GetCost(count float64) float64
        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalProjection
        + ResolveIndices() error

    }
    class PhysicalSelection << (S,Aquamarine) >> {
        + Conditions []expression.Expression

        - attach2Task(tasks ...task) task

        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalSelection
        + ResolveIndices() error
        + ToPB(ctx sessionctx.Context) (*tipb.Executor, error)

    }
    class PhysicalShow << (S,Aquamarine) >> {
        + Init(ctx sessionctx.Context) *PhysicalShow

    }
    class PhysicalShowDDLJobs << (S,Aquamarine) >> {
        + JobNumber int64

        + Init(ctx sessionctx.Context) *PhysicalShowDDLJobs

    }
    class PhysicalShuffle << (S,Aquamarine) >> {
        + Concurrency int
        + Tail PhysicalPlan
        + DataSource PhysicalPlan
        + SplitterType PartitionSplitterType
        + HashByItems []expression.Expression

        + ExplainInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalShuffle
        + ResolveIndices() error

    }
    class PhysicalShuffleDataSourceStub << (S,Aquamarine) >> {
        + Worker unsafe.Pointer

        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalShuffleDataSourceStub

    }
    class PhysicalSort << (S,Aquamarine) >> {
        + ByItems []*util.ByItems

        - attach2Task(tasks ...task) task

        + GetCost(count float64, schema *expression.Schema) float64
        + ExplainInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalSort
        + ResolveIndices() error

    }
    class PhysicalStreamAgg << (S,Aquamarine) >> {
        - attach2Task(tasks ...task) task

        + GetCost(inputRows float64, isRoot bool) float64
        + ToPB(ctx sessionctx.Context) (*tipb.Executor, error)

    }
    class PhysicalTableDual << (S,Aquamarine) >> {
        - names []*types.FieldName

        + RowCount int

        + ExplainInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int) *PhysicalTableDual
        + OutputNames() types.NameSlice
        + SetOutputNames(names types.NameSlice) 

    }
    class PhysicalTableReader << (S,Aquamarine) >> {
        - tablePlan PhysicalPlan

        + TablePlans []PhysicalPlan
        + StoreType kv.StoreType

        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + Init(ctx sessionctx.Context, offset int) *PhysicalTableReader
        + SetChildren(children ...PhysicalPlan) 
        + ResolveIndices() error

    }
    class PhysicalTableScan << (S,Aquamarine) >> {
        - filterCondition []expression.Expression
        - pkCol *expression.Column
        - physicalTableID int64
        - rangeDecidedBy []*expression.Column
        - isPartition bool
        - isChildOfIndexLookUp bool

        + AccessCondition []expression.Expression
        + Table *model.TableInfo
        + Columns []*model.ColumnInfo
        + DBName model.CIStr
        + Ranges []*ranger.Range
        + TableAsName *model.CIStr
        + Hist *statistics.Histogram
        + HandleIdx int
        + StoreType kv.StoreType
        + KeepOrder bool
        + Desc bool

        - appendExtraHandleCol(ds *DataSource) (*expression.Column, bool)
        - addPushedDownSelection(copTask *copTask, stats *property.StatsInfo) 
        - haveCorCol() bool
        - isFullScan() bool

        + ExplainID() fmt.Stringer
        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + AccessObject() string
        + OperatorInfo(normalized bool) string
        + Init(ctx sessionctx.Context, offset int) *PhysicalTableScan
        + IsPartition() (bool, int64)
        + SetIsChildOfIndexLookUp(isIsChildOfIndexLookUp bool) 
        + ToPB(ctx sessionctx.Context) (*tipb.Executor, error)

    }
    class PhysicalTopN << (S,Aquamarine) >> {
        + ByItems []*util.ByItems
        + Offset uint64
        + Count uint64

        - canPushDown(cop *copTask) bool
        - allColsFromSchema(schema *expression.Schema) bool
        - getPushedDownTopN(childPlan PhysicalPlan) *PhysicalTopN
        - attach2Task(tasks ...task) task

        + GetCost(count float64, isRoot bool) float64
        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalTopN
        + ResolveIndices() error
        + ToPB(ctx sessionctx.Context) (*tipb.Executor, error)

    }
    class PhysicalUnionAll << (S,Aquamarine) >> {
        - attach2Task(tasks ...task) task

        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalUnionAll

    }
    class PhysicalUnionScan << (S,Aquamarine) >> {
        + Conditions []expression.Expression
        + HandleCol *expression.Column

        - attach2Task(tasks ...task) task

        + ExplainInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalUnionScan
        + ResolveIndices() error

    }
    class PhysicalWindow << (S,Aquamarine) >> {
        + WindowFuncDescs []*aggregation.WindowFuncDesc
        + PartitionBy []property.Item
        + OrderBy []property.Item
        + Frame *WindowFrame

        - formatFrameBound(buffer *bytes.Buffer, bound *FrameBound) 

        + ExplainInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalWindow
        + ResolveIndices() error

    }
    interface Plan  {
        - replaceExprColumns(replace <font color=blue>map</font>[string]*expression.Column) 
        - statsInfo() *property.StatsInfo

        + Schema() *expression.Schema
        + ID() int
        + TP() string
        + ExplainID() fmt.Stringer
        + ExplainInfo() string
        + SCtx() sessionctx.Context
        + OutputNames() types.NameSlice
        + SetOutputNames(names types.NameSlice) 
        + SelectBlockOffset() int

    }
    class PlanBuilder << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - is infoschema.InfoSchema
        - outerSchemas []*expression.Schema
        - outerNames [][]*types.FieldName
        - colMapper <font color=blue>map</font>[*ast.ColumnNameExpr]int
        - visitInfo []visitInfo
        - tableHintInfo []tableHintInfo
        - optFlag uint64
        - capFlag capFlagType
        - curClause clauseCode
        - rewriterPool []*expressionRewriter
        - rewriterCounter int
        - windowSpecs <font color=blue>map</font>[string]*ast.WindowSpec
        - inUpdateStmt bool
        - inDeleteStmt bool
        - inStraightJoin bool
        - handleHelper *handleColHelper
        - hintProcessor *hint.BlockHintProcessor
        - selectOffset []int
        - partitionedTable []table.PartitionedTable
        - underlyingViewNames set.StringSet

        - rewriteInsertOnDuplicateUpdate(ctx context.Context, exprNode ast.ExprNode, mockPlan LogicalPlan, insertPlan *Insert) (expression.Expression, error)
        - rewrite(ctx context.Context, exprNode ast.ExprNode, p LogicalPlan, aggMapper <font color=blue>map</font>[*ast.AggregateFuncExpr]int, asScalar bool) (expression.Expression, LogicalPlan, error)
        - rewriteWithPreprocess(ctx context.Context, exprNode ast.ExprNode, p LogicalPlan, aggMapper <font color=blue>map</font>[*ast.AggregateFuncExpr]int, windowMapper <font color=blue>map</font>[*ast.WindowFuncExpr]int, asScalar bool, preprocess <font color=blue>func</font>(ast.Node) ast.Node) (expression.Expression, LogicalPlan, error)
        - getExpressionRewriter(ctx context.Context, p LogicalPlan) *expressionRewriter
        - rewriteExprNode(rewriter *expressionRewriter, exprNode ast.ExprNode, asScalar bool) (expression.Expression, LogicalPlan, error)
        - buildAggregation(ctx context.Context, p LogicalPlan, aggFuncList []*ast.AggregateFuncExpr, gbyItems []expression.Expression) (LogicalPlan, <font color=blue>map</font>[int]int, error)
        - buildResultSetNode(ctx context.Context, node ast.ResultSetNode) (LogicalPlan, error)
        - buildJoin(ctx context.Context, joinNode *ast.Join) (LogicalPlan, error)
        - buildUsingClause(p *LogicalJoin, leftPlan LogicalPlan, rightPlan LogicalPlan, join *ast.Join) error
        - buildNaturalJoin(p *LogicalJoin, leftPlan LogicalPlan, rightPlan LogicalPlan, join *ast.Join) error
        - coalesceCommonColumns(p *LogicalJoin, leftPlan LogicalPlan, rightPlan LogicalPlan, joinTp ast.JoinType, filter <font color=blue>map</font>[string]bool) error
        - buildSelection(ctx context.Context, p LogicalPlan, where ast.ExprNode, AggMapper <font color=blue>map</font>[*ast.AggregateFuncExpr]int) (LogicalPlan, error)
        - buildProjectionFieldNameFromColumns(origField *ast.SelectField, colNameField *ast.ColumnNameExpr, name *types.FieldName) model.CIStr
        - buildProjectionFieldNameFromExpressions(ctx context.Context, field *ast.SelectField) (model.CIStr, error)
        - buildProjectionField(ctx context.Context, p LogicalPlan, field *ast.SelectField, expr expression.Expression) (*expression.Column, *types.FieldName, error)
        - buildProjection(ctx context.Context, p LogicalPlan, fields []*ast.SelectField, mapper <font color=blue>map</font>[*ast.AggregateFuncExpr]int, windowMapper <font color=blue>map</font>[*ast.WindowFuncExpr]int, considerWindow bool, expandGenerateColumn bool) (LogicalPlan, int, error)
        - buildDistinct(child LogicalPlan, length int) (*LogicalAggregation, error)
        - buildProjection4Union(ctx context.Context, u *LogicalUnionAll) 
        - buildUnion(ctx context.Context, union *ast.UnionStmt) (LogicalPlan, error)
        - divideUnionSelectPlans(ctx context.Context, selects []*ast.SelectStmt) ([]LogicalPlan, []LogicalPlan, error)
        - buildUnionAll(ctx context.Context, subPlan []LogicalPlan) LogicalPlan
        - buildSort(ctx context.Context, p LogicalPlan, byItems []*ast.ByItem, aggMapper <font color=blue>map</font>[*ast.AggregateFuncExpr]int, windowMapper <font color=blue>map</font>[*ast.WindowFuncExpr]int) (*LogicalSort, error)
        - buildLimit(src LogicalPlan, limit *ast.Limit) (LogicalPlan, error)
        - resolveHavingAndOrderBy(sel *ast.SelectStmt, p LogicalPlan) (<font color=blue>map</font>[*ast.AggregateFuncExpr]int, <font color=blue>map</font>[*ast.AggregateFuncExpr]int, error)
        - extractAggFuncs(fields []*ast.SelectField) ([]*ast.AggregateFuncExpr, <font color=blue>map</font>[*ast.AggregateFuncExpr]int)
        - resolveWindowFunction(sel *ast.SelectStmt, p LogicalPlan) (<font color=blue>map</font>[*ast.AggregateFuncExpr]int, error)
        - checkOnlyFullGroupBy(p LogicalPlan, sel *ast.SelectStmt) error
        - checkOnlyFullGroupByWithGroupClause(p LogicalPlan, sel *ast.SelectStmt) error
        - checkOnlyFullGroupByWithOutGroupClause(p LogicalPlan, fields []*ast.SelectField) error
        - resolveGbyExprs(ctx context.Context, p LogicalPlan, gby *ast.GroupByClause, fields []*ast.SelectField) (LogicalPlan, []expression.Expression, error)
        - unfoldWildStar(p LogicalPlan, selectFields []*ast.SelectField) ([]*ast.SelectField, error)
        - pushHintWithoutTableWarning(hint *ast.TableOptimizerHint) 
        - pushTableHints(hints []*ast.TableOptimizerHint, nodeType hint.NodeType, currentLevel int) 
        - popTableHints() 
        - appendUnmatchedIndexHintWarning(indexHints []indexHintInfo, usedForIndexMerge bool) 
        - appendUnmatchedJoinHintWarning(joinType string, joinTypeAlias string, hintTables []hintTableInfo) 
        - appendUnmatchedStorageHintWarning(tiflashTables []hintTableInfo, tikvTables []hintTableInfo) 
        - buildSelect(ctx context.Context, sel *ast.SelectStmt) (LogicalPlan, error)
        - buildTableDual() *LogicalTableDual
        - buildDataSource(ctx context.Context, tn *ast.TableName, asName *model.CIStr) (LogicalPlan, error)
        - timeRangeForSummaryTable() QueryTimeRange
        - buildMemTable(_ context.Context, dbName model.CIStr, tableInfo *model.TableInfo) (LogicalPlan, error)
        - buildProjUponView(ctx context.Context, dbName model.CIStr, tableInfo *model.TableInfo, selectLogicalPlan Plan) (LogicalPlan, error)
        - buildApplyWithJoinType(outerPlan LogicalPlan, innerPlan LogicalPlan, tp JoinType) LogicalPlan
        - buildSemiApply(outerPlan LogicalPlan, innerPlan LogicalPlan, condition []expression.Expression, asScalar bool, not bool) (LogicalPlan, error)
        - buildMaxOneRow(p LogicalPlan) LogicalPlan
        - buildSemiJoin(outerPlan LogicalPlan, innerPlan LogicalPlan, onCondition []expression.Expression, asScalar bool, not bool) (*LogicalJoin, error)
        - buildUpdate(ctx context.Context, update *ast.UpdateStmt) (Plan, error)
        - buildUpdateLists(ctx context.Context, tableList []*ast.TableName, list []*ast.Assignment, p LogicalPlan) ([]*expression.Assignment, LogicalPlan, bool, error)
        - buildDelete(ctx context.Context, delete *ast.DeleteStmt) (Plan, error)
        - buildProjectionForWindow(ctx context.Context, p LogicalPlan, spec *ast.WindowSpec, args []ast.ExprNode, aggMap <font color=blue>map</font>[*ast.AggregateFuncExpr]int) (LogicalPlan, []property.Item, []property.Item, []expression.Expression, error)
        - buildArgs4WindowFunc(ctx context.Context, p LogicalPlan, args []ast.ExprNode, aggMap <font color=blue>map</font>[*ast.AggregateFuncExpr]int) ([]expression.Expression, error)
        - buildByItemsForWindow(ctx context.Context, p LogicalPlan, proj *LogicalProjection, items []*ast.ByItem, retItems []property.Item, aggMap <font color=blue>map</font>[*ast.AggregateFuncExpr]int) (LogicalPlan, []property.Item, error)
        - buildWindowFunctionFrameBound(ctx context.Context, spec *ast.WindowSpec, orderByItems []property.Item, boundClause *ast.FrameBound) (*FrameBound, error)
        - buildWindowFunctionFrame(ctx context.Context, spec *ast.WindowSpec, orderByItems []property.Item) (*WindowFrame, error)
        - checkWindowFuncArgs(ctx context.Context, p LogicalPlan, windowFuncExprs []*ast.WindowFuncExpr, windowAggMap <font color=blue>map</font>[*ast.AggregateFuncExpr]int) error
        - buildWindowFunctions(ctx context.Context, p LogicalPlan, groupedFuncs <font color=blue>map</font>[*ast.WindowSpec][]*ast.WindowFuncExpr, aggMap <font color=blue>map</font>[*ast.AggregateFuncExpr]int) (LogicalPlan, <font color=blue>map</font>[*ast.WindowFuncExpr]int, error)
        - checkOriginWindowSpecs(funcs []*ast.WindowFuncExpr, orderByItems []property.Item) error
        - checkOriginWindowFrameBound(bound *ast.FrameBound, spec *ast.WindowSpec, orderByItems []property.Item) error
        - handleDefaultFrame(spec *ast.WindowSpec, windowFuncName string) (*ast.WindowSpec, bool)
        - groupWindowFuncs(windowFuncs []*ast.WindowFuncExpr) (<font color=blue>map</font>[*ast.WindowSpec][]*ast.WindowFuncExpr, error)
        - getSelectOffset() int
        - pushSelectOffset(offset int) 
        - popSelectOffset() 
        - buildSetConfig(ctx context.Context, v *ast.SetConfigStmt) (Plan, error)
        - buildChange(v *ast.ChangeStmt) (Plan, error)
        - buildExecute(ctx context.Context, v *ast.ExecuteStmt) (Plan, error)
        - buildDo(ctx context.Context, v *ast.DoStmt) (Plan, error)
        - buildSet(ctx context.Context, v *ast.SetStmt) (Plan, error)
        - buildDropBindPlan(v *ast.DropBindingStmt) (Plan, error)
        - buildCreateBindPlan(v *ast.CreateBindingStmt) (Plan, error)
        - detectSelectAgg(sel *ast.SelectStmt) bool
        - detectSelectWindow(sel *ast.SelectStmt) bool
        - getPossibleAccessPaths(indexHints []*ast.IndexHint, tbl table.Table, dbName model.CIStr, tblName model.CIStr) ([]*util.AccessPath, error)
        - filterPathByIsolationRead(paths []*util.AccessPath, dbName model.CIStr) ([]*util.AccessPath, error)
        - buildSelectLock(src LogicalPlan, lock ast.SelectLockType) *LogicalLock
        - buildPrepare(x *ast.PrepareStmt) Plan
        - buildAdmin(ctx context.Context, as *ast.AdminStmt) (Plan, error)
        - getGenExprs(ctx context.Context, dbName model.CIStr, tbl table.Table, idx *model.IndexInfo, exprCols *expression.Schema, names types.NameSlice) (<font color=blue>map</font>[model.TableColumnID]expression.Expression, error)
        - buildPhysicalIndexLookUpReader(ctx context.Context, dbName model.CIStr, tbl table.Table, idx *model.IndexInfo) (Plan, error)
        - buildPhysicalIndexLookUpReaders(ctx context.Context, dbName model.CIStr, tbl table.Table, indices []table.Index) ([]Plan, []*model.IndexInfo, error)
        - buildAdminCheckTable(ctx context.Context, as *ast.AdminStmt) (*CheckTable, error)
        - buildCheckIndex(ctx context.Context, dbName model.CIStr, as *ast.AdminStmt) (Plan, error)
        - buildCheckIndexSchema(tn *ast.TableName, indexName string) (*expression.Schema, types.NameSlice, error)
        - buildAnalyzeTable(as *ast.AnalyzeTableStmt, opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64) (Plan, error)
        - buildAnalyzeIndex(as *ast.AnalyzeTableStmt, opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64) (Plan, error)
        - buildAnalyzeAllIndex(as *ast.AnalyzeTableStmt, opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64) (Plan, error)
        - buildAnalyze(as *ast.AnalyzeTableStmt) (Plan, error)
        - buildShow(ctx context.Context, show *ast.ShowStmt) (Plan, error)
        - buildSimple(node ast.StmtNode) (Plan, error)
        - getDefaultValue(col *table.Column) (*expression.Constant, error)
        - findDefaultValue(cols []*table.Column, name *ast.ColumnName) (*expression.Constant, error)
        - resolveGeneratedColumns(ctx context.Context, columns []*table.Column, onDups <font color=blue>map</font>[string]<font color=blue>struct</font>{}, mockPlan LogicalPlan) (InsertGeneratedColumns, error)
        - buildInsert(ctx context.Context, insert *ast.InsertStmt) (Plan, error)
        - getAffectCols(insertStmt *ast.InsertStmt, insertPlan *Insert) ([]*table.Column, error)
        - buildSetValuesOfInsert(ctx context.Context, insert *ast.InsertStmt, insertPlan *Insert, mockTablePlan *LogicalTableDual, checkRefColumn <font color=blue>func</font>(ast.Node) ast.Node) error
        - buildValuesListOfInsert(ctx context.Context, insert *ast.InsertStmt, insertPlan *Insert, mockTablePlan *LogicalTableDual, checkRefColumn <font color=blue>func</font>(ast.Node) ast.Node) error
        - buildSelectPlanOfInsert(ctx context.Context, insert *ast.InsertStmt, insertPlan *Insert) error
        - buildLoadData(ctx context.Context, ld *ast.LoadDataStmt) (Plan, error)
        - buildLoadStats(ld *ast.LoadStatsStmt) Plan
        - buildIndexAdvise(node *ast.IndexAdviseStmt) Plan
        - buildSplitRegion(node *ast.SplitRegionStmt) (Plan, error)
        - buildSplitIndexRegion(node *ast.SplitRegionStmt) (Plan, error)
        - convertValue2ColumnType(valuesItem []ast.ExprNode, mockTablePlan LogicalPlan, indexInfo *model.IndexInfo, tblInfo *model.TableInfo) ([]types.Datum, error)
        - convertValue(valueItem ast.ExprNode, mockTablePlan LogicalPlan, col *model.ColumnInfo) (types.Datum, error)
        - buildSplitTableRegion(node *ast.SplitRegionStmt) (Plan, error)
        - buildDDL(ctx context.Context, node ast.DDLNode) (Plan, error)
        - buildTrace(trace *ast.TraceStmt) (Plan, error)
        - buildExplainPlan(targetPlan Plan, format string, rows [][]string, analyze bool, execStmt ast.StmtNode) (Plan, error)
        - buildExplainFor(explainFor *ast.ExplainForStmt) (Plan, error)
        - buildExplain(ctx context.Context, explain *ast.ExplainStmt) (Plan, error)
        - buildSelectInto(ctx context.Context, sel *ast.SelectStmt) (Plan, error)

        + TableHints() *tableHintInfo
        + BuildDataSourceFromView(ctx context.Context, dbName model.CIStr, tableInfo *model.TableInfo) (LogicalPlan, error)
        + GetVisitInfo() []visitInfo
        + GetDBTableInfo() []stmtctx.TableEntry
        + GetOptFlag() uint64
        + Build(ctx context.Context, node ast.Node) (Plan, error)

    }
    class PointGetPlan << (S,Aquamarine) >> {
        - dbName string
        - schema *expression.Schema
        - expr expression.Expression
        - ctx sessionctx.Context
        - outputNames []*types.FieldName
        - partitionColumnPos int

        + TblInfo *model.TableInfo
        + IndexInfo *model.IndexInfo
        + PartitionInfo *model.PartitionDefinition
        + Handle int64
        + HandleParam *parser_driver.ParamMarkerExpr
        + IndexValues []types.Datum
        + IndexValueParams []*parser_driver.ParamMarkerExpr
        + UnsignedHandle bool
        + IsTableDual bool
        + Lock bool
        + LockWaitTime int64
        + Columns []*model.ColumnInfo
        + Path *util.AccessPath

        - attach2Task( ...task) task
        - statsInfo() *property.StatsInfo

        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PointGetPlan
        + Schema() *expression.Schema
        + ToPB(ctx sessionctx.Context) (*tipb.Executor, error)
        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + AccessObject() string
        + OperatorInfo(normalized bool) string
        + GetChildReqProps(idx int) *property.PhysicalProperty
        + StatsCount() float64
        + Children() []PhysicalPlan
        + SetChildren( ...PhysicalPlan) 
        + SetChild(i int, child PhysicalPlan) 
        + ResolveIndices() error
        + OutputNames() types.NameSlice
        + SetOutputNames(names types.NameSlice) 
        + GetCost(cols []*expression.Column) float64

    }
    class Prepare << (S,Aquamarine) >> {
        + Name string
        + SQLText string

    }
    class PushedDownLimit << (S,Aquamarine) >> {
        + Offset uint64
        + Count uint64

    }
    class QueryTimeRange << (S,Aquamarine) >> {
        + From time.Time
        + To time.Time

        + Condition() string

    }
    class RecoverIndex << (S,Aquamarine) >> {
        + Table *ast.TableName
        + IndexName string

    }
    class ReloadExprPushdownBlacklist << (S,Aquamarine) >> {
    }
    class ReloadOptRuleBlacklist << (S,Aquamarine) >> {
    }
    class SQLBindPlan << (S,Aquamarine) >> {
        + SQLBindOp SQLBindOpType
        + NormdOrigSQL string
        + BindSQL string
        + IsGlobal bool
        + BindStmt ast.StmtNode
        + Db string
        + Charset string
        + Collation string

    }
    class SelectInto << (S,Aquamarine) >> {
        + TargetPlan Plan
        + IntoOpt *ast.SelectIntoOption

    }
    class Set << (S,Aquamarine) >> {
        + VarAssigns []*expression.VarAssignment

    }
    class SetConfig << (S,Aquamarine) >> {
        + Type string
        + Instance string
        + Name string
        + Value expression.Expression

    }
    class ShowContents << (S,Aquamarine) >> {
        + Tp ast.ShowStmtType
        + DBName string
        + Table *ast.TableName
        + Column *ast.ColumnName
        + IndexName model.CIStr
        + Flag int
        + User *auth.UserIdentity
        + Roles []*auth.RoleIdentity
        + Full bool
        + IfNotExists bool
        + GlobalScope bool
        + Extended bool

    }
    class ShowDDL << (S,Aquamarine) >> {
    }
    class ShowDDLJobQueries << (S,Aquamarine) >> {
        + JobIDs []int64

    }
    class ShowNextRowID << (S,Aquamarine) >> {
        + TableName *ast.TableName

    }
    class ShowSlow << (S,Aquamarine) >> {
    }
    class Simple << (S,Aquamarine) >> {
        + Statement ast.StmtNode

    }
    class SlowQueryExtractor << (S,Aquamarine) >> {
        + SkipRequest bool
        + StartTime time.Time
        + EndTime time.Time
        + Enable bool

        - setTimeRange(start int64, end int64) 
        - explainInfo(p *PhysicalMemTable) string

        + Extract(ctx sessionctx.Context, schema *expression.Schema, names []*types.FieldName, predicates []expression.Expression) []expression.Expression

    }
    class SplitRegion << (S,Aquamarine) >> {
        + TableInfo *model.TableInfo
        + PartitionNames []model.CIStr
        + IndexInfo *model.IndexInfo
        + Lower []types.Datum
        + Upper []types.Datum
        + Num int
        + ValueLists [][]types.Datum

    }
    class SplitRegionStatus << (S,Aquamarine) >> {
        + Table table.Table
        + IndexInfo *model.IndexInfo

    }
    class TblColPosInfo << (S,Aquamarine) >> {
        + TblID int64
        + Start int
        + HandleOrdinal int

    }
    class TblColPosInfoSlice << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool
        + FindHandle(colOrdinal int) (int, bool)

    }
    class TiKVSingleGather << (S,Aquamarine) >> {
        + Source *DataSource
        + IsIndexGather bool
        + Index *model.IndexInfo

        + ExplainInfo() string
        + Init(ctx sessionctx.Context, offset int) *TiKVSingleGather
        + PreparePossibleProperties(schema *expression.Schema, childrenProperties ...[][]*expression.Column) [][]*expression.Column
        + GetPhysicalTableReader(schema *expression.Schema, stats *property.StatsInfo, props ...*property.PhysicalProperty) *PhysicalTableReader
        + GetPhysicalIndexReader(schema *expression.Schema, stats *property.StatsInfo, props ...*property.PhysicalProperty) *PhysicalIndexReader
        + BuildKeyInfo(selfSchema *expression.Schema, childSchema []*expression.Schema) 

    }
    class Trace << (S,Aquamarine) >> {
        + StmtNode ast.StmtNode
        + Format string

    }
    class Update << (S,Aquamarine) >> {
        + OrderedList []*expression.Assignment
        + AllAssignmentsAreConstant bool
        + SelectPlan PhysicalPlan
        + TblColPosInfos TblColPosInfoSlice
        + PartitionedTable []table.PartitionedTable

        + Init(ctx sessionctx.Context) *Update
        + ResolveIndices() error

    }
    class WindowFrame << (S,Aquamarine) >> {
        + Type ast.FrameType
        + Start *FrameBound
        + End *FrameBound

    }
    class WindowFuncExtractor << (S,Aquamarine) >> {
        - windowFuncs []*ast.WindowFuncExpr

        + Enter(n ast.Node) (ast.Node, bool)
        + Leave(n ast.Node) (ast.Node, bool)

    }
    class aggHintInfo << (S,Aquamarine) >> {
        - preferAggType uint
        - preferAggToCop bool

    }
    class aggOrderByResolver << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - err error
        - args []ast.ExprNode
        - exprDepth int

        + Enter(inNode ast.Node) (ast.Node, bool)
        + Leave(inNode ast.Node) (ast.Node, bool)

    }
    class aggregationEliminateChecker << (S,Aquamarine) >> {
        - tryToEliminateAggregation(agg *LogicalAggregation) *LogicalProjection

    }
    class aggregationEliminator << (S,Aquamarine) >> {
        - optimize(ctx context.Context, p LogicalPlan) (LogicalPlan, error)
        - name() string

    }
    class aggregationPushDownSolver << (S,Aquamarine) >> {
        - isDecomposableWithJoin(fun *aggregation.AggFuncDesc) bool
        - isDecomposableWithUnion(fun *aggregation.AggFuncDesc) bool
        - getAggFuncChildIdx(aggFunc *aggregation.AggFuncDesc, schema *expression.Schema) int
        - collectAggFuncs(agg *LogicalAggregation, join *LogicalJoin) (bool, []*aggregation.AggFuncDesc)
        - collectGbyCols(agg *LogicalAggregation, join *LogicalJoin) []*expression.Column
        - splitAggFuncsAndGbyCols(agg *LogicalAggregation, join *LogicalJoin) (bool, []*aggregation.AggFuncDesc, []*expression.Column)
        - addGbyCol(ctx sessionctx.Context, gbyCols []*expression.Column, cols ...*expression.Column) []*expression.Column
        - checkValidJoin(join *LogicalJoin) bool
        - decompose(ctx sessionctx.Context, aggFunc *aggregation.AggFuncDesc, schema *expression.Schema) ([]*aggregation.AggFuncDesc, *expression.Schema)
        - tryToPushDownAgg(aggFuncs []*aggregation.AggFuncDesc, gbyCols []*expression.Column, join *LogicalJoin, childIdx int, aggHints aggHintInfo, blockOffset int) (LogicalPlan, error)
        - getDefaultValues(agg *LogicalAggregation) ([]types.Datum, bool)
        - checkAnyCountAndSum(aggFuncs []*aggregation.AggFuncDesc) bool
        - makeNewAgg(ctx sessionctx.Context, aggFuncs []*aggregation.AggFuncDesc, gbyCols []*expression.Column, aggHints aggHintInfo, blockOffset int) (*LogicalAggregation, error)
        - splitPartialAgg(agg *LogicalAggregation) *LogicalAggregation
        - pushAggCrossUnion(agg *LogicalAggregation, unionSchema *expression.Schema, unionChild LogicalPlan) (LogicalPlan, error)
        - optimize(ctx context.Context, p LogicalPlan) (LogicalPlan, error)
        - tryAggPushDownForUnion(union *LogicalUnionAll, agg *LogicalAggregation) error
        - aggPushDown(p LogicalPlan) (LogicalPlan, error)
        - name() string

    }
    class analyzeInfo << (S,Aquamarine) >> {
        + DBName string
        + TableName string
        + PartitionName string
        + PhysicalTableID int64
        + Incremental bool

    }
    class baseLogicalPlan << (S,Aquamarine) >> {
        - taskMap <font color=blue>map</font>[string]task
        - self LogicalPlan
        - maxOneRow bool
        - children []LogicalPlan

        - enumeratePhysicalPlans4Task(physicalPlans []PhysicalPlan, prop *property.PhysicalProperty) (task, error)
        - findBestTask(prop *property.PhysicalProperty) (task, error)
        - exhaustPhysicalPlans(_ *property.PhysicalProperty) ([]PhysicalPlan, bool)
        - pushDownTopN(topN *LogicalTopN) LogicalPlan
        - recursiveDeriveStats() (*property.StatsInfo, error)
        - getTask(prop *property.PhysicalProperty) task
        - storeTask(prop *property.PhysicalProperty, task task) 

        + PredicatePushDown(predicates []expression.Expression) ([]expression.Expression, LogicalPlan)
        + DeriveStats(childStats []*property.StatsInfo, selfSchema *expression.Schema, childSchema []*expression.Schema) (*property.StatsInfo, error)
        + HashCode() []byte
        + MaxOneRow() bool
        + ExplainInfo() string
        + BuildKeyInfo(selfSchema *expression.Schema, childSchema []*expression.Schema) 
        + ExtractCorrelatedCols() []*expression.CorrelatedColumn
        + PruneColumns(parentUsedCols []*expression.Column) error
        + Schema() *expression.Schema
        + OutputNames() types.NameSlice
        + SetOutputNames(names types.NameSlice) 
        + Children() []LogicalPlan
        + SetChildren(children ...LogicalPlan) 
        + SetChild(i int, child LogicalPlan) 
        + PreparePossibleProperties(schema *expression.Schema, childrenProperties ...[][]*expression.Column) [][]*expression.Column

    }
    class basePhysicalAgg << (S,Aquamarine) >> {
        + AggFuncs []*aggregation.AggFuncDesc
        + GroupByItems []expression.Expression

        - newPartialAggregate(copTaskType kv.StoreType) PhysicalPlan
        - explainInfo(normalized bool) string
        - initForHash(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalHashAgg
        - initForStream(ctx sessionctx.Context, stats *property.StatsInfo, offset int, props ...*property.PhysicalProperty) *PhysicalStreamAgg
        - numDistinctFunc() int
        - getAggFuncCostFactor() float64

        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + Init(ctx sessionctx.Context, stats *property.StatsInfo, offset int) *basePhysicalAgg
        + ResolveIndices() error

    }
    class basePhysicalJoin << (S,Aquamarine) >> {
        + JoinType JoinType
        + LeftConditions expression.CNFExprs
        + RightConditions expression.CNFExprs
        + OtherConditions expression.CNFExprs
        + InnerChildIdx int
        + OuterJoinKeys []*expression.Column
        + InnerJoinKeys []*expression.Column
        + LeftJoinKeys []*expression.Column
        + RightJoinKeys []*expression.Column
        + DefaultValues []types.Datum

    }
    class basePhysicalPlan << (S,Aquamarine) >> {
        - childrenReqProps []*property.PhysicalProperty
        - self PhysicalPlan
        - children []PhysicalPlan

        - attach2Task(tasks ...task) task

        + StatsCount() float64
        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + GetChildReqProps(idx int) *property.PhysicalProperty
        + Schema() *expression.Schema
        + Children() []PhysicalPlan
        + SetChildren(children ...PhysicalPlan) 
        + SetChild(i int, child PhysicalPlan) 
        + ResolveIndices() error
        + ToPB(_ sessionctx.Context) (*tipb.Executor, error)

    }
    class basePlan << (S,Aquamarine) >> {
        - tp string
        - id int
        - ctx sessionctx.Context
        - stats *property.StatsInfo
        - blockOffset int

        - replaceExprColumns(replace <font color=blue>map</font>[string]*expression.Column) 
        - statsInfo() *property.StatsInfo

        + OutputNames() types.NameSlice
        + SetOutputNames(names types.NameSlice) 
        + ID() int
        + ExplainInfo() string
        + ExplainID() fmt.Stringer
        + TP() string
        + SelectBlockOffset() int
        + Stats() *property.StatsInfo
        + SCtx() sessionctx.Context

    }
    class baseSchemaProducer << (S,Aquamarine) >> {
        - schema *expression.Schema
        - names types.NameSlice

        - setSchemaAndNames(schema *expression.Schema, names types.NameSlice) 

        + OutputNames() types.NameSlice
        + SetOutputNames(names types.NameSlice) 
        + Schema() *expression.Schema
        + SetSchema(schema *expression.Schema) 
        + ResolveIndices() error

    }
    class baseSingleGroupJoinOrderSolver << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - curJoinGroup []*jrNode
        - otherConds []expression.Expression

        - baseNodeCumCost(groupNode LogicalPlan) float64
        - makeBushyJoin(cartesianJoinGroup []LogicalPlan) LogicalPlan
        - newCartesianJoin(lChild LogicalPlan, rChild LogicalPlan) *LogicalJoin
        - newJoinWithEdges(lChild LogicalPlan, rChild LogicalPlan, eqEdges []*expression.ScalarFunction, otherConds []expression.Expression) LogicalPlan
        - calcJoinCumCost(join LogicalPlan, lNode *jrNode, rNode *jrNode) float64

    }
    class buildKeySolver << (S,Aquamarine) >> {
        - optimize(ctx context.Context, lp LogicalPlan) (LogicalPlan, error)
        - name() string

    }
    class cacheableChecker << (S,Aquamarine) >> {
        - cacheable bool
        - schema infoschema.InfoSchema

        - isPartitionTable(tn *ast.TableName) bool

        + Enter(in ast.Node) (ast.Node, bool)
        + Leave(in ast.Node) (ast.Node, bool)

    }
    class candidatePath << (S,Aquamarine) >> {
        - path *util.AccessPath
        - columnSet *intsets.Sparse
        - isSingleScan bool
        - isMatchProp bool

    }
    class colNameResolver << (S,Aquamarine) >> {
        - p LogicalPlan
        - names <font color=blue>map</font>[*types.FieldName]<font color=blue>struct</font>{}

        + Enter(inNode ast.Node) (ast.Node, bool)
        + Leave(inNode ast.Node) (ast.Node, bool)

    }
    class colResolverForOnlyFullGroupBy << (S,Aquamarine) >> {
        - firstNonAggCol *ast.ColumnName
        - exprIdx int
        - firstNonAggColIdx int
        - hasAggFuncOrAnyValue bool

        + Enter(node ast.Node) (ast.Node, bool)
        + Leave(node ast.Node) (ast.Node, bool)
        + Check() error

    }
    class columnPruner << (S,Aquamarine) >> {
        - optimize(ctx context.Context, lp LogicalPlan) (LogicalPlan, error)
        - name() string

    }
    class columnsWithNames << (S,Aquamarine) >> {
        - cols []*expression.Column
        - names types.NameSlice

        - col2Schema() *expression.Schema

        + Append(col *expression.Column, name *types.FieldName) 

    }
    class copTask << (S,Aquamarine) >> {
        - indexPlan PhysicalPlan
        - tablePlan PhysicalPlan
        - cst float64
        - indexPlanFinished bool
        - keepOrder bool
        - doubleReadNeedProj bool
        - extraHandleCol *expression.Column
        - tblColHists *statistics.HistColl
        - tblCols []*expression.Column
        - idxMergePartPlans []PhysicalPlan
        - rootTaskConds []expression.Expression

        - invalid() bool
        - count() float64
        - addCost(cst float64) 
        - cost() float64
        - copy() task
        - plan() PhysicalPlan
        - finishIndexPlan() 
        - getStoreType() kv.StoreType

    }
    class core.AdminPluginsAction << (T, #FF7700) >>  {
    }
    class core.ExprColumnMap << (T, #FF7700) >>  {
    }
    class core.JoinType << (T, #FF7700) >>  {
    }
    class core.PartitionSplitterType << (T, #FF7700) >>  {
    }
    class core.PreprocessOpt << (T, #FF7700) >>  {
    }
    class core.SQLBindOpType << (T, #FF7700) >>  {
    }
    class core.TblColPosInfoSlice << (T, #FF7700) >>  {
    }
    class core.capFlagType << (T, #FF7700) >>  {
    }
    class core.clauseCode << (T, #FF7700) >>  {
    }
    class core.partitionRangeOR << (T, #FF7700) >>  {
    }
    class core.preprocessorFlag << (T, #FF7700) >>  {
    }
    interface dataAccesser  {
        + AccessObject() string
        + OperatorInfo(normalized bool) string

    }
    class dataForPrune << (S,Aquamarine) >> {
        - op string
        - c int64

    }
    class decorrelateSolver << (S,Aquamarine) >> {
        - aggDefaultValueMap(agg *LogicalAggregation) <font color=blue>map</font>[int]*expression.Constant
        - optimize(ctx context.Context, p LogicalPlan) (LogicalPlan, error)
        - name() string

    }
    class expressionRewriter << (S,Aquamarine) >> {
        - ctxStack []expression.Expression
        - ctxNameStk []*types.FieldName
        - p LogicalPlan
        - schema *expression.Schema
        - names []*types.FieldName
        - err error
        - aggrMap <font color=blue>map</font>[*ast.AggregateFuncExpr]int
        - windowMap <font color=blue>map</font>[*ast.WindowFuncExpr]int
        - b *PlanBuilder
        - sctx sessionctx.Context
        - ctx context.Context
        - asScalar bool
        - preprocess <font color=blue>func</font>(ast.Node) ast.Node
        - insertPlan *Insert
        - disableFoldCounter int

        - ctxStackLen() int
        - ctxStackPop(num int) 
        - ctxStackAppend(col expression.Expression, name *types.FieldName) 
        - constructBinaryOpFunction(l expression.Expression, r expression.Expression, op string) (expression.Expression, error)
        - buildSubquery(ctx context.Context, subq *ast.SubqueryExpr) (LogicalPlan, error)
        - buildSemiApplyFromEqualSubq(np LogicalPlan, l expression.Expression, r expression.Expression, not bool) 
        - handleCompareSubquery(ctx context.Context, v *ast.CompareSubqueryExpr) (ast.Node, bool)
        - handleOtherComparableSubq(lexpr expression.Expression, rexpr expression.Expression, np LogicalPlan, useMin bool, cmpFunc string, all bool) 
        - buildQuantifierPlan(plan4Agg *LogicalAggregation, cond expression.Expression, lexpr expression.Expression, rexpr expression.Expression, all bool) 
        - handleNEAny(lexpr expression.Expression, rexpr expression.Expression, np LogicalPlan) 
        - handleEQAll(lexpr expression.Expression, rexpr expression.Expression, np LogicalPlan) 
        - handleExistSubquery(ctx context.Context, v *ast.ExistsSubqueryExpr) (ast.Node, bool)
        - popExistsSubPlan(p LogicalPlan) LogicalPlan
        - handleInSubquery(ctx context.Context, v *ast.PatternInExpr) (ast.Node, bool)
        - handleScalarSubquery(ctx context.Context, v *ast.SubqueryExpr) (ast.Node, bool)
        - newFunction(funcName string, retType *types.FieldType, args ...expression.Expression) (expression.Expression, error)
        - checkTimePrecision(ft *types.FieldType) error
        - useCache() bool
        - rewriteVariable(v *ast.VariableExpr) 
        - unaryOpToExpression(v *ast.UnaryOperationExpr) 
        - binaryOpToExpression(v *ast.BinaryOperationExpr) 
        - notToExpression(hasNot bool, op string, tp *types.FieldType, args ...expression.Expression) expression.Expression
        - isNullToExpression(v *ast.IsNullExpr) 
        - positionToScalarFunc(v *ast.PositionExpr) 
        - isTrueToScalarFunc(v *ast.IsTruthExpr) 
        - inToExpression(lLen int, not bool, tp *types.FieldType) 
        - caseToExpression(v *ast.CaseExpr) 
        - patternLikeToExpression(v *ast.PatternLikeExpr) 
        - regexpToScalarFunc(v *ast.PatternRegexpExpr) 
        - rowToScalarFunc(v *ast.RowExpr) 
        - betweenToExpression(v *ast.BetweenExpr) 
        - rewriteFuncCall(v *ast.FuncCallExpr) bool
        - funcCallToExpression(v *ast.FuncCallExpr) 
        - toTable(v *ast.TableName) 
        - toColumn(v *ast.ColumnName) 
        - evalDefaultExpr(v *ast.DefaultExpr) 

        + Enter(inNode ast.Node) (ast.Node, bool)
        + Leave(originInNode ast.Node) (ast.Node, bool)

    }
    class extractHelper << (S,Aquamarine) >> {
        - extractColInConsExpr(extractCols <font color=blue>map</font>[int64]*types.FieldName, expr *expression.ScalarFunction) (string, []types.Datum)
        - extractColBinaryOpConsExpr(extractCols <font color=blue>map</font>[int64]*types.FieldName, expr *expression.ScalarFunction) (string, []types.Datum)
        - extractColOrExpr(extractCols <font color=blue>map</font>[int64]*types.FieldName, expr *expression.ScalarFunction) (string, []types.Datum)
        - merge(lhs set.StringSet, datums []types.Datum, toLower bool) set.StringSet
        - extractCol(schema *expression.Schema, names []*types.FieldName, predicates []expression.Expression, extractColName string, valueToLower bool) ([]expression.Expression, bool, set.StringSet)
        - extractLikePatternCol(schema *expression.Schema, names []*types.FieldName, predicates []expression.Expression, extractColName string) ([]expression.Expression, []string)
        - extractOrLikePattern(orFunc *expression.ScalarFunction, extractColName string, extractCols <font color=blue>map</font>[int64]*types.FieldName) (bool, string)
        - extractLikePattern(fn *expression.ScalarFunction, extractColName string, extractCols <font color=blue>map</font>[int64]*types.FieldName) (bool, string)
        - findColumn(schema *expression.Schema, names []*types.FieldName, colName string) <font color=blue>map</font>[int64]*types.FieldName
        - getTimeFunctionName(fn *expression.ScalarFunction) string
        - extractTimeRange(ctx sessionctx.Context, schema *expression.Schema, names []*types.FieldName, predicates []expression.Expression, extractColName string, timezone *time.Location) ([]expression.Expression, int64, int64)
        - parseQuantiles(quantileSet set.StringSet) []float64
        - extractCols(schema *expression.Schema, names []*types.FieldName, predicates []expression.Expression, excludeCols set.StringSet, valueToLower bool) ([]expression.Expression, bool, <font color=blue>map</font>[string]set.StringSet)
        - convertToTime(t int64) time.Time

    }
    class fullJoinRowCountHelper << (S,Aquamarine) >> {
        - cartesian bool
        - leftProfile *property.StatsInfo
        - rightProfile *property.StatsInfo
        - leftJoinKeys []*expression.Column
        - rightJoinKeys []*expression.Column
        - leftSchema *expression.Schema
        - rightSchema *expression.Schema

        - estimate() float64

    }
    class gbyResolver << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - fields []*ast.SelectField
        - schema *expression.Schema
        - names []*types.FieldName
        - err error
        - inExpr bool
        - isParam bool
        - exprDepth int

        + Enter(inNode ast.Node) (ast.Node, bool)
        + Leave(inNode ast.Node) (ast.Node, bool)

    }
    class gcSubstituter << (S,Aquamarine) >> {
        - optimize(ctx context.Context, lp LogicalPlan) (LogicalPlan, error)
        - substitute(ctx context.Context, lp LogicalPlan, exprToColumn ExprColumnMap) LogicalPlan
        - name() string

    }
    class handleColHelper << (S,Aquamarine) >> {
        - id2HandleMapStack []<font color=blue>map</font>[int64][]*expression.Column
        - stackTail int

        - appendColToLastMap(tblID int64, col *expression.Column) 
        - popMap() <font color=blue>map</font>[int64][]*expression.Column
        - pushMap(m <font color=blue>map</font>[int64][]*expression.Column) 
        - mergeAndPush(m1 <font color=blue>map</font>[int64][]*expression.Column, m2 <font color=blue>map</font>[int64][]*expression.Column) 
        - tailMap() <font color=blue>map</font>[int64][]*expression.Column

    }
    class havingWindowAndOrderbyExprResolver << (S,Aquamarine) >> {
        - inAggFunc bool
        - inWindowFunc bool
        - inWindowSpec bool
        - inExpr bool
        - orderBy bool
        - err error
        - p LogicalPlan
        - selectFields []*ast.SelectField
        - aggMapper <font color=blue>map</font>[*ast.AggregateFuncExpr]int
        - colMapper <font color=blue>map</font>[*ast.ColumnNameExpr]int
        - gbyItems []*ast.ByItem
        - outerSchemas []*expression.Schema
        - outerNames [][]*types.FieldName
        - curClause clauseCode

        - resolveFromPlan(v *ast.ColumnNameExpr, p LogicalPlan) (int, error)

        + Enter(n ast.Node) (ast.Node, bool)
        + Leave(n ast.Node) (ast.Node, bool)

    }
    class hintTableInfo << (S,Aquamarine) >> {
        - dbName model.CIStr
        - tblName model.CIStr
        - selectOffset int
        - matched bool

    }
    class indexHintInfo << (S,Aquamarine) >> {
        - dbName model.CIStr
        - tblName model.CIStr
        - indexHint *ast.IndexHint
        - matched bool

        - hintTypeString() string
        - indexString() string

    }
    class indexJoinBuildHelper << (S,Aquamarine) >> {
        - join *LogicalJoin
        - chosenIndexInfo *model.IndexInfo
        - maxUsedCols int
        - chosenAccess []expression.Expression
        - chosenRemained []expression.Expression
        - idxOff2KeyOff []int
        - lastColManager *ColWithCmpFuncManager
        - chosenRanges []*ranger.Range
        - chosenPath *util.AccessPath
        - curPossibleUsedKeys []*expression.Column
        - curNotUsedIndexCols []*expression.Column
        - curNotUsedColLens []int
        - curIdxOff2KeyOff []int

        - buildRangeDecidedByInformation(idxCols []*expression.Column, outerJoinKeys []*expression.Column) string
        - resetContextForIndex(innerKeys []*expression.Column, idxCols []*expression.Column, colLens []int) 
        - findUsefulEqAndInFilters(innerPlan *DataSource) []expression.Expression
        - buildLastColManager(nextCol *expression.Column, innerPlan *DataSource, cwc *ColWithCmpFuncManager) []expression.Expression
        - removeUselessEqAndInFunc(idxCols []*expression.Column, notKeyEqAndIn []expression.Expression) []expression.Expression
        - analyzeLookUpFilters(path *util.AccessPath, innerPlan *DataSource, innerJoinKeys []*expression.Column) (bool, error)
        - updateBestChoice(ranges []*ranger.Range, path *util.AccessPath, accesses []expression.Expression, remained []expression.Expression, lastColManager *ColWithCmpFuncManager) 
        - buildTemplateRange(matchedKeyCnt int, eqAndInFuncs []expression.Expression, nextColRange []*ranger.Range, haveExtraCol bool) ([]*ranger.Range, bool, error)

    }
    class indexNestedLoopJoinTables << (S,Aquamarine) >> {
        - inljTables []hintTableInfo
        - inlhjTables []hintTableInfo
        - inlmjTables []hintTableInfo

    }
    class itemTransformer << (S,Aquamarine) >> {
        + Enter(inNode ast.Node) (ast.Node, bool)
        + Leave(inNode ast.Node) (ast.Node, bool)

    }
    class joinGroupEqEdge << (S,Aquamarine) >> {
        - nodeIDs []int
        - edge *expression.ScalarFunction

    }
    class joinGroupNonEqEdge << (S,Aquamarine) >> {
        - nodeIDs []int
        - nodeIDMask uint
        - expr expression.Expression

    }
    class joinReOrderSolver << (S,Aquamarine) >> {
        - optimize(ctx context.Context, p LogicalPlan) (LogicalPlan, error)
        - optimizeRecursive(ctx sessionctx.Context, p LogicalPlan) (LogicalPlan, error)
        - name() string

    }
    class joinReorderDPSolver << (S,Aquamarine) >> {
        - newJoin <font color=blue>func</font>(LogicalPlan, LogicalPlan, []*expression.ScalarFunction, []expression.Expression) LogicalPlan

        - solve(joinGroup []LogicalPlan, eqConds []expression.Expression) (LogicalPlan, error)
        - bfsGraph(startNode int, visited []bool, adjacents [][]int, nodeID2VistID []int) []int
        - dpGraph(visitID2NodeID []int, nodeID2VisitID []int, joinGroup []LogicalPlan, totalEqEdges []joinGroupEqEdge, totalNonEqEdges []joinGroupNonEqEdge) (LogicalPlan, error)
        - nodesAreConnected(leftMask uint, rightMask uint, oldPos2NewPos []int, totalEqEdges []joinGroupEqEdge, totalNonEqEdges []joinGroupNonEqEdge) ([]joinGroupEqEdge, []expression.Expression)
        - newJoinWithEdge(leftPlan LogicalPlan, rightPlan LogicalPlan, edges []joinGroupEqEdge, otherConds []expression.Expression) (LogicalPlan, error)
        - makeBushyJoin(cartesianJoinGroup []LogicalPlan, otherConds []expression.Expression) LogicalPlan
        - newJoinWithConds(leftPlan LogicalPlan, rightPlan LogicalPlan, eqConds []*expression.ScalarFunction, otherConds []expression.Expression) LogicalPlan

    }
    class joinReorderGreedySolver << (S,Aquamarine) >> {
        - eqEdges []*expression.ScalarFunction

        - solve(joinNodePlans []LogicalPlan) (LogicalPlan, error)
        - constructConnectedJoinTree() (*jrNode, error)
        - checkConnectionAndMakeJoin(leftNode LogicalPlan, rightNode LogicalPlan) (LogicalPlan, []expression.Expression)

    }
    class jrNode << (S,Aquamarine) >> {
        - p LogicalPlan
        - cumCost float64

    }
    class lessThanDataInt << (S,Aquamarine) >> {
        - data []int64
        - maxvalue bool

        - length() int
        - compare(ith int, v int64, unsigned bool) int

    }
    interface logicalOptRule  {
        - optimize( context.Context,  LogicalPlan) (LogicalPlan, error)
        - name() string

    }
    class logicalSchemaProducer << (S,Aquamarine) >> {
        - schema *expression.Schema
        - names types.NameSlice

        - setSchemaAndNames(schema *expression.Schema, names types.NameSlice) 
        - inlineProjection(parentUsedCols []*expression.Column) 

        + BuildKeyInfo(selfSchema *expression.Schema, childSchema []*expression.Schema) 
        + Schema() *expression.Schema
        + OutputNames() types.NameSlice
        + SetOutputNames(names types.NameSlice) 
        + SetSchema(schema *expression.Schema) 

    }
    class maxMinEliminator << (S,Aquamarine) >> {
        - optimize(ctx context.Context, p LogicalPlan) (LogicalPlan, error)
        - composeAggsByInnerJoin(aggs []*LogicalAggregation) LogicalPlan
        - checkColCanUseIndex(plan LogicalPlan, col *expression.Column, conditions []expression.Expression) bool
        - cloneSubPlans(plan LogicalPlan) LogicalPlan
        - splitAggFuncAndCheckIndices(agg *LogicalAggregation) ([]*LogicalAggregation, bool)
        - eliminateSingleMaxMin(agg *LogicalAggregation) *LogicalAggregation
        - eliminateMaxMin(p LogicalPlan) LogicalPlan
        - name() string

    }
    class nameValuePair << (S,Aquamarine) >> {
        - colName string
        - value types.Datum
        - param *parser_driver.ParamMarkerExpr

    }
    class outerJoinEliminator << (S,Aquamarine) >> {
        - tryToEliminateOuterJoin(p *LogicalJoin, aggCols []*expression.Column, parentCols []*expression.Column) (LogicalPlan, bool, error)
        - extractInnerJoinKeys(join *LogicalJoin, innerChildIdx int) *expression.Schema
        - isInnerJoinKeysContainUniqueKey(innerPlan LogicalPlan, joinKeys *expression.Schema) (bool, error)
        - isInnerJoinKeysContainIndex(innerPlan LogicalPlan, joinKeys *expression.Schema) (bool, error)
        - doOptimize(p LogicalPlan, aggCols []*expression.Column, parentCols []*expression.Column) (LogicalPlan, error)
        - optimize(ctx context.Context, p LogicalPlan) (LogicalPlan, error)
        - name() string

    }
    class paramMarkerInPrepareChecker << (S,Aquamarine) >> {
        - inPrepareStmt bool

        + Enter(in ast.Node) (ast.Node, bool)
        + Leave(in ast.Node) (ast.Node, bool)

    }
    class partitionProcessor << (S,Aquamarine) >> {
        - optimize(ctx context.Context, lp LogicalPlan) (LogicalPlan, error)
        - rewriteDataSource(lp LogicalPlan) (LogicalPlan, error)
        - pruneHashPartition(ds *DataSource, pi *model.PartitionInfo) (LogicalPlan, error)
        - prune(ds *DataSource) (LogicalPlan, error)
        - findByName(partitionNames []model.CIStr, partitionName string) bool
        - name() string
        - pruneRangePartition(ds *DataSource, pi *model.PartitionInfo) (LogicalPlan, error)
        - makeUnionAllChildren(ds *DataSource, pi *model.PartitionInfo, or partitionRangeOR) (LogicalPlan, error)
        - pruneRangeColumnsPartition(ds *DataSource, pi *model.PartitionInfo, pe *tables.PartitionExpr) (LogicalPlan, error)

    }
    class partitionRange << (S,Aquamarine) >> {
        - start int
        - end int

    }
    class partitionRangeOR << (S,Aquamarine) >> {
        - intersectionRange(start int, end int) partitionRangeOR
        - union(x partitionRangeOR) partitionRangeOR
        - simplify() partitionRangeOR
        - intersection(x partitionRangeOR) partitionRangeOR

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    interface partitionRangePruner  {
        - partitionRangeForExpr( sessionctx.Context,  expression.Expression) (int, bool)
        - fullRange() partitionRangeOR

    }
    interface partitionTable  {
        + PartitionExpr() (*tables.PartitionExpr, error)

    }
    class physicalSchemaProducer << (S,Aquamarine) >> {
        - schema *expression.Schema

        + Schema() *expression.Schema
        + SetSchema(schema *expression.Schema) 
        + ResolveIndices() error

    }
    class planDigester << (S,Aquamarine) >> {
        - buf bytes.Buffer
        - encodedPlans <font color=blue>map</font>[int]bool
        - hasher hash.Hash

        - normalizePlanTree(p PhysicalPlan) 
        - normalizePlan(p PhysicalPlan, isRoot bool, depth int) 

    }
    class planEncoder << (S,Aquamarine) >> {
        - buf bytes.Buffer
        - encodedPlans <font color=blue>map</font>[int]bool

        - encodePlanTree(p PhysicalPlan) string
        - encodePlan(p PhysicalPlan, isRoot bool, depth int) 

    }
    class ppdSolver << (S,Aquamarine) >> {
        - optimize(ctx context.Context, lp LogicalPlan) (LogicalPlan, error)
        - name() string

    }
    class preprocessor << (S,Aquamarine) >> {
        - is infoschema.InfoSchema
        - ctx sessionctx.Context
        - err error
        - flag preprocessorFlag
        - tableAliasInJoin []<font color=blue>map</font>[string]<font color=blue>interface</font>{}

        - checkBindGrammar(originSel ast.StmtNode, hintedSel ast.StmtNode) 
        - checkAutoIncrement(stmt *ast.CreateTableStmt) 
        - checkUnionSelectList(stmt *ast.UnionSelectList) 
        - checkCreateDatabaseGrammar(stmt *ast.CreateDatabaseStmt) 
        - checkAlterDatabaseGrammar(stmt *ast.AlterDatabaseStmt) 
        - checkDropDatabaseGrammar(stmt *ast.DropDatabaseStmt) 
        - checkCreateTableGrammar(stmt *ast.CreateTableStmt) 
        - checkCreateViewGrammar(stmt *ast.CreateViewStmt) 
        - checkCreateViewWithSelect(stmt *ast.SelectStmt) 
        - checkCreateViewWithSelectGrammar(stmt *ast.CreateViewStmt) 
        - checkDropSequenceGrammar(stmt *ast.DropSequenceStmt) 
        - checkDropTableGrammar(stmt *ast.DropTableStmt) 
        - checkDropTableNames(tables []*ast.TableName) 
        - checkNonUniqTableAlias(stmt *ast.Join) 
        - checkCreateIndexGrammar(stmt *ast.CreateIndexStmt) 
        - checkRenameTableGrammar(stmt *ast.RenameTableStmt) 
        - checkRenameTable(oldTable string, newTable string) 
        - checkRepairTableGrammar(stmt *ast.RepairTableStmt) 
        - checkAlterTableGrammar(stmt *ast.AlterTableStmt) 
        - checkContainDotColumn(stmt *ast.CreateTableStmt) 
        - handleTableName(tn *ast.TableName) 
        - checkNotInRepair(tn *ast.TableName) 
        - handleRepairName(tn *ast.TableName) 
        - resolveShowStmt(node *ast.ShowStmt) 
        - resolveCreateTableStmt(node *ast.CreateTableStmt) 
        - resolveAlterTableStmt(node *ast.AlterTableStmt) 
        - resolveCreateSequenceStmt(stmt *ast.CreateSequenceStmt) 

        + Enter(in ast.Node) (ast.Node, bool)
        + Leave(in ast.Node) (ast.Node, bool)

    }
    class projInjector << (S,Aquamarine) >> {
        - inject(plan PhysicalPlan) PhysicalPlan

    }
    class projectionEliminator << (S,Aquamarine) >> {
        - optimize(ctx context.Context, lp LogicalPlan) (LogicalPlan, error)
        - eliminate(p LogicalPlan, replace <font color=blue>map</font>[string]*expression.Column, canEliminate bool) LogicalPlan
        - name() string

    }
    class pstmtPlanCacheKey << (S,Aquamarine) >> {
        - database string
        - connID uint64
        - pstmtID uint32
        - snapshot uint64
        - schemaVersion int64
        - sqlMode errno.SQLMode
        - timezoneOffset int
        - selectLimit uint64
        - isolationReadEngines <font color=blue>map</font>[kv.StoreType]<font color=blue>struct</font>{}
        - hash []byte

        + Hash() []byte

    }
    class pushDownTopNOptimizer << (S,Aquamarine) >> {
        - optimize(ctx context.Context, p LogicalPlan) (LogicalPlan, error)
        - name() string

    }
    class rangeColumnsPruner << (S,Aquamarine) >> {
        - data []expression.Expression
        - partCol *expression.Column
        - maxvalue bool

        - fullRange() partitionRangeOR
        - partitionRangeForExpr(sctx sessionctx.Context, expr expression.Expression) (int, int, bool)
        - pruneUseBinarySearch(sctx sessionctx.Context, op string, data *expression.Constant) (int, int)

    }
    class rangePruner << (S,Aquamarine) >> {
        - lessThan lessThanDataInt
        - col *expression.Column
        - partFn *expression.ScalarFunction

        - partitionRangeForExpr(sctx sessionctx.Context, expr expression.Expression) (int, int, bool)
        - fullRange() partitionRangeOR
        - extractDataForPrune(sctx sessionctx.Context, expr expression.Expression) (dataForPrune, bool)

    }
    class rootTask << (S,Aquamarine) >> {
        - p PhysicalPlan
        - cst float64

        - invalid() bool
        - copy() task
        - count() float64
        - addCost(cst float64) 
        - cost() float64
        - plan() PhysicalPlan

    }
    class tableHintInfo << (S,Aquamarine) >> {
        - sortMergeJoinTables []hintTableInfo
        - hashJoinTables []hintTableInfo
        - indexHintList []indexHintInfo
        - tiflashTables []hintTableInfo
        - tikvTables []hintTableInfo
        - aggHints aggHintInfo
        - indexMergeHintList []indexHintInfo
        - timeRangeHint ast.HintTimeRange

        - ifPreferMergeJoin(tableNames ...*hintTableInfo) bool
        - ifPreferHashJoin(tableNames ...*hintTableInfo) bool
        - ifPreferINLJ(tableNames ...*hintTableInfo) bool
        - ifPreferINLHJ(tableNames ...*hintTableInfo) bool
        - ifPreferINLMJ(tableNames ...*hintTableInfo) bool
        - ifPreferTiFlash(tableNames ...*hintTableInfo) bool
        - ifPreferTiKV(tableNames ...*hintTableInfo) bool
        - matchTableName(tables []*hintTableInfo, hintTables []hintTableInfo) bool

    }
    interface task  {
        - count() float64
        - addCost(cost float64) 
        - cost() float64
        - copy() task
        - plan() PhysicalPlan
        - invalid() bool

    }
    class visitInfo << (S,Aquamarine) >> {
        - privilege errno.PrivilegeType
        - db string
        - table string
        - column string
        - err error

    }
    class windowFuncs << (S,Aquamarine) >> {
        - spec *ast.WindowSpec
        - funcs []*ast.WindowFuncExpr

    }
    class "<font color=blue>map</font>[expression.Expression]*expression.Column" as fontcolorbluemapfontexpressionExpressionexpressionColumn {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"core.baseSchemaProducer" *-- "core.AdminPlugins"
"core.baseSchemaProducer" *-- "core.AdminResetTelemetryID"
"core.baseSchemaProducer" *-- "core.AdminShowTelemetry"
"core.baseSchemaProducer" *-- "core.Analyze"
"core.analyzeInfo" *-- "core.AnalyzeColumnsTask"
"core.analyzeInfo" *-- "core.AnalyzeIndexTask"
"core.baseSchemaProducer" *-- "core.BatchPointGetPlan"
"core.baseSchemaProducer" *-- "core.CancelDDLJobs"
"ast.ChangeStmt" *-- "core.Change"
"core.baseSchemaProducer" *-- "core.Change"
"core.baseSchemaProducer" *-- "core.CheckIndexRange"
"core.baseSchemaProducer" *-- "core.CheckTable"
"core.baseSchemaProducer" *-- "core.ChecksumTable"
"core.baseSchemaProducer" *-- "core.CleanupIndex"
"core.extractHelper" *-- "core.ClusterLogTableExtractor"
"core.extractHelper" *-- "core.ClusterTableExtractor"
"core.baseSchemaProducer" *-- "core.DDL"
"core.logicalSchemaProducer" *-- "core.DataSource"
"core.baseSchemaProducer" *-- "core.Deallocate"
"core.baseSchemaProducer" *-- "core.Delete"
"core.baseSchemaProducer" *-- "core.Execute"
"core.baseSchemaProducer" *-- "core.Explain"
"core.baseSchemaProducer" *-- "core.IndexAdvise"
"core.baseSchemaProducer" *-- "core.Insert"
"core.extractHelper" *-- "core.InspectionResultTableExtractor"
"core.extractHelper" *-- "core.InspectionRuleTableExtractor"
"core.extractHelper" *-- "core.InspectionSummaryTableExtractor"
"core.baseSchemaProducer" *-- "core.LoadData"
"core.baseSchemaProducer" *-- "core.LoadStats"
"core.logicalSchemaProducer" *-- "core.LogicalAggregation"
"core.LogicalJoin" *-- "core.LogicalApply"
"core.logicalSchemaProducer" *-- "core.LogicalIndexScan"
"core.logicalSchemaProducer" *-- "core.LogicalJoin"
"core.baseLogicalPlan" *-- "core.LogicalLimit"
"core.baseLogicalPlan" *-- "core.LogicalLock"
"core.baseLogicalPlan" *-- "core.LogicalMaxOneRow"
"core.logicalSchemaProducer" *-- "core.LogicalMemTable"
"core.LogicalUnionAll" *-- "core.LogicalPartitionUnionAll"
"core.Plan" *-- "core.LogicalPlan"
"core.logicalSchemaProducer" *-- "core.LogicalProjection"
"core.baseLogicalPlan" *-- "core.LogicalSelection"
"core.ShowContents" *-- "core.LogicalShow"
"core.logicalSchemaProducer" *-- "core.LogicalShow"
"core.logicalSchemaProducer" *-- "core.LogicalShowDDLJobs"
"core.baseLogicalPlan" *-- "core.LogicalSort"
"core.logicalSchemaProducer" *-- "core.LogicalTableDual"
"core.logicalSchemaProducer" *-- "core.LogicalTableScan"
"core.baseLogicalPlan" *-- "core.LogicalTopN"
"core.logicalSchemaProducer" *-- "core.LogicalUnionAll"
"core.baseLogicalPlan" *-- "core.LogicalUnionScan"
"core.logicalSchemaProducer" *-- "core.LogicalWindow"
"core.extractHelper" *-- "core.MetricSummaryTableExtractor"
"core.extractHelper" *-- "core.MetricTableExtractor"
"core.basePhysicalPlan" *-- "core.NominalSort"
"core.PhysicalHashJoin" *-- "core.PhysicalApply"
"core.basePhysicalAgg" *-- "core.PhysicalHashAgg"
"core.basePhysicalJoin" *-- "core.PhysicalHashJoin"
"core.PhysicalIndexJoin" *-- "core.PhysicalIndexHashJoin"
"core.basePhysicalJoin" *-- "core.PhysicalIndexJoin"
"core.physicalSchemaProducer" *-- "core.PhysicalIndexLookUpReader"
"core.PhysicalIndexJoin" *-- "core.PhysicalIndexMergeJoin"
"core.physicalSchemaProducer" *-- "core.PhysicalIndexMergeReader"
"core.physicalSchemaProducer" *-- "core.PhysicalIndexReader"
"core.physicalSchemaProducer" *-- "core.PhysicalIndexScan"
"core.basePhysicalPlan" *-- "core.PhysicalLimit"
"core.basePhysicalPlan" *-- "core.PhysicalLock"
"core.basePhysicalPlan" *-- "core.PhysicalMaxOneRow"
"core.physicalSchemaProducer" *-- "core.PhysicalMemTable"
"core.basePhysicalJoin" *-- "core.PhysicalMergeJoin"
"core.Plan" *-- "core.PhysicalPlan"
"core.physicalSchemaProducer" *-- "core.PhysicalProjection"
"core.basePhysicalPlan" *-- "core.PhysicalSelection"
"core.ShowContents" *-- "core.PhysicalShow"
"core.physicalSchemaProducer" *-- "core.PhysicalShow"
"core.physicalSchemaProducer" *-- "core.PhysicalShowDDLJobs"
"core.basePhysicalPlan" *-- "core.PhysicalShuffle"
"core.physicalSchemaProducer" *-- "core.PhysicalShuffleDataSourceStub"
"core.basePhysicalPlan" *-- "core.PhysicalSort"
"core.basePhysicalAgg" *-- "core.PhysicalStreamAgg"
"core.physicalSchemaProducer" *-- "core.PhysicalTableDual"
"core.physicalSchemaProducer" *-- "core.PhysicalTableReader"
"core.physicalSchemaProducer" *-- "core.PhysicalTableScan"
"core.basePhysicalPlan" *-- "core.PhysicalTopN"
"core.physicalSchemaProducer" *-- "core.PhysicalUnionAll"
"core.basePhysicalPlan" *-- "core.PhysicalUnionScan"
"core.physicalSchemaProducer" *-- "core.PhysicalWindow"
"core.basePlan" *-- "core.PointGetPlan"
"core.baseSchemaProducer" *-- "core.Prepare"
"core.baseSchemaProducer" *-- "core.RecoverIndex"
"core.baseSchemaProducer" *-- "core.ReloadExprPushdownBlacklist"
"core.baseSchemaProducer" *-- "core.ReloadOptRuleBlacklist"
"core.baseSchemaProducer" *-- "core.SQLBindPlan"
"core.baseSchemaProducer" *-- "core.SelectInto"
"core.baseSchemaProducer" *-- "core.Set"
"core.baseSchemaProducer" *-- "core.SetConfig"
"core.baseSchemaProducer" *-- "core.ShowDDL"
"core.baseSchemaProducer" *-- "core.ShowDDLJobQueries"
"core.baseSchemaProducer" *-- "core.ShowNextRowID"
"ast.ShowSlow" *-- "core.ShowSlow"
"core.baseSchemaProducer" *-- "core.ShowSlow"
"core.baseSchemaProducer" *-- "core.Simple"
"core.extractHelper" *-- "core.SlowQueryExtractor"
"core.baseSchemaProducer" *-- "core.SplitRegion"
"core.baseSchemaProducer" *-- "core.SplitRegionStatus"
"core.logicalSchemaProducer" *-- "core.TiKVSingleGather"
"core.baseSchemaProducer" *-- "core.Trace"
"core.baseSchemaProducer" *-- "core.Update"
"core.aggregationEliminateChecker" *-- "core.aggregationEliminator"
"core.aggregationEliminateChecker" *-- "core.aggregationPushDownSolver"
"core.basePlan" *-- "core.baseLogicalPlan"
"core.physicalSchemaProducer" *-- "core.basePhysicalAgg"
"core.physicalSchemaProducer" *-- "core.basePhysicalJoin"
"core.basePlan" *-- "core.basePhysicalPlan"
"core.basePlan" *-- "core.baseSchemaProducer"
"core.baseSingleGroupJoinOrderSolver" *-- "core.joinReorderDPSolver"
"core.baseSingleGroupJoinOrderSolver" *-- "core.joinReorderGreedySolver"
"core.baseLogicalPlan" *-- "core.logicalSchemaProducer"
"core.basePhysicalPlan" *-- "core.physicalSchemaProducer"
"core.indexNestedLoopJoinTables" *-- "core.tableHintInfo"

"core.dataAccesser" <|-- "core.BatchPointGetPlan"
"core.MemTablePredicateExtractor" <|-- "core.ClusterLogTableExtractor"
"core.MemTablePredicateExtractor" <|-- "core.ClusterTableExtractor"
"core.MemTablePredicateExtractor" <|-- "core.InspectionResultTableExtractor"
"core.MemTablePredicateExtractor" <|-- "core.InspectionRuleTableExtractor"
"core.MemTablePredicateExtractor" <|-- "core.InspectionSummaryTableExtractor"
"core.MemTablePredicateExtractor" <|-- "core.MetricSummaryTableExtractor"
"core.MemTablePredicateExtractor" <|-- "core.MetricTableExtractor"
"core.dataAccesser" <|-- "core.PhysicalIndexScan"
"core.dataAccesser" <|-- "core.PhysicalMemTable"
"core.dataAccesser" <|-- "core.PhysicalTableScan"
"core.dataAccesser" <|-- "core.PointGetPlan"
"core.MemTablePredicateExtractor" <|-- "core.SlowQueryExtractor"
"core.logicalOptRule" <|-- "core.aggregationEliminator"
"core.logicalOptRule" <|-- "core.aggregationPushDownSolver"
"core.LogicalPlan" <|-- "core.baseLogicalPlan"
"core.logicalOptRule" <|-- "core.buildKeySolver"
"core.logicalOptRule" <|-- "core.columnPruner"
"core.task" <|-- "core.copTask"
"core.logicalOptRule" <|-- "core.decorrelateSolver"
"core.logicalOptRule" <|-- "core.gcSubstituter"
"core.logicalOptRule" <|-- "core.joinReOrderSolver"
"core.logicalOptRule" <|-- "core.maxMinEliminator"
"core.logicalOptRule" <|-- "core.outerJoinEliminator"
"core.logicalOptRule" <|-- "core.partitionProcessor"
"core.logicalOptRule" <|-- "core.ppdSolver"
"core.logicalOptRule" <|-- "core.projectionEliminator"
"kvcache.Key" <|-- "core.pstmtPlanCacheKey"
"core.logicalOptRule" <|-- "core.pushDownTopNOptimizer"
"core.task" <|-- "core.rootTask"

namespace ddl {
    class AlterAlgorithm << (S,Aquamarine) >> {
        - supported []ast.AlgorithmType
        - defAlgorithm ast.AlgorithmType

    }
    class BaseCallback << (S,Aquamarine) >> {
        + OnChanged(err error) error
        + OnJobRunBefore(job *model.Job) 
        + OnJobUpdated(job *model.Job) 
        + OnWatched(ctx context.Context) 

    }
    class BaseInterceptor << (S,Aquamarine) >> {
        + OnGetInfoSchema(ctx sessionctx.Context, is infoschema.InfoSchema) infoschema.InfoSchema

    }
    interface Callback  {
        + OnChanged(err error) error
        + OnJobRunBefore(job *model.Job) 
        + OnJobUpdated(job *model.Job) 
        + OnWatched(ctx context.Context) 

    }
    interface DDL  {
        + CreateSchema(ctx sessionctx.Context, name model.CIStr, charsetInfo *ast.CharsetOpt) error
        + AlterSchema(ctx sessionctx.Context, stmt *ast.AlterDatabaseStmt) error
        + DropSchema(ctx sessionctx.Context, schema model.CIStr) error
        + CreateTable(ctx sessionctx.Context, stmt *ast.CreateTableStmt) error
        + CreateView(ctx sessionctx.Context, stmt *ast.CreateViewStmt) error
        + DropTable(ctx sessionctx.Context, tableIdent ast.Ident) error
        + RecoverTable(ctx sessionctx.Context, recoverInfo *RecoverInfo) error
        + DropView(ctx sessionctx.Context, tableIdent ast.Ident) error
        + CreateIndex(ctx sessionctx.Context, tableIdent ast.Ident, keyType ast.IndexKeyType, indexName model.CIStr, columnNames []*ast.IndexPartSpecification, indexOption *ast.IndexOption, ifNotExists bool) error
        + DropIndex(ctx sessionctx.Context, tableIdent ast.Ident, indexName model.CIStr, ifExists bool) error
        + AlterTable(ctx sessionctx.Context, tableIdent ast.Ident, spec []*ast.AlterTableSpec) error
        + TruncateTable(ctx sessionctx.Context, tableIdent ast.Ident) error
        + RenameTable(ctx sessionctx.Context, oldTableIdent ast.Ident, newTableIdent ast.Ident, isAlterTable bool) error
        + LockTables(ctx sessionctx.Context, stmt *ast.LockTablesStmt) error
        + UnlockTables(ctx sessionctx.Context, lockedTables []model.TableLockTpInfo) error
        + CleanupTableLock(ctx sessionctx.Context, tables []*ast.TableName) error
        + UpdateTableReplicaInfo(ctx sessionctx.Context, physicalID int64, available bool) error
        + RepairTable(ctx sessionctx.Context, table *ast.TableName, createStmt *ast.CreateTableStmt) error
        + CreateSequence(ctx sessionctx.Context, stmt *ast.CreateSequenceStmt) error
        + DropSequence(ctx sessionctx.Context, tableIdent ast.Ident, ifExists bool) error
        + CreateSchemaWithInfo(ctx sessionctx.Context, info *model.DBInfo, onExist OnExist, tryRetainID bool) error
        + CreateTableWithInfo(ctx sessionctx.Context, schema model.CIStr, info *model.TableInfo, onExist OnExist, tryRetainID bool) error
        + Start(ctxPool *pools.ResourcePool) error
        + GetLease() time.Duration
        + Stats(vars *variable.SessionVars) (<font color=blue>map</font>[string]<font color=blue>interface</font>{}, error)
        + GetScope(status string) variable.ScopeFlag
        + Stop() error
        + RegisterEventCh( <font color=blue>chan</font> *util.Event) 
        + SchemaSyncer() util.SchemaSyncer
        + OwnerManager() owner.Manager
        + GetID() string
        + GetTableMaxRowID(startTS uint64, tbl table.PhysicalTable) (int64, bool, error)
        + SetBinlogClient( *pump_client.PumpsClient) 
        + GetHook() Callback

    }
    interface Interceptor  {
        + OnGetInfoSchema(ctx sessionctx.Context, is infoschema.InfoSchema) infoschema.InfoSchema

    }
    class MockSchemaSyncer << (S,Aquamarine) >> {
        - selfSchemaVersion int64
        - globalVerCh <font color=blue>chan</font> clientv3.WatchResponse
        - mockSession <font color=blue>chan</font> <font color=blue>struct</font>{}

        + Init(ctx context.Context) error
        + GlobalVersionCh() clientv3.WatchChan
        + WatchGlobalSchemaVer( context.Context) 
        + UpdateSelfVersion(ctx context.Context, version int64) error
        + Done() <font color=blue>chan</font> <font color=blue>struct</font>{}
        + CloseSession() 
        + Restart(_ context.Context) error
        + RemoveSelfVersionPath() error
        + OwnerUpdateGlobalVersion(ctx context.Context, version int64) error
        + MustGetGlobalVersion(ctx context.Context) (int64, error)
        + OwnerCheckAllVersions(ctx context.Context, latestVer int64) error
        + NotifyCleanExpiredPaths() bool
        + StartCleanWork() 
        + CloseCleanWork() 

    }
    class Options << (S,Aquamarine) >> {
        + EtcdCli *clientv3.Client
        + Store kv.Storage
        + InfoHandle *infoschema.Handle
        + Hook Callback
        + Lease time.Duration

    }
    class RecoverInfo << (S,Aquamarine) >> {
        + SchemaID int64
        + TableInfo *model.TableInfo
        + DropJobID int64
        + SnapshotTS uint64
        + CurAutoIncID int64
        + CurAutoRandID int64

    }
    class addIndexResult << (S,Aquamarine) >> {
        - addedCount int
        - scanCount int
        - nextHandle int64
        - err error

    }
    class addIndexTaskContext << (S,Aquamarine) >> {
        - nextHandle int64
        - done bool
        - addedCount int
        - scanCount int

    }
    class addIndexWorker << (S,Aquamarine) >> {
        - id int
        - ddlWorker *worker
        - batchCnt int
        - sessCtx sessionctx.Context
        - taskCh <font color=blue>chan</font> *reorgIndexTask
        - resultCh <font color=blue>chan</font> *addIndexResult
        - index table.Index
        - table table.Table
        - closed bool
        - priority int
        - defaultVals []types.Datum
        - idxRecords []*indexRecord
        - rowMap <font color=blue>map</font>[int64]types.Datum
        - rowDecoder *decoder.RowDecoder
        - idxKeyBufs [][]byte
        - batchCheckKeys []kv.Key
        - distinctCheckFlags []bool

        - close() 
        - getIndexRecord(handle int64, recordKey []byte, rawRecord []byte) (*indexRecord, error)
        - cleanRowMap() 
        - getNextHandle(taskRange reorgIndexTask, taskDone bool) int64
        - fetchRowColVals(txn kv.Transaction, taskRange reorgIndexTask) ([]*indexRecord, int64, bool, error)
        - logSlowOperations(elapsed time.Duration, slowMsg string, threshold uint32) 
        - initBatchCheckBufs(batchCount int) 
        - batchCheckUniqueKey(txn kv.Transaction, idxRecords []*indexRecord) error
        - backfillIndexInTxn(handleRange reorgIndexTask) (addIndexTaskContext, error)
        - handleBackfillTask(d *ddlCtx, task *reorgIndexTask) *addIndexResult
        - run(d *ddlCtx) 

    }
    class columnGenerationInDDL << (S,Aquamarine) >> {
        - position int
        - generated bool
        - dependences <font color=blue>map</font>[string]<font color=blue>struct</font>{}

    }
    class columnInfoSlice << (S,Aquamarine) >> {
        + Len() int
        + At(i int) string

    }
    class columnNameExtractor << (S,Aquamarine) >> {
        - extractedColumns []*model.ColumnInfo
        - tblInfo *model.TableInfo
        - err error

        + Enter(node ast.Node) (ast.Node, bool)
        + Leave(node ast.Node) (ast.Node, bool)

    }
    class columnNameSlice << (S,Aquamarine) >> {
        + Len() int
        + At(i int) string

    }
    class ddl << (S,Aquamarine) >> {
        - m sync.RWMutex
        - quitCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - wg sync.WaitGroup
        - limitJobCh <font color=blue>chan</font> *limitJobTask
        - workers <font color=blue>map</font>[workerType]*worker
        - sessPool *sessionPool
        - delRangeMgr delRangeManager

        - assignTableID(tbInfo *model.TableInfo) error
        - assignPartitionIDs(tbInfo *model.TableInfo) error
        - preSplitAndScatter(ctx sessionctx.Context, tbInfo *model.TableInfo, pi *model.PartitionInfo) 
        - handleAutoIncID(tbInfo *model.TableInfo, schemaID int64, tp autoid.AllocatorType) error
        - getSchemaAndTableByIdent(ctx sessionctx.Context, tableIdent ast.Ident) (*model.DBInfo, table.Table, error)
        - getModifiableColumnJob(ctx sessionctx.Context, ident ast.Ident, originalColName model.CIStr, spec *ast.AlterTableSpec) (*model.Job, error)
        - newDeleteRangeManager(mock bool) delRangeManager
        - close() 
        - genGlobalIDs(count int) ([]int64, error)
        - asyncNotifyWorker(jobTp model.ActionType) 
        - doDDLJob(ctx sessionctx.Context, job *model.Job) error
        - callHookOnChanged(err error) error
        - limitDDLJobs() 
        - addBatchDDLJobs(tasks []*limitJobTask) 
        - getHistoryDDLJob(id int64) (*model.Job, error)

        + CreateSchema(ctx sessionctx.Context, schema model.CIStr, charsetInfo *ast.CharsetOpt) error
        + CreateSchemaWithInfo(ctx sessionctx.Context, dbInfo *model.DBInfo, onExist OnExist, tryRetainID bool) error
        + AlterSchema(ctx sessionctx.Context, stmt *ast.AlterDatabaseStmt) error
        + DropSchema(ctx sessionctx.Context, schema model.CIStr) error
        + CreateTable(ctx sessionctx.Context, s *ast.CreateTableStmt) error
        + CreateTableWithInfo(ctx sessionctx.Context, dbName model.CIStr, tbInfo *model.TableInfo, onExist OnExist, tryRetainID bool) error
        + RecoverTable(ctx sessionctx.Context, recoverInfo *RecoverInfo) error
        + CreateView(ctx sessionctx.Context, s *ast.CreateViewStmt) error
        + AlterTable(ctx sessionctx.Context, ident ast.Ident, specs []*ast.AlterTableSpec) error
        + RebaseAutoID(ctx sessionctx.Context, ident ast.Ident, newBase int64, tp autoid.AllocatorType) error
        + ShardRowID(ctx sessionctx.Context, tableIdent ast.Ident, uVal uint64) error
        + AddColumn(ctx sessionctx.Context, ti ast.Ident, spec *ast.AlterTableSpec) error
        + AddTablePartitions(ctx sessionctx.Context, ident ast.Ident, spec *ast.AlterTableSpec) error
        + CoalescePartitions(ctx sessionctx.Context, ident ast.Ident, spec *ast.AlterTableSpec) error
        + TruncateTablePartition(ctx sessionctx.Context, ident ast.Ident, spec *ast.AlterTableSpec) error
        + DropTablePartition(ctx sessionctx.Context, ident ast.Ident, spec *ast.AlterTableSpec) error
        + DropColumn(ctx sessionctx.Context, ti ast.Ident, spec *ast.AlterTableSpec) error
        + ChangeColumn(ctx sessionctx.Context, ident ast.Ident, spec *ast.AlterTableSpec) error
        + RenameColumn(ctx sessionctx.Context, ident ast.Ident, spec *ast.AlterTableSpec) error
        + ModifyColumn(ctx sessionctx.Context, ident ast.Ident, spec *ast.AlterTableSpec) error
        + AlterColumn(ctx sessionctx.Context, ident ast.Ident, spec *ast.AlterTableSpec) error
        + AlterTableComment(ctx sessionctx.Context, ident ast.Ident, spec *ast.AlterTableSpec) error
        + AlterTableAutoIDCache(ctx sessionctx.Context, ident ast.Ident, newCache int64) error
        + AlterTableCharsetAndCollate(ctx sessionctx.Context, ident ast.Ident, toCharset string, toCollate string, needsOverwriteCols bool) error
        + AlterTableSetTiFlashReplica(ctx sessionctx.Context, ident ast.Ident, replicaInfo *ast.TiFlashReplicaSpec) error
        + UpdateTableReplicaInfo(ctx sessionctx.Context, physicalID int64, available bool) error
        + RenameIndex(ctx sessionctx.Context, ident ast.Ident, spec *ast.AlterTableSpec) error
        + DropTable(ctx sessionctx.Context, ti ast.Ident) error
        + DropView(ctx sessionctx.Context, ti ast.Ident) error
        + TruncateTable(ctx sessionctx.Context, ti ast.Ident) error
        + RenameTable(ctx sessionctx.Context, oldIdent ast.Ident, newIdent ast.Ident, isAlterTable bool) error
        + CreatePrimaryKey(ctx sessionctx.Context, ti ast.Ident, indexName model.CIStr, indexPartSpecifications []*ast.IndexPartSpecification, indexOption *ast.IndexOption) error
        + CreateIndex(ctx sessionctx.Context, ti ast.Ident, keyType ast.IndexKeyType, indexName model.CIStr, indexPartSpecifications []*ast.IndexPartSpecification, indexOption *ast.IndexOption, ifNotExists bool) error
        + CreateForeignKey(ctx sessionctx.Context, ti ast.Ident, fkName model.CIStr, keys []*ast.IndexPartSpecification, refer *ast.ReferenceDef) error
        + DropForeignKey(ctx sessionctx.Context, ti ast.Ident, fkName model.CIStr) error
        + DropIndex(ctx sessionctx.Context, ti ast.Ident, indexName model.CIStr, ifExists bool) error
        + LockTables(ctx sessionctx.Context, stmt *ast.LockTablesStmt) error
        + UnlockTables(ctx sessionctx.Context, unlockTables []model.TableLockTpInfo) error
        + CleanupTableLock(ctx sessionctx.Context, tables []*ast.TableName) error
        + RepairTable(ctx sessionctx.Context, table *ast.TableName, createStmt *ast.CreateTableStmt) error
        + OrderByColumns(ctx sessionctx.Context, ident ast.Ident) error
        + CreateSequence(ctx sessionctx.Context, stmt *ast.CreateSequenceStmt) error
        + DropSequence(ctx sessionctx.Context, ti ast.Ident, ifExists bool) error
        + RegisterEventCh(ch <font color=blue>chan</font> *util.Event) 
        + Stop() error
        + Start(ctxPool *pools.ResourcePool) error
        + GetLease() time.Duration
        + GetInfoSchemaWithInterceptor(ctx sessionctx.Context) infoschema.InfoSchema
        + SchemaSyncer() util.SchemaSyncer
        + OwnerManager() owner.Manager
        + GetID() string
        + SetBinlogClient(binlogCli *pump_client.PumpsClient) 
        + GetHook() Callback
        + GetScope(status string) variable.ScopeFlag
        + Stats(vars *variable.SessionVars) (<font color=blue>map</font>[string]<font color=blue>interface</font>{}, error)

    }
    class ddl.OnExist << (T, #FF7700) >>  {
    }
    class ddl.Option << (T, #FF7700) >>  {
    }
    class ddl.columnInfoSlice << (T, #FF7700) >>  {
    }
    class ddl.columnNameSlice << (T, #FF7700) >>  {
    }
    class ddl.recordIterFunc << (T, #FF7700) >>  {
    }
    class ddl.workerType << (T, #FF7700) >>  {
    }
    class ddlCtx << (S,Aquamarine) >> {
        - uuid string
        - store kv.Storage
        - ownerManager owner.Manager
        - schemaSyncer util.SchemaSyncer
        - ddlJobDoneCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - ddlEventCh <font color=blue>chan</font> *util.Event
        - lease time.Duration
        - binlogCli *pump_client.PumpsClient
        - infoHandle *infoschema.Handle
        - mu <font color=blue>struct</font>{sync.RWMutex, Callback, Interceptor}

        - isOwner() bool
        - buildDescTableScan(ctx context.Context, startTS uint64, tbl table.PhysicalTable, columns []*model.ColumnInfo, limit uint64) (distsql.SelectResult, error)

        + GetTableMaxRowID(startTS uint64, tbl table.PhysicalTable) (int64, bool, error)

    }
    class delRange << (S,Aquamarine) >> {
        - store kv.Storage
        - sessPool *sessionPool
        - emulatorCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - keys []kv.Key
        - quitCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - wait sync.WaitGroup
        - storeSupport bool

        - addDelRangeJob(job *model.Job) error
        - removeFromGCDeleteRange(jobID int64, tableIDs []int64) error
        - start() 
        - clear() 
        - startEmulator() 
        - doDelRangeWork() error
        - doTask(ctx sessionctx.Context, r util.DelRangeTask) error

    }
    interface delRangeManager  {
        - addDelRangeJob(job *model.Job) error
        - removeFromGCDeleteRange(jobID int64, tableID []int64) error
        - start() 
        - clear() 

    }
    class generatedColumnChecker << (S,Aquamarine) >> {
        - cols []*ast.ColumnName

        + Enter(inNode ast.Node) (ast.Node, bool)
        + Leave(inNode ast.Node) (ast.Node, bool)

    }
    class illegalFunctionChecker << (S,Aquamarine) >> {
        - hasIllegalFunc bool
        - hasAggFunc bool

        + Enter(inNode ast.Node) (ast.Node, bool)
        + Leave(inNode ast.Node) (ast.Node, bool)

    }
    class indexRecord << (S,Aquamarine) >> {
        - handle int64
        - key []byte
        - vals []types.Datum
        - skip bool

    }
    class limitJobTask << (S,Aquamarine) >> {
        - job *model.Job
        - err <font color=blue>chan</font> error

    }
    class lockTablesArg << (S,Aquamarine) >> {
        + LockTables []model.TableLockTpInfo
        + IndexOfLock int
        + UnlockTables []model.TableLockTpInfo
        + IndexOfUnlock int
        + SessionInfo model.SessionInfo
        + IsCleanup bool

    }
    class mockDelRange << (S,Aquamarine) >> {
        - addDelRangeJob(job *model.Job) error
        - removeFromGCDeleteRange(jobID int64, tableIDs []int64) error
        - start() 
        - clear() 

    }
    class reorgCtx << (S,Aquamarine) >> {
        - doneCh <font color=blue>chan</font> error
        - rowCount int64
        - notifyCancelReorgJob int32
        - doneHandle int64

        - notifyReorgCancel() 
        - cleanNotifyReorgCancel() 
        - isReorgCanceled() bool
        - setRowCount(count int64) 
        - setNextHandle(doneHandle int64) 
        - increaseRowCount(count int64) 
        - getRowCountAndHandle() (int64, int64)
        - clean() 

    }
    class reorgIndexTask << (S,Aquamarine) >> {
        - physicalTableID int64
        - startHandle int64
        - endHandle int64
        - endIncluded bool

        + String() string

    }
    class reorgInfo << (S,Aquamarine) >> {
        - d *ddlCtx
        - first bool

        + StartHandle int64
        + EndHandle int64
        + PhysicalTableID int64

        + String() string
        + UpdateReorgMeta(txn kv.Transaction, startHandle int64, endHandle int64, physicalTableID int64) error

    }
    class sessionPool << (S,Aquamarine) >> {
        - mu <font color=blue>struct</font>{sync.Mutex, bool}
        - resPool *pools.ResourcePool

        - get() (sessionctx.Context, error)
        - put(ctx sessionctx.Context) 
        - close() 

    }
    interface stringSlice  {
        + Len() int
        + At(i int) string

    }
    class worker << (S,Aquamarine) >> {
        - id int32
        - tp workerType
        - ddlJobCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - quitCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - wg sync.WaitGroup
        - sessPool *sessionPool
        - reorgCtx *reorgCtx
        - delRangeManager delRangeManager
        - logCtx context.Context

        - runReorgJob(t *meta.Meta, reorgInfo *reorgInfo, tblInfo *model.TableInfo, lease time.Duration, f <font color=blue>func</font>() error) error
        - isReorgRunnable(d *ddlCtx) error
        - typeStr() string
        - close() 
        - start(d *ddlCtx) 
        - getFirstDDLJob(t *meta.Meta) (*model.Job, error)
        - handleUpdateJobError(t *meta.Meta, job *model.Job, err error) error
        - updateDDLJob(t *meta.Meta, job *model.Job, meetErr bool) error
        - deleteRange(job *model.Job) error
        - finishDDLJob(t *meta.Meta, job *model.Job) error
        - handleDDLJobQueue(d *ddlCtx) error
        - waitDependencyJobFinished(job *model.Job, cnt *int) 
        - runDDLJob(d *ddlCtx, t *meta.Meta, job *model.Job) (int64, error)
        - waitSchemaChanged(ctx context.Context, d *ddlCtx, waitTime time.Duration, latestSchemaVersion int64, job *model.Job) 
        - waitSchemaSynced(d *ddlCtx, job *model.Job, waitTime time.Duration) 
        - onModifyColumn(t *meta.Meta, job *model.Job) (int64, error)
        - doModifyColumn(t *meta.Meta, job *model.Job, newCol *model.ColumnInfo, oldName *model.CIStr, pos *ast.ColumnPosition, modifyColumnTp byte) (int64, error)
        - onRecoverTable(d *ddlCtx, t *meta.Meta, job *model.Job) (int64, error)
        - onShardRowID(d *ddlCtx, t *meta.Meta, job *model.Job) (int64, error)
        - onCreateIndex(d *ddlCtx, t *meta.Meta, job *model.Job, isPK bool) (int64, error)
        - waitTaskResults(workers []*addIndexWorker, taskCnt int, totalAddedCount *int64, startHandle int64) (int64, int64, error)
        - handleReorgTasks(reorgInfo *reorgInfo, totalAddedCount *int64, workers []*addIndexWorker, batchTasks []*reorgIndexTask) error
        - sendRangeTaskToWorkers(t table.Table, workers []*addIndexWorker, reorgInfo *reorgInfo, totalAddedCount *int64, kvRanges []kv.KeyRange) ([]kv.KeyRange, error)
        - addPhysicalTableIndex(t table.PhysicalTable, indexInfo *model.IndexInfo, reorgInfo *reorgInfo) error
        - addTableIndex(t table.Table, idx *model.IndexInfo, reorgInfo *reorgInfo) error
        - updateReorgInfo(t table.PartitionedTable, reorg *reorgInfo) (bool, error)

        + String() string

    }
    class "<font color=blue>func</font>(int64, kv.Key, []byte) (bool, error)" as fontcolorbluefuncfontint64kvKeybyteboolerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "[]*model.ColumnInfo" as modelColumnInfo {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "[]*ast.ColumnName" as astColumnName {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"ddl.ddlCtx" *-- "ddl.ddl"
"model.Job" *-- "ddl.reorgInfo"

"ddl.Callback" <|-- "ddl.BaseCallback"
"ddl.Interceptor" <|-- "ddl.BaseInterceptor"
"util.SchemaSyncer" <|-- "ddl.MockSchemaSyncer"
"ddl.stringSlice" <|-- "ddl.columnInfoSlice"
"ddl.stringSlice" <|-- "ddl.columnNameSlice"
"variable.Statistics" <|-- "ddl.ddl"
"ddl.delRangeManager" <|-- "ddl.delRange"
"ddl.delRangeManager" <|-- "ddl.mockDelRange"

namespace deadlock {
    class Detector << (S,Aquamarine) >> {
        - waitForMap <font color=blue>map</font>[uint64]*txnList
        - lock sync.Mutex

        - doDetect(sourceTxn uint64, waitForTxn uint64) *ErrDeadlock
        - register(sourceTxn uint64, waitForTxn uint64, keyHash uint64) 

        + Detect(sourceTxn uint64, waitForTxn uint64, keyHash uint64) *ErrDeadlock
        + CleanUp(txn uint64) 
        + CleanUpWaitFor(txn uint64, waitForTxn uint64, keyHash uint64) 
        + Expire(minTS uint64) 

    }
    class ErrDeadlock << (S,Aquamarine) >> {
        + KeyHash uint64

        + Error() string

    }
    class txnKeyHashPair << (S,Aquamarine) >> {
        - txn uint64
        - keyHash uint64

    }
    class txnList << (S,Aquamarine) >> {
        - txns []txnKeyHashPair

    }
}


namespace decoder {
    class Column << (S,Aquamarine) >> {
        + Col *table.Column
        + GenExpr expression.Expression

    }
    class RowDecoder << (S,Aquamarine) >> {
        - tbl table.Table
        - mutRow chunk.MutRow
        - columns <font color=blue>map</font>[int64]Column
        - colTypes <font color=blue>map</font>[int64]*types.FieldType
        - haveGenColumn bool
        - defaultVals []types.Datum

        + DecodeAndEvalRowWithMap(ctx sessionctx.Context, handle int64, b []byte, decodeLoc *time.Location, sysLoc *time.Location, row <font color=blue>map</font>[int64]types.Datum) (<font color=blue>map</font>[int64]types.Datum, error)

    }
}


namespace disjointset {
    class IntSet << (S,Aquamarine) >> {
        - parent []int

        + Union(a int, b int) 
        + FindRoot(a int) int

    }
}


namespace disk {
    class disk.Tracker << (T, #FF7700) >>  {
    }
    class "memory.Tracker" as memoryTracker {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace distsql {
    class RequestBuilder << (S,Aquamarine) >> {
        - err error

        - getIsolationLevel() kv.IsoLevel
        - getKVPriority(sv *variable.SessionVars) int

        + Build() (*kv.Request, error)
        + SetMemTracker(tracker *memory.Tracker) *RequestBuilder
        + SetTableRanges(tid int64, tableRanges []*ranger.Range, fb *statistics.QueryFeedback) *RequestBuilder
        + SetIndexRanges(sc *stmtctx.StatementContext, tid int64, idxID int64, ranges []*ranger.Range) *RequestBuilder
        + SetTableHandles(tid int64, handles []int64) *RequestBuilder
        + SetDAGRequest(dag *tipb.DAGRequest) *RequestBuilder
        + SetAnalyzeRequest(ana *tipb.AnalyzeReq) *RequestBuilder
        + SetChecksumRequest(checksum *tipb.ChecksumRequest) *RequestBuilder
        + SetKeyRanges(keyRanges []kv.KeyRange) *RequestBuilder
        + SetStartTS(startTS uint64) *RequestBuilder
        + SetDesc(desc bool) *RequestBuilder
        + SetKeepOrder(order bool) *RequestBuilder
        + SetStoreType(storeType kv.StoreType) *RequestBuilder
        + SetAllowBatchCop(batchCop bool) *RequestBuilder
        + SetFromSessionVars(sv *variable.SessionVars) *RequestBuilder
        + SetStreaming(streaming bool) *RequestBuilder
        + SetConcurrency(concurrency int) *RequestBuilder

    }
    interface SelectResult  {
        + Fetch( context.Context) 
        + NextRaw( context.Context) ([]byte, error)
        + Next( context.Context,  *chunk.Chunk) error
        + Close() error

    }
    class selectResult << (S,Aquamarine) >> {
        - label string
        - resp kv.Response
        - rowLen int
        - fieldTypes []*types.FieldType
        - ctx sessionctx.Context
        - selectResp *tipb.SelectResponse
        - selectRespSize int
        - respChkIdx int
        - respChunkDecoder *chunk.Decoder
        - feedback *statistics.QueryFeedback
        - partialCount int64
        - sqlType string
        - encodeType tipb.EncodeType
        - copPlanIDs []fmt.Stringer
        - rootPlanID fmt.Stringer
        - fetchDuration time.Duration
        - durationReported bool
        - memTracker *memory.Tracker

        - fetchResp(ctx context.Context) error
        - readFromDefault(ctx context.Context, chk *chunk.Chunk) error
        - readFromChunk(ctx context.Context, chk *chunk.Chunk) error
        - updateCopRuntimeStats(detail *execdetails.ExecDetails, respTime time.Duration) 
        - readRowsData(chk *chunk.Chunk) error
        - memConsume(bytes int64) 

        + Fetch(ctx context.Context) 
        + Next(ctx context.Context, chk *chunk.Chunk) error
        + NextRaw(ctx context.Context) ([]byte, error)
        + Close() error

    }
    class streamResult << (S,Aquamarine) >> {
        - label string
        - sqlType string
        - resp kv.Response
        - rowLen int
        - fieldTypes []*types.FieldType
        - ctx sessionctx.Context
        - curr *tipb.Chunk
        - partialCount int64
        - feedback *statistics.QueryFeedback
        - fetchDuration time.Duration
        - durationReported bool

        - readDataFromResponse(ctx context.Context, resp kv.Response, result *tipb.Chunk) (bool, error)
        - readDataIfNecessary(ctx context.Context) error
        - flushToChunk(chk *chunk.Chunk) error

        + Fetch( context.Context) 
        + Next(ctx context.Context, chk *chunk.Chunk) error
        + NextRaw(ctx context.Context) ([]byte, error)
        + Close() error

    }
}
"kv.Request" *-- "distsql.RequestBuilder"

"distsql.SelectResult" <|-- "distsql.selectResult"
"executor.Closeable" <|-- "distsql.selectResult"
"distsql.SelectResult" <|-- "distsql.streamResult"
"executor.Closeable" <|-- "distsql.streamResult"

namespace domain {
    class Domain << (S,Aquamarine) >> {
        - store kv.Storage
        - infoHandle *infoschema.Handle
        - privHandle *privileges.Handle
        - bindHandle *bindinfo.BindHandle
        - statsHandle unsafe.Pointer
        - statsLease time.Duration
        - ddl ddl.DDL
        - info *infosync.InfoSyncer
        - m sync.Mutex
        - sysSessionPool *sessionPool
        - exit <font color=blue>chan</font> <font color=blue>struct</font>{}
        - etcdClient *clientv3.Client
        - gvc GlobalVariableCache
        - slowQuery *topNSlowQueries
        - expensiveQueryHandle *expensivequery.Handle
        - wg sync.WaitGroup
        - statsUpdating sync2.AtomicInt32
        - cancel context.CancelFunc

        + SchemaValidator SchemaValidator

        - loadInfoSchema(handle *infoschema.Handle, usedSchemaVersion int64, startTS uint64) (int64, []int64, bool, error)
        - fetchAllSchemasWithTables(m *meta.Meta) ([]*model.DBInfo, error)
        - splitForConcurrentFetch(schemas []*model.DBInfo) [][]*model.DBInfo
        - fetchSchemasWithTables(schemas []*model.DBInfo, m *meta.Meta, done <font color=blue>chan</font> error) 
        - tryLoadSchemaDiffs(m *meta.Meta, usedVersion int64, newVersion int64) (bool, []int64, error)
        - topNSlowQueryLoop() 
        - infoSyncerKeeper() 
        - topologySyncerKeeper() 
        - loadSchemaInLoop(ctx context.Context, lease time.Duration) 
        - mustRestartSyncer(ctx context.Context) error
        - mustReload() bool
        - isClose() bool
        - globalBindHandleWorkerLoop() 
        - handleEvolvePlanTasksLoop(ctx sessionctx.Context) 
        - newOwnerManager(prompt string, ownerKey string) owner.Manager
        - loadStatsWorker() 
        - updateStatsWorker(ctx sessionctx.Context, owner owner.Manager) 
        - autoAnalyzeWorker(owner owner.Manager) 

        + GetGlobalVarsCache() *GlobalVariableCache
        + InfoSchema() infoschema.InfoSchema
        + GetSnapshotInfoSchema(snapshotTS uint64) (infoschema.InfoSchema, error)
        + GetSnapshotMeta(startTS uint64) (*meta.Meta, error)
        + DDL() ddl.DDL
        + InfoSyncer() *infosync.InfoSyncer
        + Store() kv.Storage
        + GetScope(status string) variable.ScopeFlag
        + Reload() error
        + LogSlowQuery(query *SlowQueryInfo) 
        + ShowSlowQuery(showSlow *ast.ShowSlow) []*SlowQueryInfo
        + Close() 
        + Init(ddlLease time.Duration, sysFactory <font color=blue>func</font>(*Domain) (pools.Resource, error)) error
        + SysSessionPool() *sessionPool
        + GetEtcdClient() *clientv3.Client
        + LoadPrivilegeLoop(ctx sessionctx.Context) error
        + PrivilegeHandle() *privileges.Handle
        + BindHandle() *bindinfo.BindHandle
        + LoadBindInfoLoop(ctxForHandle sessionctx.Context, ctxForEvolve sessionctx.Context) error
        + TelemetryLoop(ctx sessionctx.Context) 
        + StatsHandle() *handle.Handle
        + CreateStatsHandle(ctx sessionctx.Context) 
        + StatsUpdating() bool
        + SetStatsUpdating(val bool) 
        + UpdateTableStatsLoop(ctx sessionctx.Context) error
        + ExpensiveQueryHandle() *expensivequery.Handle
        + InitExpensiveQueryHandle() 
        + NotifyUpdatePrivilege(ctx sessionctx.Context) 

    }
    class GlobalVariableCache << (S,Aquamarine) >> {
        - lastModify time.Time
        - rows []chunk.Row
        - fields []*ast.ResultField
        - disable bool

        + SingleFight singleflight.Group

        + Update(rows []chunk.Row, fields []*ast.ResultField) 
        + Get() (bool, []chunk.Row, []*ast.ResultField)
        + LoadGlobalVariables(loadFn <font color=blue>func</font>() ([]chunk.Row, []*ast.ResultField, error)) ([]chunk.Row, []*ast.ResultField, error)
        + Disable() 

    }
    class SchemaChecker << (S,Aquamarine) >> {
        - schemaVer int64
        - relatedTableIDs []int64

        + Check(txnTS uint64) error

    }
    interface SchemaValidator  {
        + Update(leaseGrantTime uint64, oldSchemaVer int64, newSchemaVer int64, changedTableIDs []int64) 
        + Check(txnTS uint64, schemaVer int64, relatedPhysicalTableIDs []int64) checkResult
        + Stop() 
        + Restart() 
        + Reset() 
        + IsStarted() bool

    }
    class SlowQueryInfo << (S,Aquamarine) >> {
        + SQL string
        + Start time.Time
        + Duration time.Duration
        + Detail execdetails.ExecDetails
        + ConnID uint64
        + TxnTS uint64
        + User string
        + DB string
        + TableIDs string
        + IndexNames string
        + Digest string
        + Internal bool
        + Succ bool

    }
    class ddlCallback << (S,Aquamarine) >> {
        - do *Domain

        + OnChanged(err error) error

    }
    class deltaSchemaInfo << (S,Aquamarine) >> {
        - schemaVersion int64
        - relatedIDs []int64

    }
    class domain.checkResult << (T, #FF7700) >>  {
    }
    class domain.domainKeyType << (T, #FF7700) >>  {
    }
    class domain.ids << (T, #FF7700) >>  {
    }
    class domainKeyType << (S,Aquamarine) >> {
        + String() string

    }
    class ids << (S,Aquamarine) >> {
        - containIn(b []int64) bool

    }
    class loadResult << (S,Aquamarine) >> {
        - rows []chunk.Row
        - fields []*ast.ResultField

    }
    class schemaValidator << (S,Aquamarine) >> {
        - isStarted bool
        - mux sync.RWMutex
        - lease time.Duration
        - latestSchemaVer int64
        - latestSchemaExpire time.Time
        - deltaSchemaInfos []deltaSchemaInfo

        - isRelatedTablesChanged(currVer int64, tableIDs []int64) bool
        - findNewerDeltas(currVer int64) []deltaSchemaInfo
        - enqueue(schemaVersion int64, relatedPhysicalTableIDs []int64) 

        + IsStarted() bool
        + LatestSchemaVersion() int64
        + Stop() 
        + Restart() 
        + Reset() 
        + Update(leaseGrantTS uint64, oldVer int64, currVer int64, changedTableIDs []int64) 
        + Check(txnTS uint64, schemaVer int64, relatedPhysicalTableIDs []int64) checkResult

    }
    class sessionPool << (S,Aquamarine) >> {
        - resources <font color=blue>chan</font> pools.Resource
        - factory pools.Factory
        - mu <font color=blue>struct</font>{sync.RWMutex, bool}

        + Get() (pools.Resource, error)
        + Put(resource pools.Resource) 
        + Close() 

    }
    class showSlowMessage << (S,Aquamarine) >> {
        - request *ast.ShowSlow
        - result []*SlowQueryInfo

    }
    class slowQueryHeap << (S,Aquamarine) >> {
        - data []*SlowQueryInfo

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}
        + RemoveExpired(now time.Time, period time.Duration) 
        + Query(count int) []*SlowQueryInfo

    }
    class slowQueryQueue << (S,Aquamarine) >> {
        - data []*SlowQueryInfo
        - size int

        + Enqueue(info *SlowQueryInfo) 
        + Query(count int) []*SlowQueryInfo

    }
    class topNSlowQueries << (S,Aquamarine) >> {
        - recent slowQueryQueue
        - user slowQueryHeap
        - internal slowQueryHeap
        - topN int
        - period time.Duration
        - ch <font color=blue>chan</font> *SlowQueryInfo
        - msgCh <font color=blue>chan</font> *showSlowMessage
        - mu <font color=blue>struct</font>{sync.RWMutex, bool}

        + Append(info *SlowQueryInfo) 
        + QueryAll() []*SlowQueryInfo
        + RemoveExpired(now time.Time) 
        + QueryRecent(count int) []*SlowQueryInfo
        + QueryTop(count int, kind ast.ShowSlowKind) []*SlowQueryInfo
        + Close() 

    }
}
"sync.RWMutex" *-- "domain.GlobalVariableCache"
"domain.SchemaValidator" *-- "domain.SchemaChecker"
"ddl.BaseCallback" *-- "domain.ddlCallback"
"sync.WaitGroup" *-- "domain.showSlowMessage"

"tikv.schemaLeaseChecker" <|-- "domain.SchemaChecker"
"domain.SchemaValidator" <|-- "domain.schemaValidator"
"session.sessionPool" <|-- "domain.sessionPool"

namespace domainutil {
    class domainutil.repairKeyType << (T, #FF7700) >>  {
    }
    class repairInfo << (S,Aquamarine) >> {
        - repairMode bool
        - repairTableList []string
        - repairDBInfoMap <font color=blue>map</font>[int64]*model.DBInfo

        + InRepairMode() bool
        + SetRepairMode(mode bool) 
        + GetRepairTableList() []string
        + SetRepairTableList(list []string) 
        + CheckAndFetchRepairedTable(di *model.DBInfo, tbl *model.TableInfo) bool
        + GetRepairedTableInfoByTableName(schemaLowerName string, tableLowerName string) (*model.TableInfo, *model.DBInfo)
        + RemoveFromRepairInfo(schemaLowerName string, tableLowerName string) 

    }
    class repairKeyType << (S,Aquamarine) >> {
        + String() string

    }
}
"sync.RWMutex" *-- "domainutil.repairInfo"


namespace driver {
    class ParamMarkerExpr << (S,Aquamarine) >> {
        + Offset int
        + Order int
        + InExecute bool

        + Restore(ctx *format.RestoreCtx) error
        + Format(w io.Writer) 
        + Accept(v types.Visitor) (types.Node, bool)
        + SetOrder(order int) 

    }
    class ValueExpr << (S,Aquamarine) >> {
        - projectionOffset int

        + SetValue(res <font color=blue>interface</font>{}) 
        + Restore(ctx *format.RestoreCtx) error
        + GetDatumString() string
        + Format(w io.Writer) 
        + SetProjectionOffset(offset int) 
        + GetProjectionOffset() int
        + Accept(v types.Visitor) (types.Node, bool)

    }
    class driver.featureID << (T, #FF7700) >>  {
    }
}
"driver.ValueExpr" *-- "driver.ParamMarkerExpr"
"types.Datum" *-- "driver.ValueExpr"
"types.TexprNode" *-- "driver.ValueExpr"


namespace encrypt {
    class ecb << (S,Aquamarine) >> {
        - b cipher.Block
        - blockSize int

    }
    class ecbDecrypter << (S,Aquamarine) >> {
        + BlockSize() int
        + CryptBlocks(dst []byte, src []byte) 

    }
    class ecbEncrypter << (S,Aquamarine) >> {
        + BlockSize() int
        + CryptBlocks(dst []byte, src []byte) 

    }
    class encrypt.ecbDecrypter << (T, #FF7700) >>  {
    }
    class encrypt.ecbEncrypter << (T, #FF7700) >>  {
    }
    class randStruct << (S,Aquamarine) >> {
        - seed1 uint32
        - seed2 uint32
        - maxValue uint32
        - maxValueDbl float64

        - randomInit(password []byte, length int) 
        - myRand() float64

    }
    class sqlCrypt << (S,Aquamarine) >> {
        - rand randStruct
        - orgRand randStruct
        - decodeBuff []byte
        - encodeBuff []byte
        - shift uint32

        - init(password []byte, length int) 
        - encode(str []byte, length int) 
        - decode(str []byte, length int) 

    }
}


namespace execdetails {
    class CommitDetails << (S,Aquamarine) >> {
        + GetCommitTsTime time.Duration
        + PrewriteTime time.Duration
        + WaitPrewriteBinlogTime time.Duration
        + CommitTime time.Duration
        + LocalLatchTime time.Duration
        + CommitBackoffTime int64
        + Mu <font color=blue>struct</font>{sync.Mutex, []fmt.Stringer}
        + ResolveLockTime int64
        + WriteKeys int
        + WriteSize int
        + PrewriteRegionNum int32
        + TxnRetry int

    }
    class ConcurrencyInfo << (S,Aquamarine) >> {
        - concurrencyName string
        - concurrencyNum int

    }
    class CopRuntimeStats << (S,Aquamarine) >> {
        - stats <font color=blue>map</font>[string][]*RuntimeStats

        + RecordOneCopTask(address string, summary *tipb.ExecutorExecutionSummary) 
        + GetActRows() int64
        + String() string

    }
    class ExecDetails << (S,Aquamarine) >> {
        + CalleeAddress string
        + CopTime time.Duration
        + ProcessTime time.Duration
        + WaitTime time.Duration
        + BackoffTime time.Duration
        + LockKeysDuration time.Duration
        + BackoffSleep <font color=blue>map</font>[string]time.Duration
        + BackoffTimes <font color=blue>map</font>[string]int
        + RequestCount int
        + TotalKeys int64
        + ProcessedKeys int64
        + CommitDetail *CommitDetails

        + String() string
        + ToZapFields() []zap.Field

    }
    class ReaderRuntimeStats << (S,Aquamarine) >> {
        - copRespTime []time.Duration
        - procKeys []int64

        - recordOneCopTask(t time.Duration, detail *ExecDetails) 

        + String() string

    }
    class RuntimeStats << (S,Aquamarine) >> {
        - loop int32
        - consume int64
        - rows int64
        - mu sync.Mutex
        - concurrency []*ConcurrencyInfo
        - additionalInfo string

        + Record(d time.Duration, rowNum int) 
        + SetRowNum(rowNum int64) 
        + SetConcurrencyInfo(infos ...*ConcurrencyInfo) 
        + SetAdditionalInfo(info string) 
        + GetActRows() int64
        + String() string

    }
    class RuntimeStatsColl << (S,Aquamarine) >> {
        - mu sync.Mutex
        - rootStats <font color=blue>map</font>[string]*RuntimeStats
        - copStats <font color=blue>map</font>[string]*CopRuntimeStats
        - readerStats <font color=blue>map</font>[string]*ReaderRuntimeStats

        + GetRootStats(planID string) *RuntimeStats
        + GetCopStats(planID string) *CopRuntimeStats
        + RecordOneCopTask(planID string, address string, summary *tipb.ExecutorExecutionSummary) 
        + RecordOneReaderStats(planID string, copRespTime time.Duration, detail *ExecDetails) 
        + ExistsRootStats(planID string) bool
        + ExistsCopStats(planID string) bool
        + GetReaderStats(planID string) *ReaderRuntimeStats

    }
    class commitDetailCtxKeyType << (S,Aquamarine) >> {
    }
}
"sync.Mutex" *-- "execdetails.CopRuntimeStats"
"sync.Mutex" *-- "execdetails.ReaderRuntimeStats"


namespace executor {
    class AdminPluginsExec << (S,Aquamarine) >> {
        + Action core.AdminPluginsAction
        + Plugins []string

        - changeDisableFlagAndFlush(disabled bool) error

        + Next(ctx context.Context, _ *chunk.Chunk) error

    }
    class AdminResetTelemetryIDExec << (S,Aquamarine) >> {
        - done bool

        + Next(ctx context.Context, _ *chunk.Chunk) error

    }
    class AdminShowTelemetryExec << (S,Aquamarine) >> {
        - done bool

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class AfFinalResult << (S,Aquamarine) >> {
        - chk *chunk.Chunk
        - err error
        - giveBackCh <font color=blue>chan</font> *chunk.Chunk

    }
    class AnalyzeColumnsExec << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - physicalTableID int64
        - colsInfo []*model.ColumnInfo
        - pkInfo *model.ColumnInfo
        - concurrency int
        - priority int
        - analyzePB *tipb.AnalyzeReq
        - resultHandler *tableResultHandler
        - opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64
        - job *statistics.AnalyzeJob

        - open(ranges []*ranger.Range) error
        - buildResp(ranges []*ranger.Range) (distsql.SelectResult, error)
        - buildStats(ranges []*ranger.Range) ([]*statistics.Histogram, []*statistics.CMSketch, error)

    }
    class AnalyzeExec << (S,Aquamarine) >> {
        - tasks []*analyzeTask
        - wg *sync.WaitGroup

        - analyzeWorker(taskCh <font color=blue>chan</font> *analyzeTask, resultCh <font color=blue>chan</font> analyzeResult, isCloseChanThread bool) 

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class AnalyzeFastExec << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - physicalTableID int64
        - pkInfo *model.ColumnInfo
        - colsInfo []*model.ColumnInfo
        - idxsInfo []*model.IndexInfo
        - concurrency int
        - opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64
        - tblInfo *model.TableInfo
        - cache *tikv.RegionCache
        - wg *sync.WaitGroup
        - sampLocs <font color=blue>chan</font> *tikv.KeyLocation
        - rowCount uint64
        - sampCursor int32
        - sampTasks []*AnalyzeFastTask
        - scanTasks []*tikv.KeyLocation
        - collectors []*statistics.SampleCollector
        - randSeed int64
        - job *statistics.AnalyzeJob

        - getSampRegionsRowCount(bo *tikv.Backoffer, needRebuild *bool, err *error, sampTasks *[]*AnalyzeFastTask) 
        - getNextSampleKey(bo *tikv.Backoffer, startKey kv.Key) (kv.Key, error)
        - buildSampTask() (bool, error)
        - decodeValues(sValue []byte) (<font color=blue>map</font>[int64]types.Datum, error)
        - getValueByInfo(colInfo *model.ColumnInfo, values <font color=blue>map</font>[int64]types.Datum) (types.Datum, error)
        - updateCollectorSamples(sValue []byte, sKey kv.Key, samplePos int32, hasPKInfo int) error
        - handleBatchSeekResponse(kvMap <font color=blue>map</font>[string][]byte) error
        - handleScanIter(iter kv.Iterator) (int, error)
        - handleScanTasks(bo *tikv.Backoffer) (int, error)
        - handleSampTasks(bo *tikv.Backoffer, workID int, err *error) 
        - buildColumnStats(ID int64, collector *statistics.SampleCollector, tp *types.FieldType, rowCount int64) (*statistics.Histogram, *statistics.CMSketch, error)
        - buildIndexStats(idxInfo *model.IndexInfo, collector *statistics.SampleCollector, rowCount int64) (*statistics.Histogram, *statistics.CMSketch, error)
        - runTasks() ([]*statistics.Histogram, []*statistics.CMSketch, error)
        - buildStats() ([]*statistics.Histogram, []*statistics.CMSketch, error)

    }
    class AnalyzeFastTask << (S,Aquamarine) >> {
        + Location *tikv.KeyLocation
        + SampSize uint64
        + BeginOffset uint64
        + EndOffset uint64

    }
    class AnalyzeIndexExec << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - physicalTableID int64
        - idxInfo *model.IndexInfo
        - concurrency int
        - priority int
        - analyzePB *tipb.AnalyzeReq
        - result distsql.SelectResult
        - countNullRes distsql.SelectResult
        - opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64
        - job *statistics.AnalyzeJob

        - fetchAnalyzeResult(ranges []*ranger.Range, isNullRange bool) error
        - open(ranges []*ranger.Range, considerNull bool) error
        - buildStatsFromResult(result distsql.SelectResult, needCMS bool) (*statistics.Histogram, *statistics.CMSketch, error)
        - buildStats(ranges []*ranger.Range, considerNull bool) (*statistics.Histogram, *statistics.CMSketch, error)

    }
    class AnalyzeTestFastExec << (S,Aquamarine) >> {
        + Ctx sessionctx.Context
        + PhysicalTableID int64
        + PKInfo *model.ColumnInfo
        + ColsInfo []*model.ColumnInfo
        + IdxsInfo []*model.IndexInfo
        + Concurrency int
        + Collectors []*statistics.SampleCollector
        + TblInfo *model.TableInfo
        + Opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64

        + TestFastSample() error

    }
    class BRIEExec << (S,Aquamarine) >> {
        - backupCfg *task.BackupConfig
        - restoreCfg *task.RestoreConfig
        - info *brieTaskInfo

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class BatchPointGetExec << (S,Aquamarine) >> {
        - tblInfo *model.TableInfo
        - idxInfo *model.IndexInfo
        - handles []int64
        - physIDs []int64
        - partPos int
        - idxVals [][]types.Datum
        - startTS uint64
        - snapshotTS uint64
        - txn kv.Transaction
        - lock bool
        - waitTime int64
        - inited bool
        - values [][]byte
        - index int
        - rowDecoder *rowcodec.ChunkDecoder
        - keepOrder bool
        - desc bool
        - columns []*model.ColumnInfo
        - virtualColumnIndex []int
        - virtualColumnRetFieldTypes []*types.FieldType

        - buildVirtualColumnInfo() 
        - initialize(ctx context.Context) error
        - lockKeys(ctx context.Context, keys []kv.Key) error

        + Open( context.Context) error
        + Close() error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class CancelDDLJobsExec << (S,Aquamarine) >> {
        - cursor int
        - jobIDs []int64
        - errs []error

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class ChangeExec << (S,Aquamarine) >> {
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class CheckIndexRangeExec << (S,Aquamarine) >> {
        - table *model.TableInfo
        - index *model.IndexInfo
        - is infoschema.InfoSchema
        - startKey []types.Datum
        - handleRanges []ast.HandleRange
        - srcChunk *chunk.Chunk
        - result distsql.SelectResult
        - cols []*model.ColumnInfo

        - buildDAGPB() (*tipb.DAGRequest, error)
        - constructIndexScanPB() *tipb.Executor

        + Next(ctx context.Context, req *chunk.Chunk) error
        + Open(ctx context.Context) error
        + Close() error

    }
    class CheckTableExec << (S,Aquamarine) >> {
        - dbName string
        - table table.Table
        - indexInfos []*model.IndexInfo
        - srcs []*IndexLookUpExecutor
        - done bool
        - is infoschema.InfoSchema
        - exitCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - retCh <font color=blue>chan</font> error
        - checkIndex bool

        - checkTableIndexHandle(ctx context.Context, idxInfo *model.IndexInfo) error
        - checkIndexHandle(ctx context.Context, src *IndexLookUpExecutor) error
        - handlePanic(r <font color=blue>interface</font>{}) 
        - checkTableRecord(idxOffset int) error

        + Open(ctx context.Context) error
        + Close() error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class ChecksumTableExec << (S,Aquamarine) >> {
        - tables <font color=blue>map</font>[int64]*checksumContext
        - done bool

        - buildTasks() ([]*checksumTask, error)
        - handleResult(result *checksumResult) 
        - checksumWorker(taskCh <font color=blue>chan</font> *checksumTask, resultCh <font color=blue>chan</font> *checksumResult) 
        - handleChecksumRequest(req *kv.Request) (*tipb.ChecksumResponse, error)

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class CleanupIndexExec << (S,Aquamarine) >> {
        - done bool
        - removeCnt uint64
        - index table.Index
        - table table.Table
        - physicalID int64
        - idxCols []*model.ColumnInfo
        - idxColFieldTypes []*types.FieldType
        - idxChunk *chunk.Chunk
        - idxValues <font color=blue>map</font>[int64][][]types.Datum
        - batchSize uint64
        - batchKeys []kv.Key
        - idxValsBufs [][]types.Datum
        - lastIdxKey []byte
        - scanRowCnt uint64

        - getIdxColTypes() []*types.FieldType
        - batchGetRecord(txn kv.Transaction) (<font color=blue>map</font>[string][]byte, error)
        - deleteDanglingIdx(txn kv.Transaction, values <font color=blue>map</font>[string][]byte) error
        - fetchIndex(ctx context.Context, txn kv.Transaction) error
        - cleanTableIndex(ctx context.Context) error
        - buildIndexScan(ctx context.Context, txn kv.Transaction) (distsql.SelectResult, error)
        - init() error
        - buildIdxDAGPB(txn kv.Transaction) (*tipb.DAGRequest, error)
        - constructIndexScanPB() *tipb.Executor
        - constructLimitPB() *tipb.Executor

        + Next(ctx context.Context, req *chunk.Chunk) error
        + Open(ctx context.Context) error
        + Close() error

    }
    interface Closeable  {
        + Close() error

    }
    class CommitTask << (S,Aquamarine) >> {
        - cnt uint64
        - rows [][]types.Datum

    }
    class Compiler << (S,Aquamarine) >> {
        + Ctx sessionctx.Context

        + Compile(ctx context.Context, stmtNode ast.StmtNode) (*ExecStmt, error)

    }
    class CoprocessorDAGHandler << (S,Aquamarine) >> {
        - sctx sessionctx.Context
        - dagReq *tipb.DAGRequest

        - buildResponseAndSendToStream(chk *chunk.Chunk, tps []*types.FieldType, stream tikvpb.Tikv_CoprocessorStreamServer) error
        - buildDAGExecutor(req *coprocessor.Request) (Executor, error)
        - buildChunk(chk *chunk.Chunk, tps []*types.FieldType) ([]tipb.Chunk, error)
        - buildUnaryResponse(chunks []tipb.Chunk) *coprocessor.Response
        - buildStreamResponse(chunk *tipb.Chunk) *coprocessor.Response
        - buildErrorResponse(err error) *coprocessor.Response
        - encodeChunk(chk *chunk.Chunk, colTypes []*types.FieldType) ([]tipb.Chunk, error)
        - encodeDefault(chk *chunk.Chunk, tps []*types.FieldType) ([]tipb.Chunk, error)
        - appendRow(chunks []tipb.Chunk, data []byte, rowCnt int) []tipb.Chunk

        + HandleRequest(ctx context.Context, req *coprocessor.Request) *coprocessor.Response
        + HandleStreamRequest(ctx context.Context, req *coprocessor.Request, stream tikvpb.Tikv_CoprocessorStreamServer) error

    }
    class DDLExec << (S,Aquamarine) >> {
        - stmt ast.StmtNode
        - is infoschema.InfoSchema
        - done bool

        - toErr(err error) error
        - executeTruncateTable(s *ast.TruncateTableStmt) error
        - executeRenameTable(s *ast.RenameTableStmt) error
        - executeCreateDatabase(s *ast.CreateDatabaseStmt) error
        - executeAlterDatabase(s *ast.AlterDatabaseStmt) error
        - executeCreateTable(s *ast.CreateTableStmt) error
        - executeCreateView(s *ast.CreateViewStmt) error
        - executeCreateIndex(s *ast.CreateIndexStmt) error
        - executeDropDatabase(s *ast.DropDatabaseStmt) error
        - executeDropTable(s *ast.DropTableStmt) error
        - executeDropView(s *ast.DropTableStmt) error
        - executeDropSequence(s *ast.DropSequenceStmt) error
        - dropTableObject(objects []*ast.TableName, obt objectType, ifExists bool) error
        - executeDropIndex(s *ast.DropIndexStmt) error
        - executeAlterTable(s *ast.AlterTableStmt) error
        - executeRecoverTable(s *ast.RecoverTableStmt) error
        - getTableAutoIDsFromSnapshot(job *model.Job) (int64, error)
        - getRecoverTableByJobID(s *ast.RecoverTableStmt, t *meta.Meta, dom *domain.Domain) (*model.Job, *model.TableInfo, error)
        - getRecoverTableByTableName(tableName *ast.TableName) (*model.Job, *model.TableInfo, error)
        - executeFlashbackTable(s *ast.FlashBackTableStmt) error
        - executeLockTables(s *ast.LockTablesStmt) error
        - executeUnlockTables(s *ast.UnlockTablesStmt) error
        - executeCleanupTableLock(s *ast.CleanupTableLockStmt) error
        - executeRepairTable(s *ast.RepairTableStmt) error
        - executeCreateSequence(s *ast.CreateSequenceStmt) error

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class DDLJobRetriever << (S,Aquamarine) >> {
        - runningJobs []*model.Job
        - historyJobIter *meta.LastJobIterator
        - cursor int
        - is infoschema.InfoSchema
        - activeRoles []*auth.RoleIdentity
        - cacheJobs []*model.Job

        - initial(txn kv.Transaction) error
        - appendJobToChunk(req *chunk.Chunk, job *model.Job, checker privilege.Manager) 

    }
    class DDLJobsReaderExec << (S,Aquamarine) >> {
        - cacheJobs []*model.Job
        - is infoschema.InfoSchema

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class DeallocateExec << (S,Aquamarine) >> {
        + Name string

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class DeleteExec << (S,Aquamarine) >> {
        - tblID2Table <font color=blue>map</font>[int64]table.Table
        - tblColPosInfos core.TblColPosInfoSlice
        - memTracker *memory.Tracker

        + IsMultiTable bool

        - deleteOneRow(tbl table.Table, handleIndex int, isExtraHandle bool, row []types.Datum) error
        - deleteSingleTableByChunk(ctx context.Context) error
        - composeTblRowMap(tblRowMap tableRowMapType, colPosInfos []core.TblColPosInfo, joinedRow []types.Datum) 
        - deleteMultiTablesByChunk(ctx context.Context) error
        - removeRowsInTblRowMap(tblRowMap tableRowMapType) error
        - removeRow(ctx sessionctx.Context, t table.Table, h int64, data []types.Datum) error

        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error
        + Open(ctx context.Context) error

    }
    class DirtyDB << (S,Aquamarine) >> {
        - tables <font color=blue>map</font>[int64]*DirtyTable

        + GetDirtyTable(tid int64) *DirtyTable

    }
    class DirtyTable << (S,Aquamarine) >> {
        - tid int64
        - addedRows <font color=blue>map</font>[int64]<font color=blue>struct</font>{}
        - deletedRows <font color=blue>map</font>[int64]<font color=blue>struct</font>{}

        + AddRow(handle int64) 
        + DeleteRow(handle int64) 
        + IsEmpty() bool

    }
    class ExecStmt << (S,Aquamarine) >> {
        - isPreparedStmt bool
        - isSelectForUpdate bool
        - retryCount uint

        + InfoSchema infoschema.InfoSchema
        + Plan core.Plan
        + Text string
        + StmtNode ast.StmtNode
        + Ctx sessionctx.Context
        + LowerPriority bool
        + OutputNames []*types.FieldName
        + PsStmt *core.CachedPrepareStmt

        - handleNoDelay(ctx context.Context, e Executor, isPessimistic bool) (bool, sqlexec.RecordSet, error)
        - handlePessimisticSelectForUpdate(ctx context.Context, e Executor) (sqlexec.RecordSet, error)
        - runPessimisticSelectForUpdate(ctx context.Context, e Executor) (sqlexec.RecordSet, error)
        - handleNoDelayExecutor(ctx context.Context, e Executor) (sqlexec.RecordSet, error)
        - handlePessimisticDML(ctx context.Context, e Executor) error
        - handlePessimisticLockError(ctx context.Context, err error) (Executor, error)
        - buildExecutor() (Executor, error)
        - logAudit() 

        + PointGet(ctx context.Context, is infoschema.InfoSchema) (*recordSet, error)
        + OriginText() string
        + IsPrepared() bool
        + IsReadOnly(vars *variable.SessionVars) bool
        + RebuildPlan(ctx context.Context) (int64, error)
        + Exec(ctx context.Context) (sqlexec.RecordSet, error)
        + CloseRecordSet(txnStartTS uint64, lastErr error) 
        + FinishExecuteStmt(txnTS uint64, succ bool, hasMoreResults bool) 
        + LogSlowQuery(txnTS uint64, succ bool, hasMoreResults bool) 
        + SummaryStmt(succ bool) 

    }
    class ExecuteExec << (S,Aquamarine) >> {
        - is infoschema.InfoSchema
        - name string
        - usingVars []expression.Expression
        - stmtExec Executor
        - stmt ast.StmtNode
        - plan core.Plan
        - id uint32
        - lowerPriority bool
        - outputNames []*types.FieldName

        + Next(ctx context.Context, req *chunk.Chunk) error
        + Build(b *executorBuilder) error

    }
    interface Executor  {
        - base() *baseExecutor

        + Open( context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error
        + Schema() *expression.Schema

    }
    class ExplainExec << (S,Aquamarine) >> {
        - explain *core.Explain
        - analyzeExec Executor
        - rows [][]string
        - cursor int

        - generateExplainInfo(ctx context.Context) ([][]string, error)

        + Open(ctx context.Context) error
        + Close() error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class GrantExec << (S,Aquamarine) >> {
        - is infoschema.InfoSchema
        - done bool

        + Privs []*ast.PrivElem
        + ObjectType ast.ObjectTypeType
        + Level *ast.GrantLevel
        + Users []*ast.UserSpec
        + TLSOptions []*ast.TLSOption
        + WithGrant bool

        - checkAndInitColumnPriv(user string, host string, cols []*ast.ColumnName, internalSession sessionctx.Context) error
        - grantGlobalPriv(ctx sessionctx.Context, user *ast.UserSpec) error
        - grantLevelPriv(priv *ast.PrivElem, user *ast.UserSpec, internalSession sessionctx.Context) error
        - grantGlobalLevel(priv *ast.PrivElem, user *ast.UserSpec, internalSession sessionctx.Context) error
        - grantDBLevel(priv *ast.PrivElem, user *ast.UserSpec, internalSession sessionctx.Context) error
        - grantTableLevel(priv *ast.PrivElem, user *ast.UserSpec, internalSession sessionctx.Context) error
        - grantColumnLevel(priv *ast.PrivElem, user *ast.UserSpec, internalSession sessionctx.Context) error

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class HashAggExec << (S,Aquamarine) >> {
        - sc *stmtctx.StatementContext
        - partialResultMap aggPartialResultMapper
        - groupSet set.StringSet
        - groupKeys []string
        - cursor4GroupKey int
        - groupKeyBuffer [][]byte
        - finishCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - finalOutputCh <font color=blue>chan</font> *AfFinalResult
        - partialOutputChs []<font color=blue>chan</font> *HashAggIntermData
        - inputCh <font color=blue>chan</font> *HashAggInput
        - partialInputChs []<font color=blue>chan</font> *chunk.Chunk
        - partialWorkers []HashAggPartialWorker
        - finalWorkers []HashAggFinalWorker
        - defaultVal *chunk.Chunk
        - childResult *chunk.Chunk
        - isChildReturnEmpty bool
        - isUnparallelExec bool
        - prepared bool
        - executed bool
        - memTracker *memory.Tracker

        + PartialAggFuncs []aggfuncs.AggFunc
        + FinalAggFuncs []aggfuncs.AggFunc
        + GroupByItems []expression.Expression

        - initForUnparallelExec() 
        - initForParallelExec(ctx sessionctx.Context) 
        - fetchChildData(ctx context.Context) 
        - waitPartialWorkerAndCloseOutputChs(waitGroup *sync.WaitGroup) 
        - waitFinalWorkerAndCloseFinalOutput(waitGroup *sync.WaitGroup) 
        - prepare4ParallelExec(ctx context.Context) 
        - parallelExec(ctx context.Context, chk *chunk.Chunk) error
        - unparallelExec(ctx context.Context, chk *chunk.Chunk) error
        - execute(ctx context.Context) error
        - getPartialResults(groupKey string) []aggfuncs.PartialResult

        + Close() error
        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class HashAggFinalWorker << (S,Aquamarine) >> {
        - rowBuffer []types.Datum
        - mutableRow chunk.MutRow
        - partialResultMap aggPartialResultMapper
        - groupSet set.StringSet
        - inputCh <font color=blue>chan</font> *HashAggIntermData
        - outputCh <font color=blue>chan</font> *AfFinalResult
        - finalResultHolderCh <font color=blue>chan</font> *chunk.Chunk
        - groupKeys [][]byte

        - getPartialInput() (*HashAggIntermData, bool)
        - consumeIntermData(sctx sessionctx.Context) error
        - getFinalResult(sctx sessionctx.Context) 
        - receiveFinalResultHolder() (*chunk.Chunk, bool)
        - run(ctx sessionctx.Context, waitGroup *sync.WaitGroup) 

    }
    class HashAggInput << (S,Aquamarine) >> {
        - chk *chunk.Chunk
        - giveBackCh <font color=blue>chan</font> *chunk.Chunk

    }
    class HashAggIntermData << (S,Aquamarine) >> {
        - groupKeys []string
        - cursor int
        - partialResultMap aggPartialResultMapper

        - getPartialResultBatch(sc *stmtctx.StatementContext, prs [][]aggfuncs.PartialResult, aggFuncs []aggfuncs.AggFunc, maxChunkSize int) ([][]aggfuncs.PartialResult, []string, bool)

    }
    class HashAggPartialWorker << (S,Aquamarine) >> {
        - inputCh <font color=blue>chan</font> *chunk.Chunk
        - outputChs []<font color=blue>chan</font> *HashAggIntermData
        - globalOutputCh <font color=blue>chan</font> *AfFinalResult
        - giveBackCh <font color=blue>chan</font> *HashAggInput
        - partialResultsMap aggPartialResultMapper
        - groupByItems []expression.Expression
        - groupKey [][]byte
        - chk *chunk.Chunk
        - memTracker *memory.Tracker

        - getChildInput() bool
        - run(ctx sessionctx.Context, waitGroup *sync.WaitGroup, finalConcurrency int) 
        - updatePartialResult(ctx sessionctx.Context, sc *stmtctx.StatementContext, chk *chunk.Chunk, finalConcurrency int) error
        - shuffleIntermData(sc *stmtctx.StatementContext, finalConcurrency int) 

    }
    class HashJoinExec << (S,Aquamarine) >> {
        - probeSideExec Executor
        - buildSideExec Executor
        - buildSideEstCount float64
        - outerFilter expression.CNFExprs
        - probeKeys []*expression.Column
        - buildKeys []*expression.Column
        - probeTypes []*types.FieldType
        - buildTypes []*types.FieldType
        - concurrency uint
        - rowContainer *hashRowContainer
        - buildFinished <font color=blue>chan</font> error
        - closeCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - joinType core.JoinType
        - requiredRows int64
        - joiners []joiner
        - probeChkResourceCh <font color=blue>chan</font> *probeChkResource
        - probeResultChs []<font color=blue>chan</font> *chunk.Chunk
        - joinChkResourceCh []<font color=blue>chan</font> *chunk.Chunk
        - joinResultCh <font color=blue>chan</font> *hashjoinWorkerResult
        - memTracker *memory.Tracker
        - diskTracker *disk.Tracker
        - outerMatchedStatus []*bitmap.ConcurrentBitmap
        - useOuterToBuild bool
        - prepared bool
        - isOuterJoin bool
        - joinWorkerWaitGroup sync.WaitGroup
        - finished atomic.Value

        - fetchProbeSideChunks(ctx context.Context) 
        - wait4BuildSide() (bool, error)
        - fetchBuildSideRows(ctx context.Context, chkCh <font color=blue>chan</font> *chunk.Chunk, doneCh <font color=blue>chan</font> <font color=blue>struct</font>{}) 
        - initializeForProbe() 
        - fetchAndProbeHashTable(ctx context.Context) 
        - handleProbeSideFetcherPanic(r <font color=blue>interface</font>{}) 
        - handleJoinWorkerPanic(r <font color=blue>interface</font>{}) 
        - handleUnmatchedRowsFromHashTable(workerID uint) 
        - waitJoinWorkersAndCloseResultChan() 
        - runJoinWorker(workerID uint, probeKeyColIdx []int) 
        - joinMatchedProbeSideRow2ChunkForOuterHashJoin(workerID uint, probeKey uint64, probeSideRow chunk.Row, hCtx *hashContext, joinResult *hashjoinWorkerResult) (bool, *hashjoinWorkerResult)
        - joinMatchedProbeSideRow2Chunk(workerID uint, probeKey uint64, probeSideRow chunk.Row, hCtx *hashContext, joinResult *hashjoinWorkerResult) (bool, *hashjoinWorkerResult)
        - getNewJoinResult(workerID uint) (bool, *hashjoinWorkerResult)
        - join2Chunk(workerID uint, probeSideChk *chunk.Chunk, hCtx *hashContext, joinResult *hashjoinWorkerResult, selected []bool) (bool, *hashjoinWorkerResult)
        - join2ChunkForOuterHashJoin(workerID uint, probeSideChk *chunk.Chunk, hCtx *hashContext, joinResult *hashjoinWorkerResult) (bool, *hashjoinWorkerResult)
        - handleFetchAndBuildHashTablePanic(r <font color=blue>interface</font>{}) 
        - fetchAndBuildHashTable(ctx context.Context) 
        - buildHashTableForList(buildSideResultCh <font color=blue>chan</font> *chunk.Chunk) error

        + Close() error
        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class IndexAdvice << (S,Aquamarine) >> {
    }
    class IndexAdviseExec << (S,Aquamarine) >> {
        - indexAdviseInfo *IndexAdviseInfo

        + IsLocal bool

        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error
        + Open(ctx context.Context) error

    }
    class IndexAdviseInfo << (S,Aquamarine) >> {
        + Path string
        + MaxMinutes uint64
        + MaxIndexNum *ast.MaxIndexNumClause
        + LinesInfo *ast.LinesClause
        + Ctx sessionctx.Context
        + StmtNodes [][]ast.StmtNode
        + Result *IndexAdvice

        - getStmtNodes(data []byte) error
        - prepareInfo(data []byte) error

        + GetIndexAdvice(ctx context.Context, data []byte) error

    }
    class IndexAdviseVarKeyType << (S,Aquamarine) >> {
        + String() string

    }
    class IndexLookUpExecutor << (S,Aquamarine) >> {
        - table table.Table
        - index *model.IndexInfo
        - ranges []*ranger.Range
        - dagPB *tipb.DAGRequest
        - startTS uint64
        - handleIdx int
        - tableRequest *tipb.DAGRequest
        - columns []*model.ColumnInfo
        - idxWorkerWg sync.WaitGroup
        - tblWorkerWg sync.WaitGroup
        - finished <font color=blue>chan</font> <font color=blue>struct</font>{}
        - resultCh <font color=blue>chan</font> *lookupTableTask
        - resultCurr *lookupTableTask
        - feedback *statistics.QueryFeedback
        - memTracker *memory.Tracker
        - kvRanges []kv.KeyRange
        - workerStarted bool
        - keepOrder bool
        - desc bool
        - indexStreaming bool
        - tableStreaming bool
        - corColInIdxSide bool
        - corColInTblSide bool
        - corColInAccess bool
        - idxPlans []core.PhysicalPlan
        - tblPlans []core.PhysicalPlan
        - idxCols []*expression.Column
        - colLens []int

        + PushedLimit *core.PushedDownLimit

        - open(ctx context.Context) error
        - startWorkers(ctx context.Context, initBatchSize int) error
        - startIndexWorker(ctx context.Context, kvRanges []kv.KeyRange, workCh <font color=blue>chan</font> *lookupTableTask, initBatchSize int) error
        - startTableWorker(ctx context.Context, workCh <font color=blue>chan</font> *lookupTableTask) 
        - buildTableReader(ctx context.Context, handles []int64) (Executor, error)
        - getResultTask() (*lookupTableTask, error)

        + Open(ctx context.Context) error
        + Close() error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class IndexLookUpJoin << (S,Aquamarine) >> {
        - resultCh <font color=blue>chan</font> *lookUpJoinTask
        - cancelFunc context.CancelFunc
        - workerWg *sync.WaitGroup
        - outerCtx outerCtx
        - innerCtx innerCtx
        - task *lookUpJoinTask
        - joinResult *chunk.Chunk
        - innerIter chunk.Iterator
        - joiner joiner
        - isOuterJoin bool
        - requiredRows int64
        - indexRanges []*ranger.Range
        - keyOff2IdxOff []int
        - innerPtrBytes [][]byte
        - lastColHelper *core.ColWithCmpFuncManager
        - memTracker *memory.Tracker

        - startWorkers(ctx context.Context) 
        - newOuterWorker(resultCh <font color=blue>chan</font> *lookUpJoinTask, innerCh <font color=blue>chan</font> *lookUpJoinTask) *outerWorker
        - newInnerWorker(taskCh <font color=blue>chan</font> *lookUpJoinTask) *innerWorker
        - getFinishedTask(ctx context.Context) (*lookUpJoinTask, error)
        - lookUpMatchedInners(task *lookUpJoinTask, rowPtr chunk.RowPtr) 

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error

    }
    class IndexLookUpMergeJoin << (S,Aquamarine) >> {
        - resultCh <font color=blue>chan</font> *lookUpMergeJoinTask
        - cancelFunc context.CancelFunc
        - workerWg *sync.WaitGroup
        - outerMergeCtx outerMergeCtx
        - innerMergeCtx innerMergeCtx
        - joiners []joiner
        - joinChkResourceCh []<font color=blue>chan</font> *chunk.Chunk
        - isOuterJoin bool
        - requiredRows int64
        - task *lookUpMergeJoinTask
        - indexRanges []*ranger.Range
        - keyOff2IdxOff []int
        - lastColHelper *core.ColWithCmpFuncManager
        - memTracker *memory.Tracker

        - startWorkers(ctx context.Context) 
        - newOuterWorker(resultCh <font color=blue>chan</font> *lookUpMergeJoinTask, innerCh <font color=blue>chan</font> *lookUpMergeJoinTask) *outerMergeWorker
        - newInnerMergeWorker(taskCh <font color=blue>chan</font> *lookUpMergeJoinTask, workID int) *innerMergeWorker
        - getFinishedTask(ctx context.Context) 

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error

    }
    class IndexMergeReaderExecutor << (S,Aquamarine) >> {
        - table table.Table
        - indexes []*model.IndexInfo
        - descs []bool
        - ranges [][]*ranger.Range
        - dagPBs []*tipb.DAGRequest
        - startTS uint64
        - tableRequest *tipb.DAGRequest
        - columns []*model.ColumnInfo
        - partialStreamings []bool
        - tableStreaming bool
        - tblWorkerWg sync.WaitGroup
        - processWokerWg sync.WaitGroup
        - finished <font color=blue>chan</font> <font color=blue>struct</font>{}
        - workerStarted bool
        - keyRanges [][]kv.KeyRange
        - resultCh <font color=blue>chan</font> *lookupTableTask
        - resultCurr *lookupTableTask
        - feedbacks []*statistics.QueryFeedback
        - memTracker *memory.Tracker
        - corColInIdxSide bool
        - partialPlans [][]core.PhysicalPlan
        - corColInTblSide bool
        - tblPlans []core.PhysicalPlan
        - corColInAccess bool
        - idxCols [][]*expression.Column
        - colLens [][]int

        - startWorkers(ctx context.Context) error
        - waitPartialWorkersAndCloseFetchChan(partialWorkerWg *sync.WaitGroup, fetchCh <font color=blue>chan</font> *lookupTableTask) 
        - startIndexMergeProcessWorker(ctx context.Context, workCh <font color=blue>chan</font> *lookupTableTask, fetch <font color=blue>chan</font> *lookupTableTask) 
        - startPartialIndexWorker(ctx context.Context, exitCh <font color=blue>chan</font> <font color=blue>struct</font>{}, fetchCh <font color=blue>chan</font> *lookupTableTask, workID int, partialWorkerWg *sync.WaitGroup, keyRange []kv.KeyRange) error
        - buildPartialTableReader(ctx context.Context, workID int) Executor
        - startPartialTableWorker(ctx context.Context, exitCh <font color=blue>chan</font> <font color=blue>struct</font>{}, fetchCh <font color=blue>chan</font> *lookupTableTask, workID int, partialWorkerWg *sync.WaitGroup) error
        - startIndexMergeTableScanWorker(ctx context.Context, workCh <font color=blue>chan</font> *lookupTableTask) 
        - buildFinalTableReader(ctx context.Context, handles []int64) (Executor, error)
        - getResultTask() (*lookupTableTask, error)
        - handleHandlesFetcherPanic(ctx context.Context, resultCh <font color=blue>chan</font> *lookupTableTask, worker string) <font color=blue>func</font>(<font color=blue>interface</font>{}) 

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error

    }
    class IndexNestedLoopHashJoin << (S,Aquamarine) >> {
        - resultCh <font color=blue>chan</font> *indexHashJoinResult
        - joinChkResourceCh []<font color=blue>chan</font> *chunk.Chunk
        - joiners []joiner
        - keepOuterOrder bool
        - curTask *indexHashJoinTask
        - taskCh <font color=blue>chan</font> *indexHashJoinTask

        - startWorkers(ctx context.Context) 
        - finishJoinWorkers(r <font color=blue>interface</font>{}) 
        - wait4JoinWorkers() 
        - runInOrder(ctx context.Context, req *chunk.Chunk) error
        - isDryUpTasks(ctx context.Context) bool
        - newOuterWorker(innerCh <font color=blue>chan</font> *indexHashJoinTask) *indexHashJoinOuterWorker
        - newInnerWorker(taskCh <font color=blue>chan</font> *indexHashJoinTask, workerID int) *indexHashJoinInnerWorker

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error

    }
    class IndexReaderExecutor << (S,Aquamarine) >> {
        - table table.Table
        - index *model.IndexInfo
        - physicalTableID int64
        - ranges []*ranger.Range
        - kvRanges []kv.KeyRange
        - dagPB *tipb.DAGRequest
        - startTS uint64
        - result distsql.SelectResult
        - columns []*model.ColumnInfo
        - outputColumns []*expression.Column
        - feedback *statistics.QueryFeedback
        - streaming bool
        - keepOrder bool
        - desc bool
        - corColInFilter bool
        - corColInAccess bool
        - idxCols []*expression.Column
        - colLens []int
        - plans []core.PhysicalPlan
        - memTracker *memory.Tracker

        - open(ctx context.Context, kvRanges []kv.KeyRange) error

        + Close() error
        + Next(ctx context.Context, req *chunk.Chunk) error
        + Open(ctx context.Context) error

    }
    class InsertExec << (S,Aquamarine) >> {
        - evalBuffer4Dup chunk.MutRow
        - curInsertVals chunk.MutRow
        - row4Update []types.Datum

        + OnDuplicate []*expression.Assignment
        + Priority errno.PriorityEnum

        - exec(ctx context.Context, rows [][]types.Datum) error
        - updateDupRow(ctx context.Context, txn kv.Transaction, row toBeCheckedRow, handle int64, onDuplicate []*expression.Assignment) error
        - batchUpdateDupRows(ctx context.Context, newRows [][]types.Datum) error
        - initEvalBuffer4Dup() 
        - doDupRowUpdate(ctx context.Context, handle int64, oldRow []types.Datum, newRow []types.Datum, cols []*expression.Assignment) ([]types.Datum, bool, int64, error)
        - setMessage() 

        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error
        + Open(ctx context.Context) error

    }
    class InsertValues << (S,Aquamarine) >> {
        - rowCount uint64
        - curBatchCnt uint64
        - maxRowsInBatch uint64
        - lastInsertID uint64
        - insertColumns []*table.Column
        - colDefaultVals []defaultVal
        - evalBuffer chunk.MutRow
        - evalBufferTypes []*types.FieldType
        - allAssignmentsAreConstant bool
        - hasRefCols bool
        - hasExtraHandle bool
        - lazyFillAutoID bool
        - memTracker *memory.Tracker

        + SelectExec Executor
        + Table table.Table
        + Columns []*ast.ColumnName
        + Lists [][]expression.Expression
        + SetList []*expression.Assignment
        + GenExprs []expression.Expression

        - insertCommon() *InsertValues
        - exec(_ context.Context, _ [][]types.Datum) error
        - initInsertColumns() error
        - initEvalBuffer() 
        - lazilyInitColDefaultValBuf() bool
        - processSetList() error
        - handleErr(col *table.Column, val *types.Datum, rowIdx int, err error) error
        - evalRow(ctx context.Context, list []expression.Expression, rowIdx int) ([]types.Datum, error)
        - fastEvalRow(ctx context.Context, list []expression.Expression, rowIdx int) ([]types.Datum, error)
        - setValueForRefColumn(row []types.Datum, hasValue []bool) error
        - doBatchInsert(ctx context.Context) error
        - getRow(ctx context.Context, vals []types.Datum) ([]types.Datum, error)
        - getColDefaultValue(idx int, col *table.Column) (types.Datum, error)
        - fillColValue(ctx context.Context, datum types.Datum, idx int, column *table.Column, hasValue bool) (types.Datum, error)
        - fillRow(ctx context.Context, row []types.Datum, hasValue []bool) ([]types.Datum, error)
        - isAutoNull(ctx context.Context, d types.Datum, col *table.Column) bool
        - hasAutoIncrementColumn() (int, bool)
        - lazyAdjustAutoIncrementDatumInRetry(ctx context.Context, rows [][]types.Datum, colIdx int) ([][]types.Datum, error)
        - lazyAdjustAutoIncrementDatum(ctx context.Context, rows [][]types.Datum) ([][]types.Datum, error)
        - adjustAutoIncrementDatum(ctx context.Context, d types.Datum, hasValue bool, c *table.Column) (types.Datum, error)
        - adjustAutoRandomDatum(ctx context.Context, d types.Datum, hasValue bool, c *table.Column) (types.Datum, error)
        - allocAutoRandomID(fieldType *types.FieldType) (int64, error)
        - rebaseAutoRandomID(recordID int64, fieldType *types.FieldType) error
        - handleWarning(err error) 
        - batchCheckAndInsert(ctx context.Context, rows [][]types.Datum, addRecord <font color=blue>func</font>(context.Context, []types.Datum) (int64, error)) error
        - addRecord(ctx context.Context, row []types.Datum) (int64, error)
        - addRecordWithAutoIDHint(ctx context.Context, row []types.Datum, reserveAutoIDCount int) (int64, error)

    }
    class LimitExec << (S,Aquamarine) >> {
        - begin uint64
        - end uint64
        - cursor uint64
        - meetFirstBatch bool
        - childResult *chunk.Chunk

        - adjustRequiredRows(chk *chunk.Chunk) *chunk.Chunk

        + Next(ctx context.Context, req *chunk.Chunk) error
        + Open(ctx context.Context) error
        + Close() error

    }
    class LoadDataExec << (S,Aquamarine) >> {
        - loadDataInfo *LoadDataInfo

        + IsLocal bool
        + OnDuplicate ast.OnDuplicateKeyHandlingType

        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error
        + Open(ctx context.Context) error

    }
    class LoadDataInfo << (S,Aquamarine) >> {
        - row []types.Datum
        - rows [][]types.Datum
        - commitTaskQueue <font color=blue>chan</font> CommitTask

        + Path string
        + Table table.Table
        + FieldsInfo *ast.FieldsClause
        + LinesInfo *ast.LinesClause
        + IgnoreLines uint64
        + Ctx sessionctx.Context
        + Drained bool
        + StopCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        + QuitCh <font color=blue>chan</font> <font color=blue>struct</font>{}

        - getValidData(prevData []byte, curData []byte) ([]byte, []byte)
        - getLine(prevData []byte, curData []byte) ([]byte, []byte, bool)
        - colsToRow(ctx context.Context, cols []field) []types.Datum
        - addRecordLD(ctx context.Context, row []types.Datum) (int64, error)
        - getFieldsFromLine(line []byte) ([]field, error)

        + GetRows() [][]types.Datum
        + GetCurBatchCnt() uint64
        + CloseTaskQueue() 
        + InitQueues() 
        + StartStopWatcher() 
        + ForceQuit() 
        + MakeCommitTask() CommitTask
        + EnqOneTask(ctx context.Context) error
        + CommitOneTask(ctx context.Context, task CommitTask) error
        + CommitWork(ctx context.Context) error
        + SetMaxRowsInBatch(limit uint64) 
        + InsertData(ctx context.Context, prevData []byte, curData []byte) ([]byte, bool, error)
        + CheckAndInsertOneBatch(ctx context.Context, rows [][]types.Datum, cnt uint64) error
        + SetMessage() 

    }
    class LoadStatsExec << (S,Aquamarine) >> {
        - info *LoadStatsInfo

        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error
        + Open(ctx context.Context) error

    }
    class LoadStatsInfo << (S,Aquamarine) >> {
        + Path string
        + Ctx sessionctx.Context

        + Update(data []byte) error

    }
    class MaxOneRowExec << (S,Aquamarine) >> {
        - evaluated bool

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class MemTableReaderExec << (S,Aquamarine) >> {
        - table *model.TableInfo
        - retriever memTableRetriever
        - cacheRetrieved bool

        - isInspectionCacheableTable(tblName string) bool

        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error

    }
    class MergeJoinExec << (S,Aquamarine) >> {
        - stmtCtx *stmtctx.StatementContext
        - compareFuncs []expression.CompareFunc
        - joiner joiner
        - isOuterJoin bool
        - desc bool
        - innerTable *mergeJoinTable
        - outerTable *mergeJoinTable
        - hasMatch bool
        - hasNull bool
        - memTracker *memory.Tracker
        - diskTracker *disk.Tracker

        - compare(outerRow chunk.Row, innerRow chunk.Row) (int, error)

        + Close() error
        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class MetricRetriever << (S,Aquamarine) >> {
        - table *model.TableInfo
        - tblDef *infoschema.MetricTableDef
        - extractor *core.MetricTableExtractor
        - timeRange core.QueryTimeRange
        - retrieved bool

        - retrieve(ctx context.Context, sctx sessionctx.Context) ([][]types.Datum, error)
        - queryMetric(ctx context.Context, sctx sessionctx.Context, queryRange v1.Range, quantile float64) (model.Value, error)
        - getQueryRange(sctx sessionctx.Context) promQLQueryRange
        - genRows(value model.Value, quantile float64) [][]types.Datum
        - genRecord(metric model.Metric, pair model.SamplePair, quantile float64) []types.Datum

    }
    class MetricsSummaryByLabelRetriever << (S,Aquamarine) >> {
        - table *model.TableInfo
        - extractor *core.MetricSummaryTableExtractor
        - timeRange core.QueryTimeRange
        - retrieved bool

        - retrieve(ctx context.Context, sctx sessionctx.Context) ([][]types.Datum, error)

    }
    class MetricsSummaryRetriever << (S,Aquamarine) >> {
        - table *model.TableInfo
        - extractor *core.MetricSummaryTableExtractor
        - timeRange core.QueryTimeRange
        - retrieved bool

        - retrieve(_ context.Context, sctx sessionctx.Context) ([][]types.Datum, error)

    }
    interface MockPhysicalPlan  {
        + GetExecutor() Executor

    }
    class NestedLoopApplyExec << (S,Aquamarine) >> {
        - innerRows []chunk.Row
        - cursor int
        - innerExec Executor
        - outerExec Executor
        - innerFilter expression.CNFExprs
        - outerFilter expression.CNFExprs
        - joiner joiner
        - outerSchema []*expression.CorrelatedColumn
        - outerChunk *chunk.Chunk
        - outerChunkCursor int
        - outerSelected []bool
        - innerList *chunk.List
        - innerChunk *chunk.Chunk
        - innerSelected []bool
        - innerIter chunk.Iterator
        - outerRow *chunk.Row
        - hasMatch bool
        - hasNull bool
        - outer bool
        - memTracker *memory.Tracker

        - fetchSelectedOuterRow(ctx context.Context, chk *chunk.Chunk) (*chunk.Row, error)
        - fetchAllInners(ctx context.Context) error

        + Close() error
        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class PessimisticLockCacheGetter << (S,Aquamarine) >> {
        - txnCtx *variable.TransactionContext

        + Get(_ context.Context, key kv.Key) ([]byte, error)

    }
    class PointGetExecutor << (S,Aquamarine) >> {
        - tblInfo *model.TableInfo
        - handle int64
        - idxInfo *model.IndexInfo
        - partInfo *model.PartitionDefinition
        - idxKey kv.Key
        - handleVal []byte
        - idxVals []types.Datum
        - startTS uint64
        - txn kv.Transaction
        - snapshot kv.Snapshot
        - done bool
        - lock bool
        - lockWaitTime int64
        - rowDecoder *rowcodec.ChunkDecoder
        - columns []*model.ColumnInfo
        - virtualColumnIndex []int
        - virtualColumnRetFieldTypes []*types.FieldType

        - buildVirtualColumnInfo() 
        - getAndLock(ctx context.Context, key kv.Key) ([]byte, error)
        - lockKeyIfNeeded(ctx context.Context, key []byte) error
        - get(ctx context.Context, key kv.Key) ([]byte, error)

        + Init(p *core.PointGetPlan, startTs uint64) 
        + Open( context.Context) error
        + Close() error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class PrepareExec << (S,Aquamarine) >> {
        - is infoschema.InfoSchema
        - name string
        - sqlText string

        + ID uint32
        + ParamCount int
        + Fields []*ast.ResultField

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class ProjectionExec << (S,Aquamarine) >> {
        - evaluatorSuit *expression.EvaluatorSuite
        - finishCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - outputCh <font color=blue>chan</font> *projectionOutput
        - fetcher projectionInputFetcher
        - numWorkers int64
        - workers []*projectionWorker
        - childResult *chunk.Chunk
        - parentReqRows int64
        - memTracker *memory.Tracker
        - wg sync.WaitGroup
        - calculateNoDelay bool
        - prepared bool

        - open(ctx context.Context) error
        - isUnparallelExec() bool
        - unParallelExecute(ctx context.Context, chk *chunk.Chunk) error
        - parallelExecute(ctx context.Context, chk *chunk.Chunk) error
        - prepare(ctx context.Context) 
        - drainInputCh(ch <font color=blue>chan</font> *projectionInput) 
        - drainOutputCh(ch <font color=blue>chan</font> *projectionOutput) 

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error

    }
    class RecoverIndexExec << (S,Aquamarine) >> {
        - done bool
        - index table.Index
        - table table.Table
        - physicalID int64
        - batchSize int
        - columns []*model.ColumnInfo
        - colFieldTypes []*types.FieldType
        - srcChunk *chunk.Chunk
        - recoverRows []recoverRows
        - idxValsBufs [][]types.Datum
        - idxKeyBufs [][]byte
        - batchKeys []kv.Key

        - columnsTypes() []*types.FieldType
        - constructTableScanPB(pbColumnInfos []*tipb.ColumnInfo) *tipb.Executor
        - constructLimitPB(count uint64) *tipb.Executor
        - buildDAGPB(txn kv.Transaction, limitCnt uint64) (*tipb.DAGRequest, error)
        - buildTableScan(ctx context.Context, txn kv.Transaction, startHandle int64, limitCnt uint64) (distsql.SelectResult, error)
        - backfillIndex(ctx context.Context) (int64, int64, error)
        - fetchRecoverRows(ctx context.Context, srcResult distsql.SelectResult, result *backfillResult) ([]recoverRows, error)
        - batchMarkDup(txn kv.Transaction, rows []recoverRows) error
        - backfillIndexInTxn(ctx context.Context, txn kv.Transaction, startHandle int64) (backfillResult, error)

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class ReloadExprPushdownBlacklistExec << (S,Aquamarine) >> {
        + Next(ctx context.Context, _ *chunk.Chunk) error

    }
    class ReloadOptRuleBlacklistExec << (S,Aquamarine) >> {
        + Next(ctx context.Context, _ *chunk.Chunk) error

    }
    class ReplaceExec << (S,Aquamarine) >> {
        + Priority int

        - removeRow(ctx context.Context, txn kv.Transaction, handle int64, r toBeCheckedRow) (bool, error)
        - replaceRow(ctx context.Context, r toBeCheckedRow) error
        - removeIndexRow(ctx context.Context, txn kv.Transaction, r toBeCheckedRow) (bool, bool, error)
        - exec(ctx context.Context, newRows [][]types.Datum) error
        - setMessage() 

        + Close() error
        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class RevokeExec << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - is infoschema.InfoSchema
        - done bool

        + Privs []*ast.PrivElem
        + ObjectType ast.ObjectTypeType
        + Level *ast.GrantLevel
        + Users []*ast.UserSpec

        - revokeOneUser(internalSession sessionctx.Context, user string, host string) error
        - revokePriv(internalSession sessionctx.Context, priv *ast.PrivElem, user string, host string) error
        - revokeGlobalPriv(internalSession sessionctx.Context, priv *ast.PrivElem, user string, host string) error
        - revokeDBPriv(internalSession sessionctx.Context, priv *ast.PrivElem, userName string, host string) error
        - revokeTablePriv(internalSession sessionctx.Context, priv *ast.PrivElem, user string, host string) error
        - revokeColumnPriv(internalSession sessionctx.Context, priv *ast.PrivElem, user string, host string) error

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class SQLBindExec << (S,Aquamarine) >> {
        - sqlBindOp core.SQLBindOpType
        - normdOrigSQL string
        - bindSQL string
        - charset string
        - collation string
        - db string
        - isGlobal bool
        - bindAst ast.StmtNode

        - dropSQLBind() error
        - createSQLBind() error
        - flushBindings() error
        - captureBindings() 
        - evolveBindings() error
        - reloadBindings() error

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class SelectIntoExec << (S,Aquamarine) >> {
        - intoOpt *ast.SelectIntoOption
        - lineBuf []byte
        - realBuf []byte
        - writer *bufio.Writer
        - dstFile *os.File
        - chk *chunk.Chunk
        - started bool

        - considerEncloseOpt(et types.EvalType) bool
        - dumpToOutfile() error

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error

    }
    class SelectLockExec << (S,Aquamarine) >> {
        - keys []kv.Key
        - tblID2Handle <font color=blue>map</font>[int64][]*expression.Column
        - partitionedTable []table.PartitionedTable
        - tblID2Table <font color=blue>map</font>[int64]table.PartitionedTable

        + Lock ast.SelectLockType

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class SelectionExec << (S,Aquamarine) >> {
        - batched bool
        - filters []expression.Expression
        - selected []bool
        - inputIter *chunk.Iterator4Chunk
        - inputRow chunk.Row
        - childResult *chunk.Chunk
        - memTracker *memory.Tracker

        - open(ctx context.Context) error
        - unBatchedNext(ctx context.Context, chk *chunk.Chunk) error

        + Open(ctx context.Context) error
        + Close() error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class SetConfigExec << (S,Aquamarine) >> {
        - p *core.SetConfig
        - jsonBody string

        - doRequest(url string) error

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class SetExecutor << (S,Aquamarine) >> {
        - vars []*expression.VarAssignment
        - done bool

        - getSynonyms(varName string) []string
        - setSysVariable(name string, v *expression.VarAssignment) error
        - setCharset(cs string, co string) error
        - getVarValue(v *expression.VarAssignment, sysVar *variable.SysVar) (types.Datum, error)
        - loadSnapshotInfoSchemaIfNeeded(name string) error

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class ShowDDLExec << (S,Aquamarine) >> {
        - ddlOwnerID string
        - selfID string
        - ddlInfo *admin.DDLInfo
        - done bool

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class ShowDDLJobQueriesExec << (S,Aquamarine) >> {
        - cursor int
        - jobs []*model.Job
        - jobIDs []int64

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class ShowDDLJobsExec << (S,Aquamarine) >> {
        - jobNumber int
        - is infoschema.InfoSchema
        - done bool

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class ShowExec << (S,Aquamarine) >> {
        - is infoschema.InfoSchema
        - result *chunk.Chunk
        - cursor int

        + Tp ast.ShowStmtType
        + DBName model.CIStr
        + Table *ast.TableName
        + Column *ast.ColumnName
        + IndexName model.CIStr
        + Flag int
        + Roles []*auth.RoleIdentity
        + User *auth.UserIdentity
        + Full bool
        + IfNotExists bool
        + GlobalScope bool
        + Extended bool

        - fetchAll(ctx context.Context) error
        - fetchShowBind() error
        - fetchShowEngines() error
        - fetchShowDatabases() error
        - fetchShowProcessList() error
        - fetchShowOpenTables() error
        - fetchShowTables() error
        - fetchShowTableStatus() error
        - fetchShowColumns(ctx context.Context) error
        - fetchShowIndex() error
        - fetchShowCharset() error
        - fetchShowMasterStatus() error
        - fetchShowVariables() error
        - fetchShowStatus() error
        - fetchShowCreateSequence() error
        - fetchShowClusterConfigs(ctx context.Context) error
        - fetchShowCreateTable() error
        - fetchShowCreateView() error
        - fetchShowCreateDatabase() error
        - fetchShowCollation() error
        - fetchShowCreateUser() error
        - fetchShowGrants() error
        - fetchShowPrivileges() error
        - fetchShowTriggers() error
        - fetchShowProcedureStatus() error
        - fetchShowPlugins() error
        - fetchShowWarnings(errOnly bool) error
        - fetchShowPumpOrDrainerStatus(kind string) error
        - getTable() (table.Table, error)
        - dbAccessDenied() error
        - tableAccessDenied(access string, table string) error
        - appendRow(row []<font color=blue>interface</font>{}) 
        - fetchShowTableRegions() error
        - fillRegionsToChunk(regions []regionMeta) 
        - fetchShowBuiltins() error
        - fetchShowStatsMeta() error
        - appendTableForStatsMeta(dbName string, tblName string, partitionName string, statsTbl *statistics.Table) 
        - fetchShowStatsHistogram() error
        - appendTableForStatsHistograms(dbName string, tblName string, partitionName string, statsTbl *statistics.Table) 
        - histogramToRow(dbName string, tblName string, partitionName string, colName string, isIndex int, hist statistics.Histogram, avgColSize float64) 
        - versionToTime(version uint64) types.Time
        - fetchShowStatsBuckets() error
        - appendTableForStatsBuckets(dbName string, tblName string, partitionName string, statsTbl *statistics.Table) error
        - bucketsToRows(dbName string, tblName string, partitionName string, colName string, numOfCols int, hist statistics.Histogram) error
        - fetchShowStatsHealthy() 
        - appendTableForStatsHealthy(dbName string, tblName string, partitionName string, statsTbl *statistics.Table) 
        - fetchShowAnalyzeStatus() 
        - fetchShowBRIE(kind ast.BRIEKind) error

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class ShowNextRowIDExec << (S,Aquamarine) >> {
        - tblName *ast.TableName
        - done bool

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class ShowSlowExec << (S,Aquamarine) >> {
        - result []*domain.SlowQueryInfo
        - cursor int

        + ShowSlow *ast.ShowSlow

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class ShuffleExec << (S,Aquamarine) >> {
        - concurrency int
        - workers []*shuffleWorker
        - prepared bool
        - executed bool
        - splitter partitionSplitter
        - dataSource Executor
        - finishCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - outputCh <font color=blue>chan</font> *shuffleOutput

        - prepare4ParallelExec(ctx context.Context) 
        - waitWorkerAndCloseOutput(waitGroup *sync.WaitGroup) 
        - fetchDataAndSplit(ctx context.Context) 

        + Open(ctx context.Context) error
        + Close() error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class SimpleExec << (S,Aquamarine) >> {
        - done bool
        - is infoschema.InfoSchema

        + Statement ast.StmtNode

        - setDefaultRoleNone(s *ast.SetDefaultRoleStmt) error
        - setDefaultRoleRegular(s *ast.SetDefaultRoleStmt) error
        - setDefaultRoleAll(s *ast.SetDefaultRoleStmt) error
        - setDefaultRoleForCurrentUser(s *ast.SetDefaultRoleStmt) error
        - executeSetDefaultRole(s *ast.SetDefaultRoleStmt) error
        - setRoleRegular(s *ast.SetRoleStmt) error
        - setRoleAll(s *ast.SetRoleStmt) error
        - setRoleAllExcept(s *ast.SetRoleStmt) error
        - setRoleDefault(s *ast.SetRoleStmt) error
        - setRoleNone(s *ast.SetRoleStmt) error
        - executeSetRole(s *ast.SetRoleStmt) error
        - dbAccessDenied(dbname string) error
        - executeUse(s *ast.UseStmt) error
        - executeBegin(ctx context.Context, s *ast.BeginStmt) error
        - executeRevokeRole(s *ast.RevokeRoleStmt) error
        - executeCommit(s *ast.CommitStmt) 
        - executeRollback(s *ast.RollbackStmt) error
        - executeCreateUser(ctx context.Context, s *ast.CreateUserStmt) error
        - executeAlterUser(s *ast.AlterUserStmt) error
        - executeGrantRole(s *ast.GrantRoleStmt) error
        - executeDropUser(s *ast.DropUserStmt) error
        - executeSetPwd(s *ast.SetPwdStmt) error
        - executeKillStmt(s *ast.KillStmt) error
        - executeFlush(s *ast.FlushStmt) error
        - executeAlterInstance(s *ast.AlterInstanceStmt) error
        - executeDropStats(s *ast.DropStatsStmt) error
        - autoNewTxn() bool
        - executeShutdown(s *ast.ShutdownStmt) error

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class SortExec << (S,Aquamarine) >> {
        - fetched bool
        - schema *expression.Schema
        - keyExprs []expression.Expression
        - keyTypes []*types.FieldType
        - keyColumns []int
        - keyCmpFuncs []chunk.CompareFunc
        - rowChunks *chunk.SortedRowContainer
        - memTracker *memory.Tracker
        - diskTracker *disk.Tracker
        - partitionList []*chunk.SortedRowContainer
        - multiWayMerge *multiWayMerge
        - spillAction *chunk.SortAndSpillDiskAction

        + ByItems []*util.ByItems
        + Idx int

        - externalSorting(req *chunk.Chunk) error
        - fetchRowChunks(ctx context.Context) error
        - initCompareFuncs() 
        - buildKeyColumns() 
        - lessRow(rowI chunk.Row, rowJ chunk.Row) bool

        + Close() error
        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class SplitIndexRegionExec << (S,Aquamarine) >> {
        - tableInfo *model.TableInfo
        - partitionNames []model.CIStr
        - indexInfo *model.IndexInfo
        - lower []types.Datum
        - upper []types.Datum
        - num int
        - valueLists [][]types.Datum
        - splitIdxKeys [][]byte
        - done bool

        - splitIndexRegion(ctx context.Context) error
        - getSplitIdxKeys() ([][]byte, error)
        - getSplitIdxKeysFromValueList() ([][]byte, error)
        - getSplitIdxPhysicalKeysFromValueList(physicalID int64, keys [][]byte) ([][]byte, error)
        - getSplitIdxPhysicalStartAndOtherIdxKeys(physicalID int64, keys [][]byte) [][]byte
        - getSplitIdxKeysFromBound() ([][]byte, error)
        - getSplitIdxPhysicalKeysFromBound(physicalID int64, keys [][]byte) ([][]byte, error)

        + Open(ctx context.Context) error
        + Next(ctx context.Context, chk *chunk.Chunk) error

    }
    class SplitTableRegionExec << (S,Aquamarine) >> {
        - tableInfo *model.TableInfo
        - partitionNames []model.CIStr
        - lower types.Datum
        - upper types.Datum
        - num int
        - valueLists [][]types.Datum
        - splitKeys [][]byte
        - done bool

        - splitTableRegion(ctx context.Context) error
        - getSplitTableKeys() ([][]byte, error)
        - getSplitTableKeysFromValueList() ([][]byte, error)
        - getSplitTablePhysicalKeysFromValueList(physicalID int64, keys [][]byte) [][]byte
        - getSplitTableKeysFromBound() ([][]byte, error)
        - calculateBoundValue() (int64, int64, error)
        - getSplitTablePhysicalKeysFromBound(physicalID int64, low int64, step int64, keys [][]byte) [][]byte

        + Open(ctx context.Context) error
        + Next(ctx context.Context, chk *chunk.Chunk) error

    }
    class StreamAggExec << (S,Aquamarine) >> {
        - executed bool
        - isChildReturnEmpty bool
        - defaultVal *chunk.Chunk
        - groupChecker *vecGroupChecker
        - inputIter *chunk.Iterator4Chunk
        - inputRow chunk.Row
        - aggFuncs []aggfuncs.AggFunc
        - partialResults []aggfuncs.PartialResult
        - groupRows []chunk.Row
        - childResult *chunk.Chunk
        - memTracker *memory.Tracker

        - consumeOneGroup(ctx context.Context, chk *chunk.Chunk) error
        - consumeGroupRows() error
        - consumeCurGroupRowsAndFetchChild(ctx context.Context, chk *chunk.Chunk) error
        - appendResult2Chunk(chk *chunk.Chunk) error

        + Open(ctx context.Context) error
        + Close() error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class TableDualExec << (S,Aquamarine) >> {
        - numDualRows int
        - numReturned int

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class TableReaderExecutor << (S,Aquamarine) >> {
        - table table.Table
        - ranges []*ranger.Range
        - kvRanges []kv.KeyRange
        - dagPB *tipb.DAGRequest
        - startTS uint64
        - columns []*model.ColumnInfo
        - resultHandler *tableResultHandler
        - feedback *statistics.QueryFeedback
        - plans []core.PhysicalPlan
        - memTracker *memory.Tracker
        - keepOrder bool
        - desc bool
        - streaming bool
        - storeType kv.StoreType
        - corColInFilter bool
        - corColInAccess bool
        - virtualColumnIndex []int
        - virtualColumnRetFieldTypes []*types.FieldType
        - batchCop bool

        - buildResp(ctx context.Context, ranges []*ranger.Range) (distsql.SelectResult, error)
        - buildVirtualColumnInfo() 
        - setBatchCop(v *core.PhysicalTableReader) 

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error

    }
    class TableScanExec << (S,Aquamarine) >> {
        - t table.Table
        - seekHandle int64
        - iter kv.Iterator
        - columns []*model.ColumnInfo
        - isVirtualTable bool
        - virtualTableChunkList *chunk.List
        - virtualTableChunkIdx int

        - nextChunk4InfoSchema(ctx context.Context, chk *chunk.Chunk) error
        - nextHandle() (int64, bool, error)
        - getRow(handle int64) ([]types.Datum, error)

        + Next(ctx context.Context, req *chunk.Chunk) error
        + Open(ctx context.Context) error

    }
    class TopNExec << (S,Aquamarine) >> {
        - limit *core.PhysicalLimit
        - totalLimit uint64
        - rowChunks *chunk.List
        - rowPtrs []chunk.RowPtr
        - chkHeap *topNChunkHeap

        - keyColumnsLess(i int, j int) bool
        - initPointers() 
        - loadChunksUntilTotalLimit(ctx context.Context) error
        - executeTopN(ctx context.Context) error
        - processChildChk(childRowChk *chunk.Chunk) error
        - doCompaction() error

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class TraceExec << (S,Aquamarine) >> {
        - exhausted bool
        - stmtNode ast.StmtNode
        - rootTrace opentracing.Span
        - builder *executorBuilder
        - format string

        + CollectedSpans []basictracer.RawSpan

        - nextTraceLog(ctx context.Context, se sqlexec.SQLExecutor, req *chunk.Chunk) error
        - nextRowJSON(ctx context.Context, se sqlexec.SQLExecutor, req *chunk.Chunk) error
        - executeChild(ctx context.Context, se sqlexec.SQLExecutor) 

        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class UnionExec << (S,Aquamarine) >> {
        - stopFetchData atomic.Value
        - finished <font color=blue>chan</font> <font color=blue>struct</font>{}
        - resourcePools []<font color=blue>chan</font> *chunk.Chunk
        - resultPool <font color=blue>chan</font> *unionWorkerResult
        - childrenResults []*chunk.Chunk
        - wg sync.WaitGroup
        - initialized bool

        - waitAllFinished() 
        - initialize(ctx context.Context) 
        - resultPuller(ctx context.Context, childID int) 

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error

    }
    class UnionScanExec << (S,Aquamarine) >> {
        - dirty *DirtyTable
        - usedIndex []int
        - desc bool
        - conditions []expression.Expression
        - conditionsWithVirCol []expression.Expression
        - columns []*model.ColumnInfo
        - table table.Table
        - belowHandleIndex int
        - addedRows [][]types.Datum
        - cursor4AddRows int
        - sortErr error
        - snapshotRows [][]types.Datum
        - cursor4SnapshotRows int
        - snapshotChunkBuffer *chunk.Chunk
        - mutableRow chunk.MutRow
        - virtualColumnIndex []int

        - open(ctx context.Context) error
        - getOneRow(ctx context.Context) ([]types.Datum, error)
        - getSnapshotRow(ctx context.Context) ([]types.Datum, error)
        - getAddedRow() []types.Datum
        - shouldPickFirstRow(a []types.Datum, b []types.Datum) (bool, error)
        - compare(a []types.Datum, b []types.Datum) (int, error)

        + Open(ctx context.Context) error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class UpdateExec << (S,Aquamarine) >> {
        - updatedRowKeys <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]bool
        - tblID2table <font color=blue>map</font>[int64]table.Table
        - matched uint64
        - tblColPosInfos core.TblColPosInfoSlice
        - evalBuffer chunk.MutRow
        - allAssignmentsAreConstant bool
        - drained bool
        - memTracker *memory.Tracker

        + OrderedList []*expression.Assignment

        - exec(ctx context.Context, schema *expression.Schema, row []types.Datum, newData []types.Datum) error
        - canNotUpdate(handle types.Datum) bool
        - updateRows(ctx context.Context) (int, error)
        - handleErr(colName model.CIStr, rowIdx int, err error) error
        - fastComposeNewRow(rowIdx int, oldRow []types.Datum, cols []*table.Column) ([]types.Datum, error)
        - composeNewRow(rowIdx int, oldRow []types.Datum, cols []*table.Column) ([]types.Datum, error)
        - setMessage() 

        + Next(ctx context.Context, req *chunk.Chunk) error
        + Close() error
        + Open(ctx context.Context) error

    }
    class WindowExec << (S,Aquamarine) >> {
        - groupChecker *vecGroupChecker
        - childResult *chunk.Chunk
        - executed bool
        - resultChunks []*chunk.Chunk
        - remainingRowsInChunk []int
        - numWindowFuncs int
        - processor windowProcessor

        - preparedChunkAvailable() bool
        - consumeOneGroup(ctx context.Context) error
        - consumeGroupRows(groupRows []chunk.Row) error
        - fetchChild(ctx context.Context) (bool, error)
        - copyChk(src *chunk.Chunk, dst *chunk.Chunk) error

        + Close() error
        + Next(ctx context.Context, chk *chunk.Chunk) error

    }
    class aggWindowProcessor << (S,Aquamarine) >> {
        - windowFuncs []aggfuncs.AggFunc
        - partialResults []aggfuncs.PartialResult

        - consumeGroupRows(ctx sessionctx.Context, rows []chunk.Row) ([]chunk.Row, error)
        - appendResult2Chunk(ctx sessionctx.Context, rows []chunk.Row, chk *chunk.Chunk, remained int) ([]chunk.Row, error)
        - resetPartialResult() 

    }
    class allocBuf << (S,Aquamarine) >> {
        - handleBytes []byte
        - rd *rowcodec.BytesDecoder

    }
    class analyzeIndexIncrementalExec << (S,Aquamarine) >> {
        - oldHist *statistics.Histogram
        - oldCMS *statistics.CMSketch

    }
    class analyzePKIncrementalExec << (S,Aquamarine) >> {
        - oldHist *statistics.Histogram

    }
    class analyzeResult << (S,Aquamarine) >> {
        - job *statistics.AnalyzeJob

        + PhysicalTableID int64
        + Hist []*statistics.Histogram
        + Cms []*statistics.CMSketch
        + Count int64
        + IsIndex int
        + Err error

    }
    class analyzeTask << (S,Aquamarine) >> {
        - taskType taskType
        - idxExec *AnalyzeIndexExec
        - colExec *AnalyzeColumnsExec
        - fastExec *AnalyzeFastExec
        - idxIncrementalExec *analyzeIndexIncrementalExec
        - colIncrementalExec *analyzePKIncrementalExec
        - job *statistics.AnalyzeJob

    }
    class antiLeftOuterSemiJoiner << (S,Aquamarine) >> {
        - tryToMatchInners(outer chunk.Row, inners chunk.Iterator, chk *chunk.Chunk) (bool, bool, error)
        - tryToMatchOuters(outers chunk.Iterator, inner chunk.Row, chk *chunk.Chunk, outerRowStatus []outerRowStatusFlag) ([]outerRowStatusFlag, error)
        - onMatch(outer chunk.Row, chk *chunk.Chunk) 
        - onMissMatch(hasNull bool, outer chunk.Row, chk *chunk.Chunk) 

        + Clone() joiner

    }
    class antiSemiJoiner << (S,Aquamarine) >> {
        - tryToMatchInners(outer chunk.Row, inners chunk.Iterator, chk *chunk.Chunk) (bool, bool, error)
        - tryToMatchOuters(outers chunk.Iterator, inner chunk.Row, chk *chunk.Chunk, outerRowStatus []outerRowStatusFlag) ([]outerRowStatusFlag, error)
        - onMissMatch(hasNull bool, outer chunk.Row, chk *chunk.Chunk) 

        + Clone() joiner

    }
    class backfillResult << (S,Aquamarine) >> {
        - nextHandle int64
        - addedCount int64
        - scanRowCount int64

    }
    class baseExecutor << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - id fmt.Stringer
        - schema *expression.Schema
        - initCap int
        - maxChunkSize int
        - children []Executor
        - retFieldTypes []*types.FieldType
        - runtimeStats *execdetails.RuntimeStats

        - base() *baseExecutor
        - getSysSession() (sessionctx.Context, error)
        - releaseSysSession(ctx sessionctx.Context) 

        + Open(ctx context.Context) error
        + Close() error
        + Schema() *expression.Schema
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class baseHashAggWorker << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - finishCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - aggFuncs []aggfuncs.AggFunc
        - maxChunkSize int

        - getPartialResult(sc *stmtctx.StatementContext, groupKey [][]byte, mapper aggPartialResultMapper) [][]aggfuncs.PartialResult

    }
    class baseJoiner << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - conditions []expression.Expression
        - defaultInner chunk.Row
        - outerIsRight bool
        - chk *chunk.Chunk
        - shallowRow chunk.MutRow
        - selected []bool
        - isNull []bool
        - maxChunkSize int
        - lUsed []int

        - initDefaultInner(innerTypes []*types.FieldType, defaultInner []types.Datum) 
        - makeJoinRowToChunk(chk *chunk.Chunk, lhs chunk.Row, rhs chunk.Row, lUsed []int, rUsed []int) 
        - makeShallowJoinRow(isRightJoin bool, inner chunk.Row, outer chunk.Row) 
        - filter(input *chunk.Chunk, output *chunk.Chunk, outerColLen int, lUsed []int, rUsed []int) (bool, error)
        - filterAndCheckOuterRowStatus(input *chunk.Chunk, output *chunk.Chunk, innerColsLen int, outerRowStatus []outerRowStatusFlag, lUsed []int, rUsed []int) ([]outerRowStatusFlag, error)

        + Clone() baseJoiner

    }
    class brieQueue << (S,Aquamarine) >> {
        - nextID uint64
        - tasks sync.Map
        - workerCh <font color=blue>chan</font> <font color=blue>struct</font>{}

        - registerTask(ctx context.Context, info *brieTaskInfo) (context.Context, uint64)
        - acquireTask(taskCtx context.Context, taskID uint64) (*brieTaskProgress, error)
        - releaseTask() 
        - cancelTask(taskID uint64) 

    }
    class brieQueueItem << (S,Aquamarine) >> {
        - info *brieTaskInfo
        - progress *brieTaskProgress
        - cancel <font color=blue>func</font>() 

    }
    class brieTaskInfo << (S,Aquamarine) >> {
        - queueTime types.Time
        - execTime types.Time
        - kind ast.BRIEKind
        - storage string
        - connID uint64
        - backupTS uint64
        - archiveSize uint64

    }
    class brieTaskProgress << (S,Aquamarine) >> {
        - current int64
        - lock sync.Mutex
        - cmd string
        - total int64

        + Inc() 
        + Close() 

    }
    class checkIndexValue << (S,Aquamarine) >> {
        - idxColTps []*types.FieldType
        - idxTblCols []*table.Column
        - genExprs <font color=blue>map</font>[model.TableColumnID]expression.Expression

    }
    class checkRegionHealth << (S,Aquamarine) >> {
        - genSQL(timeRange core.QueryTimeRange) string
        - genResult(_ string, row chunk.Row) inspectionResult
        - getItem() string

    }
    class checkStoreRegionTooMuch << (S,Aquamarine) >> {
        - genSQL(timeRange core.QueryTimeRange) string
        - genResult(sql string, row chunk.Row) inspectionResult
        - getItem() string

    }
    class checksumContext << (S,Aquamarine) >> {
        + DBInfo *model.DBInfo
        + TableInfo *model.TableInfo
        + StartTs uint64
        + Response *tipb.ChecksumResponse

        - appendRequest(ctx sessionctx.Context, tableID int64, reqs *[]*kv.Request) error
        - buildTableRequest(ctx sessionctx.Context, tableID int64) (*kv.Request, error)
        - buildIndexRequest(ctx sessionctx.Context, tableID int64, indexInfo *model.IndexInfo) (*kv.Request, error)

        + BuildRequests(ctx sessionctx.Context) ([]*kv.Request, error)
        + HandleResponse(update *tipb.ChecksumResponse) 

    }
    class checksumResult << (S,Aquamarine) >> {
        + Error error
        + TableID int64
        + Response *tipb.ChecksumResponse

    }
    class checksumTask << (S,Aquamarine) >> {
        + TableID int64
        + Request *kv.Request

    }
    class chunkRowRecordSet << (S,Aquamarine) >> {
        - rows []chunk.Row
        - idx int
        - fields []*ast.ResultField
        - e Executor
        - execStmt *ExecStmt

        + Fields() []*ast.ResultField
        + Next(ctx context.Context, chk *chunk.Chunk) error
        + NewChunk() *chunk.Chunk
        + Close() error

    }
    class clusterConfigRetriever << (S,Aquamarine) >> {
        - retrieved bool
        - extractor *core.ClusterTableExtractor

        - retrieve(_ context.Context, sctx sessionctx.Context) ([][]types.Datum, error)

    }
    class clusterLogRetriever << (S,Aquamarine) >> {
        - isDrained bool
        - retrieving bool
        - heap *logResponseHeap
        - extractor *core.ClusterLogTableExtractor
        - cancel context.CancelFunc

        - initialize(ctx context.Context, sctx sessionctx.Context) ([]<font color=blue>chan</font> logStreamResult, error)
        - startRetrieving(ctx context.Context, sctx sessionctx.Context, serversInfo []infoschema.ServerInfo, req *diagnosticspb.SearchLogRequest) ([]<font color=blue>chan</font> logStreamResult, error)
        - retrieve(ctx context.Context, sctx sessionctx.Context) ([][]types.Datum, error)
        - close() error

    }
    class clusterServerInfoRetriever << (S,Aquamarine) >> {
        - extractor *core.ClusterTableExtractor
        - serverInfoType diagnosticspb.ServerInfoType
        - retrieved bool

        - retrieve(ctx context.Context, sctx sessionctx.Context) ([][]types.Datum, error)

    }
    class compareStoreStatus << (S,Aquamarine) >> {
        - item string
        - tp string
        - threshold float64

        - genSQL(timeRange core.QueryTimeRange) string
        - genResult(_ string, row chunk.Row) inspectionResult
        - getItem() string

    }
    class configInspection << (S,Aquamarine) >> {
        - inspect(ctx context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult
        - inspectDiffConfig(_ context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult
        - inspectCheckConfig(ctx context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult
        - checkTiKVBlockCacheSizeConfig(ctx context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult
        - convertReadableSizeToByteSize(sizeStr string) (uint64, error)

    }
    class criticalErrorInspection << (S,Aquamarine) >> {
        - inspect(ctx context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult
        - inspectError(ctx context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult
        - inspectForServerDown(ctx context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult

    }
    class dataReaderBuilder << (S,Aquamarine) >> {
        - buildExecutorForIndexJoin(ctx context.Context, lookUpContents []*indexJoinLookUpContent, IndexRanges []*ranger.Range, keyOff2IdxOff []int, cwc *core.ColWithCmpFuncManager) (Executor, error)
        - buildExecutorForIndexJoinInternal(ctx context.Context, plan core.Plan, lookUpContents []*indexJoinLookUpContent, IndexRanges []*ranger.Range, keyOff2IdxOff []int, cwc *core.ColWithCmpFuncManager) (Executor, error)
        - buildUnionScanForIndexJoin(ctx context.Context, v *core.PhysicalUnionScan, values []*indexJoinLookUpContent, indexRanges []*ranger.Range, keyOff2IdxOff []int, cwc *core.ColWithCmpFuncManager) (Executor, error)
        - buildTableReaderForIndexJoin(ctx context.Context, v *core.PhysicalTableReader, lookUpContents []*indexJoinLookUpContent) (Executor, error)
        - buildTableReaderFromHandles(ctx context.Context, e *TableReaderExecutor, handles []int64) (Executor, error)
        - buildIndexReaderForIndexJoin(ctx context.Context, v *core.PhysicalIndexReader, lookUpContents []*indexJoinLookUpContent, indexRanges []*ranger.Range, keyOff2IdxOff []int, cwc *core.ColWithCmpFuncManager) (Executor, error)
        - buildIndexLookUpReaderForIndexJoin(ctx context.Context, v *core.PhysicalIndexLookUpReader, lookUpContents []*indexJoinLookUpContent, indexRanges []*ranger.Range, keyOff2IdxOff []int, cwc *core.ColWithCmpFuncManager) (Executor, error)
        - buildProjectionForIndexJoin(ctx context.Context, v *core.PhysicalProjection, lookUpContents []*indexJoinLookUpContent, indexRanges []*ranger.Range, keyOff2IdxOff []int, cwc *core.ColWithCmpFuncManager) (Executor, error)

    }
    class defaultVal << (S,Aquamarine) >> {
        - val types.Datum
        - valid bool

    }
    class dummyCloser << (S,Aquamarine) >> {
        - close() error

    }
    class entry << (S,Aquamarine) >> {
        - ptr chunk.RowPtr
        - next entryAddr

    }
    class entryAddr << (S,Aquamarine) >> {
        - sliceIdx uint32
        - offset uint32

    }
    class entryStore << (S,Aquamarine) >> {
        - slices [][]entry

        - init() 
        - put(e entry) entryAddr
        - get(addr entryAddr) entry

    }
    class executor.IndexAdviseVarKeyType << (T, #FF7700) >>  {
    }
    class executor.TestShowClusterConfigFunc << (T, #FF7700) >>  {
    }
    class executor.aggPartialResultMapper << (T, #FF7700) >>  {
    }
    class executor.loadDataVarKeyType << (T, #FF7700) >>  {
    }
    class executor.loadStatsVarKeyType << (T, #FF7700) >>  {
    }
    class executor.logResponseHeap << (T, #FF7700) >>  {
    }
    class executor.objectType << (T, #FF7700) >>  {
    }
    class executor.outerRowStatusFlag << (T, #FF7700) >>  {
    }
    class executor.processKVFunc << (T, #FF7700) >>  {
    }
    class executor.promQLQueryRange << (T, #FF7700) >>  {
    }
    class executor.tableRowMapType << (T, #FF7700) >>  {
    }
    class executor.taskType << (T, #FF7700) >>  {
    }
    class executorBuilder << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - is infoschema.InfoSchema
        - snapshotTS uint64
        - err error
        - hasLock bool

        - buildPointGet(p *core.PointGetPlan) Executor
        - build(p core.Plan) Executor
        - buildCancelDDLJobs(v *core.CancelDDLJobs) Executor
        - buildChange(v *core.Change) Executor
        - buildShowNextRowID(v *core.ShowNextRowID) Executor
        - buildShowDDL(v *core.ShowDDL) Executor
        - buildShowDDLJobs(v *core.PhysicalShowDDLJobs) Executor
        - buildShowDDLJobQueries(v *core.ShowDDLJobQueries) Executor
        - buildShowSlow(v *core.ShowSlow) Executor
        - buildCheckTable(v *core.CheckTable) Executor
        - buildRecoverIndex(v *core.RecoverIndex) Executor
        - buildCleanupIndex(v *core.CleanupIndex) Executor
        - buildCheckIndexRange(v *core.CheckIndexRange) Executor
        - buildChecksumTable(v *core.ChecksumTable) Executor
        - buildReloadExprPushdownBlacklist(v *core.ReloadExprPushdownBlacklist) Executor
        - buildReloadOptRuleBlacklist(v *core.ReloadOptRuleBlacklist) Executor
        - buildAdminPlugins(v *core.AdminPlugins) Executor
        - buildDeallocate(v *core.Deallocate) Executor
        - buildSelectLock(v *core.PhysicalLock) Executor
        - buildLimit(v *core.PhysicalLimit) Executor
        - buildPrepare(v *core.Prepare) Executor
        - buildExecute(v *core.Execute) Executor
        - buildShow(v *core.PhysicalShow) Executor
        - buildSimple(v *core.Simple) Executor
        - buildSet(v *core.Set) Executor
        - buildSetConfig(v *core.SetConfig) Executor
        - buildInsert(v *core.Insert) Executor
        - buildLoadData(v *core.LoadData) Executor
        - buildLoadStats(v *core.LoadStats) Executor
        - buildIndexAdvise(v *core.IndexAdvise) Executor
        - buildReplace(vals *InsertValues) Executor
        - buildGrant(grant *ast.GrantStmt) Executor
        - buildRevoke(revoke *ast.RevokeStmt) Executor
        - buildDDL(v *core.DDL) Executor
        - buildTrace(v *core.Trace) Executor
        - buildExplain(v *core.Explain) Executor
        - buildSelectInto(v *core.SelectInto) Executor
        - buildUnionScanExec(v *core.PhysicalUnionScan) Executor
        - buildUnionScanFromReader(reader Executor, v *core.PhysicalUnionScan) Executor
        - buildMergeJoin(v *core.PhysicalMergeJoin) Executor
        - buildSideEstCount(v *core.PhysicalHashJoin) float64
        - buildHashJoin(v *core.PhysicalHashJoin) Executor
        - buildHashAgg(v *core.PhysicalHashAgg) Executor
        - buildStreamAgg(v *core.PhysicalStreamAgg) Executor
        - buildSelection(v *core.PhysicalSelection) Executor
        - buildProjection(v *core.PhysicalProjection) Executor
        - buildTableDual(v *core.PhysicalTableDual) Executor
        - getSnapshotTS() (uint64, error)
        - buildMemTable(v *core.PhysicalMemTable) Executor
        - buildSort(v *core.PhysicalSort) Executor
        - buildTopN(v *core.PhysicalTopN) Executor
        - buildApply(v *core.PhysicalApply) *NestedLoopApplyExec
        - buildMaxOneRow(v *core.PhysicalMaxOneRow) Executor
        - buildUnionAll(v *core.PhysicalUnionAll) Executor
        - buildSplitRegion(v *core.SplitRegion) Executor
        - buildUpdate(v *core.Update) Executor
        - buildDelete(v *core.Delete) Executor
        - updateForUpdateTSIfNeeded(selectPlan core.PhysicalPlan) error
        - refreshForUpdateTSForRC() error
        - buildAnalyzeIndexPushdown(task core.AnalyzeIndexTask, opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64, autoAnalyze string) *analyzeTask
        - buildAnalyzeIndexIncremental(task core.AnalyzeIndexTask, opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64) *analyzeTask
        - buildAnalyzeColumnsPushdown(task core.AnalyzeColumnsTask, opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64, autoAnalyze string) *analyzeTask
        - buildAnalyzePKIncremental(task core.AnalyzeColumnsTask, opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64) *analyzeTask
        - buildAnalyzeFastColumn(e *AnalyzeExec, task core.AnalyzeColumnsTask, opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64) 
        - buildAnalyzeFastIndex(e *AnalyzeExec, task core.AnalyzeIndexTask, opts <font color=blue>map</font>[ast.AnalyzeOptionType]uint64) 
        - buildAnalyze(v *core.Analyze) Executor
        - constructDAGReq(plans []core.PhysicalPlan) (*tipb.DAGRequest, bool, error)
        - corColInDistPlan(plans []core.PhysicalPlan) bool
        - corColInAccess(p core.PhysicalPlan) bool
        - buildIndexLookUpJoin(v *core.PhysicalIndexJoin) Executor
        - buildIndexLookUpMergeJoin(v *core.PhysicalIndexMergeJoin) Executor
        - buildIndexNestedLoopHashJoin(v *core.PhysicalIndexHashJoin) Executor
        - buildTableReader(v *core.PhysicalTableReader) *TableReaderExecutor
        - buildIndexReader(v *core.PhysicalIndexReader) *IndexReaderExecutor
        - buildIndexLookUpReader(v *core.PhysicalIndexLookUpReader) *IndexLookUpExecutor
        - buildIndexMergeReader(v *core.PhysicalIndexMergeReader) *IndexMergeReaderExecutor
        - buildWindow(v *core.PhysicalWindow) *WindowExec
        - buildShuffle(v *core.PhysicalShuffle) *ShuffleExec
        - buildShuffleDataSourceStub(v *core.PhysicalShuffleDataSourceStub) *shuffleWorker
        - buildSQLBindExec(v *core.SQLBindPlan) Executor
        - buildBatchPointGet(plan *core.BatchPointGetPlan) Executor
        - buildAdminShowTelemetry(v *core.AdminShowTelemetry) Executor
        - buildAdminResetTelemetryID(v *core.AdminResetTelemetryID) Executor
        - parseTSString(ts string) (uint64, error)
        - buildBRIE(s *ast.BRIEStmt, schema *expression.Schema) Executor

    }
    class field << (S,Aquamarine) >> {
        - str []byte
        - maybeNull bool
        - enclosed bool

        - escape() field
        - escapeChar(c byte) byte

    }
    class fieldWriter << (S,Aquamarine) >> {
        - pos int
        - term string
        - enclosedChar byte
        - fieldTermChar byte
        - isEnclosed bool
        - isLineStart bool
        - isFieldStart bool

        + ReadBuf []byte
        + OutputBuf []byte

        - putback() 
        - getChar() (bool, byte)
        - isTerminator() bool
        - outputField(enclosed bool) field

        + Init(enclosedChar byte, fieldTermChar byte, readBuf []byte, term string) 
        + GetField() (bool, field)

    }
    class globalPanicOnExceed << (S,Aquamarine) >> {
        - mutex sync.Mutex

        + SetLogHook(hook <font color=blue>func</font>(uint64) ) 
        + Action(t *memory.Tracker) 
        + SetFallback( memory.ActionOnExceed) 

    }
    class hashContext << (S,Aquamarine) >> {
        - allTypes []*types.FieldType
        - keyColIdx []int
        - buf []byte
        - hashVals []hash.Hash64
        - hasNull []bool

        - initHash(rows int) 

    }
    class hashRowContainer << (S,Aquamarine) >> {
        - sc *stmtctx.StatementContext
        - hCtx *hashContext
        - stat hashStatistic
        - hashTable *rowHashMap
        - rowContainer *chunk.RowContainer

        - matchJoinKey(buildRow chunk.Row, probeRow chunk.Row, probeHCtx *hashContext) (bool, error)
        - alreadySpilledSafe() bool
        - getJoinKeyFromChkRow(sc *stmtctx.StatementContext, row chunk.Row, hCtx *hashContext) (bool, uint64, error)

        + GetMatchedRowsAndPtrs(probeKey uint64, probeRow chunk.Row, hCtx *hashContext) ([]chunk.Row, []chunk.RowPtr, error)
        + PutChunk(chk *chunk.Chunk) error
        + PutChunkSelected(chk *chunk.Chunk, selected []bool) error
        + NumChunks() int
        + NumRowsOfChunk(chkID int) int
        + GetChunk(chkIdx int) (*chunk.Chunk, error)
        + GetRow(ptr chunk.RowPtr) (chunk.Row, error)
        + Len() int
        + Close() error
        + GetMemTracker() *memory.Tracker
        + GetDiskTracker() *disk.Tracker
        + ActionSpill() memory.ActionOnExceed

    }
    class hashStatistic << (S,Aquamarine) >> {
        - probeCollision int
        - buildTableElapse time.Duration

        + String() string

    }
    class hashjoinWorkerResult << (S,Aquamarine) >> {
        - chk *chunk.Chunk
        - err error
        - src <font color=blue>chan</font> *chunk.Chunk

    }
    class indexHashJoinInnerWorker << (S,Aquamarine) >> {
        - matchedOuterPtrs []chunk.RowPtr
        - joiner joiner
        - joinChkResourceCh <font color=blue>chan</font> *chunk.Chunk
        - resultCh <font color=blue>chan</font> *indexHashJoinResult
        - taskCh <font color=blue>chan</font> *indexHashJoinTask
        - wg *sync.WaitGroup
        - joinKeyBuf []byte
        - outerRowStatus []outerRowStatusFlag

        - run(ctx context.Context, cancelFunc context.CancelFunc) 
        - getNewJoinResult(ctx context.Context) (*indexHashJoinResult, bool)
        - buildHashTableForOuterResult(ctx context.Context, cancelFunc context.CancelFunc, task *indexHashJoinTask, h hash.Hash64) 
        - fetchInnerResults(ctx context.Context, task *lookUpJoinTask) error
        - handleHashJoinInnerWorkerPanic(r <font color=blue>interface</font>{}) 
        - handleTask(ctx context.Context, cancelFunc context.CancelFunc, task *indexHashJoinTask, joinResult *indexHashJoinResult, h hash.Hash64, resultCh <font color=blue>chan</font> *indexHashJoinResult) error
        - doJoinUnordered(ctx context.Context, task *indexHashJoinTask, joinResult *indexHashJoinResult, h hash.Hash64, resultCh <font color=blue>chan</font> *indexHashJoinResult) error
        - getMatchedOuterRows(innerRow chunk.Row, task *indexHashJoinTask, h hash.Hash64, buf []byte) ([]chunk.Row, []chunk.RowPtr, error)
        - joinMatchedInnerRow2Chunk(ctx context.Context, innerRow chunk.Row, task *indexHashJoinTask, joinResult *indexHashJoinResult, h hash.Hash64, buf []byte) (bool, *indexHashJoinResult)
        - collectMatchedInnerPtrs4OuterRows(ctx context.Context, innerRow chunk.Row, innerRowPtr chunk.RowPtr, task *indexHashJoinTask, h hash.Hash64, buf []byte) error
        - doJoinInOrder(ctx context.Context, task *indexHashJoinTask, joinResult *indexHashJoinResult, h hash.Hash64, resultCh <font color=blue>chan</font> *indexHashJoinResult) error

    }
    class indexHashJoinOuterWorker << (S,Aquamarine) >> {
        - innerCh <font color=blue>chan</font> *indexHashJoinTask
        - keepOuterOrder bool
        - taskCh <font color=blue>chan</font> *indexHashJoinTask

        - run(ctx context.Context, cancelFunc context.CancelFunc) 
        - buildTask(ctx context.Context) (*indexHashJoinTask, error)
        - pushToChan(ctx context.Context, task *indexHashJoinTask, dst <font color=blue>chan</font> *indexHashJoinTask) bool

    }
    class indexHashJoinResult << (S,Aquamarine) >> {
        - chk *chunk.Chunk
        - err error
        - src <font color=blue>chan</font> *chunk.Chunk

    }
    class indexHashJoinTask << (S,Aquamarine) >> {
        - outerRowStatus [][]outerRowStatusFlag
        - lookupMap *rowHashMap
        - err error
        - keepOuterOrder bool
        - resultCh <font color=blue>chan</font> *indexHashJoinResult
        - matchedInnerRowPtrs [][][]chunk.RowPtr

    }
    class indexJoinLookUpContent << (S,Aquamarine) >> {
        - keys []types.Datum
        - row chunk.Row

    }
    class indexMergeJoinResult << (S,Aquamarine) >> {
        - chk *chunk.Chunk
        - src <font color=blue>chan</font> *chunk.Chunk

    }
    class indexMergeProcessWorker << (S,Aquamarine) >> {
        - fetchLoop(ctx context.Context, fetchCh <font color=blue>chan</font> *lookupTableTask, workCh <font color=blue>chan</font> *lookupTableTask, resultCh <font color=blue>chan</font> *lookupTableTask, finished <font color=blue>chan</font> <font color=blue>struct</font>{}) 
        - handleLoopFetcherPanic(ctx context.Context, resultCh <font color=blue>chan</font> *lookupTableTask) <font color=blue>func</font>(<font color=blue>interface</font>{}) 

    }
    class indexMergeTableScanWorker << (S,Aquamarine) >> {
        - workCh <font color=blue>chan</font> *lookupTableTask
        - finished <font color=blue>chan</font> <font color=blue>struct</font>{}
        - buildTblReader <font color=blue>func</font>(context.Context, []int64) (Executor, error)
        - tblPlans []core.PhysicalPlan
        - memTracker *memory.Tracker

        - pickAndExecTask(ctx context.Context) *lookupTableTask
        - handlePickAndExecTaskPanic(ctx context.Context, task *lookupTableTask) <font color=blue>func</font>(<font color=blue>interface</font>{}) 
        - executeTask(ctx context.Context, task *lookupTableTask) error

    }
    class indexWorker << (S,Aquamarine) >> {
        - idxLookup *IndexLookUpExecutor
        - workCh <font color=blue>chan</font> *lookupTableTask
        - finished <font color=blue>chan</font> <font color=blue>struct</font>{}
        - resultCh <font color=blue>chan</font> *lookupTableTask
        - keepOrder bool
        - batchSize int
        - maxBatchSize int
        - maxChunkSize int

        + PushedLimit *core.PushedDownLimit

        - fetchHandles(ctx context.Context, result distsql.SelectResult) (uint64, error)
        - extractTaskHandles(ctx context.Context, chk *chunk.Chunk, idxResult distsql.SelectResult, count uint64) ([]int64, *chunk.Chunk, uint64, error)
        - buildTableTask(handles []int64, retChk *chunk.Chunk) *lookupTableTask

    }
    class innerCtx << (S,Aquamarine) >> {
        - readerBuilder *dataReaderBuilder
        - rowTypes []*types.FieldType
        - keyCols []int
        - colLens []int
        - hasPrefixCol bool

    }
    class innerJoiner << (S,Aquamarine) >> {
        - tryToMatchInners(outer chunk.Row, inners chunk.Iterator, chk *chunk.Chunk) (bool, bool, error)
        - tryToMatchOuters(outers chunk.Iterator, inner chunk.Row, chk *chunk.Chunk, outerRowStatus []outerRowStatusFlag) ([]outerRowStatusFlag, error)
        - onMissMatch(_ bool, outer chunk.Row, chk *chunk.Chunk) 

        + Clone() joiner

    }
    class innerMergeCtx << (S,Aquamarine) >> {
        - readerBuilder *dataReaderBuilder
        - rowTypes []*types.FieldType
        - joinKeys []*expression.Column
        - keyCols []int
        - compareFuncs []expression.CompareFunc
        - colLens []int
        - desc bool
        - keyOff2KeyOffOrderByIdx []int

    }
    class innerMergeWorker << (S,Aquamarine) >> {
        - taskCh <font color=blue>chan</font> *lookUpMergeJoinTask
        - joinChkResourceCh <font color=blue>chan</font> *chunk.Chunk
        - outerMergeCtx outerMergeCtx
        - ctx sessionctx.Context
        - innerExec Executor
        - joiner joiner
        - retFieldTypes []*types.FieldType
        - maxChunkSize int
        - indexRanges []*ranger.Range
        - nextColCompareFilters *core.ColWithCmpFuncManager
        - keyOff2IdxOff []int

        - run(ctx context.Context, wg *sync.WaitGroup, cancelFunc context.CancelFunc) 
        - handleTask(ctx context.Context, task *lookUpMergeJoinTask) error
        - fetchNewChunkWhenFull(ctx context.Context, task *lookUpMergeJoinTask, chk **chunk.Chunk) bool
        - doMergeJoin(ctx context.Context, task *lookUpMergeJoinTask) error
        - fetchInnerRowsWithSameKey(ctx context.Context, task *lookUpMergeJoinTask, key chunk.Row) (bool, error)
        - compare(outerRow chunk.Row, innerRow chunk.Row) (int, error)
        - constructDatumLookupKeys(task *lookUpMergeJoinTask) ([]*indexJoinLookUpContent, error)
        - constructDatumLookupKey(task *lookUpMergeJoinTask, rowIdx chunk.RowPtr) (*indexJoinLookUpContent, error)
        - dedupDatumLookUpKeys(lookUpContents []*indexJoinLookUpContent) []*indexJoinLookUpContent
        - fetchNextInnerResult(ctx context.Context, task *lookUpMergeJoinTask) (chunk.Row, error)

    }
    class innerWorker << (S,Aquamarine) >> {
        - taskCh <font color=blue>chan</font> *lookUpJoinTask
        - outerCtx outerCtx
        - ctx sessionctx.Context
        - executorChk *chunk.Chunk
        - indexRanges []*ranger.Range
        - nextColCompareFilters *core.ColWithCmpFuncManager
        - keyOff2IdxOff []int

        - run(ctx context.Context, wg *sync.WaitGroup) 
        - handleTask(ctx context.Context, task *lookUpJoinTask) error
        - constructLookupContent(task *lookUpJoinTask) ([]*indexJoinLookUpContent, error)
        - constructDatumLookupKey(task *lookUpJoinTask, chkIdx int, rowIdx int) ([]types.Datum, error)
        - sortAndDedupLookUpContents(lookUpContents []*indexJoinLookUpContent) []*indexJoinLookUpContent
        - fetchInnerResults(ctx context.Context, task *lookUpJoinTask, lookUpContent []*indexJoinLookUpContent) error
        - buildLookUpMap(task *lookUpJoinTask) error
        - hasNullInJoinKey(row chunk.Row) bool

    }
    interface insertCommon  {
        - insertCommon() *InsertValues
        - exec(ctx context.Context, rows [][]types.Datum) error

    }
    class inspectCPULoad << (S,Aquamarine) >> {
        - item string
        - tbl string

        - genSQL(timeRange core.QueryTimeRange) string
        - genResult(sql string, row chunk.Row) inspectionResult
        - getItem() string

    }
    class inspectDiskUsage << (S,Aquamarine) >> {
        - genSQL(timeRange core.QueryTimeRange) string
        - genResult(sql string, row chunk.Row) inspectionResult
        - getItem() string

    }
    class inspectSwapMemoryUsed << (S,Aquamarine) >> {
        - genSQL(timeRange core.QueryTimeRange) string
        - genResult(sql string, row chunk.Row) inspectionResult
        - getItem() string

    }
    class inspectVirtualMemUsage << (S,Aquamarine) >> {
        - genSQL(timeRange core.QueryTimeRange) string
        - genResult(sql string, row chunk.Row) inspectionResult
        - getItem() string

    }
    class inspectionFilter << (S,Aquamarine) >> {
        - enable(name string) bool
        - exist(name string) bool

    }
    class inspectionName << (S,Aquamarine) >> {
        - name() string

    }
    class inspectionResult << (S,Aquamarine) >> {
        - tp string
        - instance string
        - statusAddress string
        - item string
        - actual string
        - expected string
        - severity string
        - detail string
        - degree float64

    }
    class inspectionResultRetriever << (S,Aquamarine) >> {
        - retrieved bool
        - extractor *core.InspectionResultTableExtractor
        - timeRange core.QueryTimeRange
        - instanceToStatusAddress <font color=blue>map</font>[string]string
        - statusToInstanceAddress <font color=blue>map</font>[string]string

        - retrieve(ctx context.Context, sctx sessionctx.Context) ([][]types.Datum, error)

    }
    class inspectionRuleRetriever << (S,Aquamarine) >> {
        - retrieved bool
        - extractor *core.InspectionRuleTableExtractor

        - retrieve(ctx context.Context, sctx sessionctx.Context) ([][]types.Datum, error)

    }
    class inspectionSummaryRetriever << (S,Aquamarine) >> {
        - retrieved bool
        - table *model.TableInfo
        - extractor *core.InspectionSummaryTableExtractor
        - timeRange core.QueryTimeRange

        - retrieve(ctx context.Context, sctx sessionctx.Context) ([][]types.Datum, error)

    }
    interface joiner  {
        - tryToMatchInners(outer chunk.Row, inners chunk.Iterator, chk *chunk.Chunk) (bool, bool, error)
        - tryToMatchOuters(outer chunk.Iterator, inner chunk.Row, chk *chunk.Chunk, outerRowStatus []outerRowStatusFlag) ([]outerRowStatusFlag, error)
        - onMissMatch(hasNull bool, outer chunk.Row, chk *chunk.Chunk) 

        + Clone() joiner

    }
    class keyValue << (S,Aquamarine) >> {
        - key kv.Key
        - value []byte

    }
    class keyValueWithDupInfo << (S,Aquamarine) >> {
        - newKV keyValue
        - dupErr error

    }
    class leftOuterJoiner << (S,Aquamarine) >> {
        - tryToMatchInners(outer chunk.Row, inners chunk.Iterator, chk *chunk.Chunk) (bool, bool, error)
        - tryToMatchOuters(outers chunk.Iterator, inner chunk.Row, chk *chunk.Chunk, outerRowStatus []outerRowStatusFlag) ([]outerRowStatusFlag, error)
        - onMissMatch(_ bool, outer chunk.Row, chk *chunk.Chunk) 

        + Clone() joiner

    }
    class leftOuterSemiJoiner << (S,Aquamarine) >> {
        - tryToMatchInners(outer chunk.Row, inners chunk.Iterator, chk *chunk.Chunk) (bool, bool, error)
        - tryToMatchOuters(outers chunk.Iterator, inner chunk.Row, chk *chunk.Chunk, outerRowStatus []outerRowStatusFlag) ([]outerRowStatusFlag, error)
        - onMatch(outer chunk.Row, chk *chunk.Chunk) 
        - onMissMatch(hasNull bool, outer chunk.Row, chk *chunk.Chunk) 

        + Clone() joiner

    }
    class loadDataVarKeyType << (S,Aquamarine) >> {
        + String() string

    }
    class loadStatsVarKeyType << (S,Aquamarine) >> {
        + String() string

    }
    class logFile << (S,Aquamarine) >> {
        - file *os.File
        - start time.Time

    }
    class logResponseHeap << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}

    }
    class logStreamResult << (S,Aquamarine) >> {
        - next <font color=blue>chan</font> logStreamResult
        - addr string
        - typ string
        - messages []*diagnosticspb.LogMessage
        - err error

    }
    class lookUpJoinTask << (S,Aquamarine) >> {
        - outerResult *chunk.List
        - outerMatch [][]bool
        - innerResult *chunk.List
        - encodedLookUpKeys []*chunk.Chunk
        - lookupMap *mvmap.MVMap
        - matchedInners []chunk.Row
        - doneCh <font color=blue>chan</font> error
        - cursor chunk.RowPtr
        - hasMatch bool
        - hasNull bool
        - memTracker *memory.Tracker

    }
    class lookUpMergeJoinTask << (S,Aquamarine) >> {
        - outerResult *chunk.List
        - outerOrderIdx []chunk.RowPtr
        - innerResult *chunk.Chunk
        - innerIter chunk.Iterator
        - sameKeyInnerRows []chunk.Row
        - sameKeyIter chunk.Iterator
        - doneErr error
        - results <font color=blue>chan</font> *indexMergeJoinResult
        - memTracker *memory.Tracker

    }
    class lookupTableTask << (S,Aquamarine) >> {
        - handles []int64
        - rowIdx []int
        - rows []chunk.Row
        - idxRows *chunk.Chunk
        - cursor int
        - doneCh <font color=blue>chan</font> error
        - indexOrder <font color=blue>map</font>[int64]int
        - duplicatedIndexOrder <font color=blue>map</font>[int64]int
        - memUsage int64
        - memTracker *memory.Tracker

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class memIndexLookUpReader << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - index *model.IndexInfo
        - columns []*model.ColumnInfo
        - table table.Table
        - desc bool
        - conditions []expression.Expression
        - retFieldTypes []*types.FieldType
        - idxReader *memIndexReader

        - getMemRows() ([][]types.Datum, error)

    }
    class memIndexReader << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - index *model.IndexInfo
        - table *model.TableInfo
        - kvRanges []kv.KeyRange
        - desc bool
        - conditions []expression.Expression
        - addedRows [][]types.Datum
        - addedRowsLen int
        - retFieldTypes []*types.FieldType
        - outputOffset []int
        - belowHandleIndex int

        - getMemRows() ([][]types.Datum, error)
        - decodeIndexKeyValue(key []byte, value []byte, tps []*types.FieldType) ([]types.Datum, error)
        - getMemRowsHandle() ([]int64, error)

    }
    class memTableReader << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - table *model.TableInfo
        - columns []*model.ColumnInfo
        - kvRanges []kv.KeyRange
        - desc bool
        - conditions []expression.Expression
        - addedRows [][]types.Datum
        - retFieldTypes []*types.FieldType
        - colIDs <font color=blue>map</font>[int64]int
        - buffer allocBuf

        - getMemRows() ([][]types.Datum, error)
        - decodeRecordKeyValue(key []byte, value []byte) ([]types.Datum, error)

    }
    interface memTableRetriever  {
        - retrieve(ctx context.Context, sctx sessionctx.Context) ([][]types.Datum, error)
        - close() error

    }
    class memtableRetriever << (S,Aquamarine) >> {
        - table *model.TableInfo
        - columns []*model.ColumnInfo
        - rows [][]types.Datum
        - rowIdx int
        - retrieved bool
        - initialized bool

        - retrieve(ctx context.Context, sctx sessionctx.Context) ([][]types.Datum, error)
        - setDataFromSchemata(ctx sessionctx.Context, schemas []*model.DBInfo) 
        - setDataForStatistics(ctx sessionctx.Context, schemas []*model.DBInfo) 
        - setDataForStatisticsInTable(schema *model.DBInfo, table *model.TableInfo) 
        - setDataFromTables(ctx sessionctx.Context, schemas []*model.DBInfo) error
        - setDataForColumns(ctx sessionctx.Context, schemas []*model.DBInfo) 
        - dataForColumnsInTable(schema *model.DBInfo, tbl *model.TableInfo) [][]types.Datum
        - setDataFromPartitions(ctx sessionctx.Context, schemas []*model.DBInfo) error
        - setDataFromIndexes(ctx sessionctx.Context, schemas []*model.DBInfo) 
        - setDataFromViews(ctx sessionctx.Context, schemas []*model.DBInfo) 
        - setDataFromEngines() 
        - setDataFromCharacterSets() 
        - setDataFromCollations() 
        - dataForCollationCharacterSetApplicability() 
        - dataForTiDBClusterInfo(ctx sessionctx.Context) error
        - setDataFromKeyColumnUsage(ctx sessionctx.Context, schemas []*model.DBInfo) 
        - setDataForClusterProcessList(ctx sessionctx.Context) error
        - setDataForProcessList(ctx sessionctx.Context) 
        - setDataFromUserPrivileges(ctx sessionctx.Context) 
        - setDataForMetricTables(ctx sessionctx.Context) 
        - setDataForTikVRegionPeers(ctx sessionctx.Context) error
        - setNewTiKVRegionPeersCols(region *helper.RegionInfo) 
        - setDataForTiDBHotRegions(ctx sessionctx.Context) error
        - setDataForHotRegionByMetrics(metrics []helper.HotTableIndex, tp string) 
        - setDataFromTableConstraints(ctx sessionctx.Context, schemas []*model.DBInfo) 
        - setDataFromSessionVar(ctx sessionctx.Context) error
        - setDataForAnalyzeStatus(sctx sessionctx.Context) 
        - setDataForPseudoProfiling(sctx sessionctx.Context) 
        - setDataForServersInfo() error
        - setDataFromSequences(ctx sessionctx.Context, schemas []*model.DBInfo) 
        - dataForTableTiFlashReplica(ctx sessionctx.Context, schemas []*model.DBInfo) 
        - setDataForStatementsSummary(ctx sessionctx.Context, tableName string) error

    }
    class mergeJoinTable << (S,Aquamarine) >> {
        - isInner bool
        - childIndex int
        - joinKeys []*expression.Column
        - filters []expression.Expression
        - executed bool
        - childChunk *chunk.Chunk
        - childChunkIter *chunk.Iterator4Chunk
        - groupChecker *vecGroupChecker
        - groupRowsSelected []int
        - groupRowsIter chunk.Iterator
        - rowContainer *chunk.RowContainer
        - filtersSelected []bool
        - memTracker *memory.Tracker

        - init(exec *MergeJoinExec) 
        - finish() error
        - selectNextGroup() 
        - fetchNextChunk(ctx context.Context, exec *MergeJoinExec) error
        - fetchNextInnerGroup(ctx context.Context, exec *MergeJoinExec) error
        - fetchNextOuterGroup(ctx context.Context, exec *MergeJoinExec, requiredRows int) error
        - hasNullInJoinKey(row chunk.Row) bool

    }
    class mockPhysicalIndexReader << (S,Aquamarine) >> {
        - e Executor

    }
    class multiWayMerge << (S,Aquamarine) >> {
        - lessRowFunction <font color=blue>func</font>(chunk.Row, chunk.Row) bool
        - elements []partitionPointer

        + Less(i int, j int) bool
        + Len() int
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}
        + Swap(i int, j int) 

    }
    class nodeLoadInspection << (S,Aquamarine) >> {
        - inspect(ctx context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult

    }
    class outerCtx << (S,Aquamarine) >> {
        - rowTypes []*types.FieldType
        - keyCols []int
        - filter expression.CNFExprs

    }
    class outerMergeCtx << (S,Aquamarine) >> {
        - rowTypes []*types.FieldType
        - joinKeys []*expression.Column
        - keyCols []int
        - filter expression.CNFExprs
        - needOuterSort bool
        - compareFuncs []expression.CompareFunc

    }
    class outerMergeWorker << (S,Aquamarine) >> {
        - lookup *IndexLookUpMergeJoin
        - ctx sessionctx.Context
        - executor Executor
        - maxBatchSize int
        - batchSize int
        - nextColCompareFilters *core.ColWithCmpFuncManager
        - resultCh <font color=blue>chan</font> *lookUpMergeJoinTask
        - innerCh <font color=blue>chan</font> *lookUpMergeJoinTask
        - parentMemTracker *memory.Tracker

        - run(ctx context.Context, wg *sync.WaitGroup, cancelFunc context.CancelFunc) 
        - pushToChan(ctx context.Context, task *lookUpMergeJoinTask, dst <font color=blue>chan</font> *lookUpMergeJoinTask) bool
        - buildTask(ctx context.Context) (*lookUpMergeJoinTask, error)
        - increaseBatchSize() 

    }
    class outerWorker << (S,Aquamarine) >> {
        - lookup *IndexLookUpJoin
        - ctx sessionctx.Context
        - executor Executor
        - maxBatchSize int
        - batchSize int
        - resultCh <font color=blue>chan</font> *lookUpJoinTask
        - innerCh <font color=blue>chan</font> *lookUpJoinTask
        - parentMemTracker *memory.Tracker

        - run(ctx context.Context, wg *sync.WaitGroup) 
        - pushToChan(ctx context.Context, task *lookUpJoinTask, dst <font color=blue>chan</font> *lookUpJoinTask) bool
        - buildTask(ctx context.Context) (*lookUpJoinTask, error)
        - increaseBatchSize() 

    }
    class paramMarkerExtractor << (S,Aquamarine) >> {
        - markers []ast.ParamMarkerExpr

        + Enter(in ast.Node) (ast.Node, bool)
        + Leave(in ast.Node) (ast.Node, bool)

    }
    class paramMarkerSorter << (S,Aquamarine) >> {
        - markers []ast.ParamMarkerExpr

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class parsedSlowLog << (S,Aquamarine) >> {
        - rows [][]types.Datum
        - err error

    }
    class partialIndexWorker << (S,Aquamarine) >> {
        - batchSize int
        - maxBatchSize int
        - maxChunkSize int

        - fetchHandles(ctx context.Context, result distsql.SelectResult, exitCh <font color=blue>chan</font> <font color=blue>struct</font>{}, fetchCh <font color=blue>chan</font> *lookupTableTask, resultCh <font color=blue>chan</font> *lookupTableTask, finished <font color=blue>chan</font> <font color=blue>struct</font>{}) (int64, error)
        - extractTaskHandles(ctx context.Context, chk *chunk.Chunk, idxResult distsql.SelectResult) ([]int64, *chunk.Chunk, error)
        - buildTableTask(handles []int64, retChk *chunk.Chunk) *lookupTableTask

    }
    class partialTableWorker << (S,Aquamarine) >> {
        - batchSize int
        - maxBatchSize int
        - maxChunkSize int
        - tableReader Executor
        - tableInfo *model.TableInfo

        - fetchHandles(ctx context.Context, exitCh <font color=blue>chan</font> <font color=blue>struct</font>{}, fetchCh <font color=blue>chan</font> *lookupTableTask, resultCh <font color=blue>chan</font> *lookupTableTask, finished <font color=blue>chan</font> <font color=blue>struct</font>{}) (int64, error)
        - extractTaskHandles(ctx context.Context, chk *chunk.Chunk, handleOffset int) ([]int64, *chunk.Chunk, error)
        - buildTableTask(handles []int64, retChk *chunk.Chunk) *lookupTableTask

    }
    class partitionHashSplitter << (S,Aquamarine) >> {
        - byItems []expression.Expression
        - numWorkers int
        - hashKeys [][]byte

        - split(ctx sessionctx.Context, input *chunk.Chunk, workerIndices []int) ([]int, error)

    }
    class partitionPointer << (S,Aquamarine) >> {
        - row chunk.Row
        - partitionID int
        - consumed int

    }
    interface partitionSplitter  {
        - split(ctx sessionctx.Context, input *chunk.Chunk, workerIndices []int) ([]int, error)

    }
    interface pessimisticTxn  {
        + KeysNeedToLock() ([]kv.Key, error)

    }
    class probeChkResource << (S,Aquamarine) >> {
        - chk *chunk.Chunk
        - dest <font color=blue>chan</font> *chunk.Chunk

    }
    interface processinfoSetter  {
        + SetProcessInfo( string,  time.Time,  byte,  uint64) 

    }
    class projectionInput << (S,Aquamarine) >> {
        - chk *chunk.Chunk
        - targetWorker *projectionWorker

    }
    class projectionInputFetcher << (S,Aquamarine) >> {
        - proj *ProjectionExec
        - child Executor
        - globalFinishCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - globalOutputCh <font color=blue>chan</font> *projectionOutput
        - wg sync.WaitGroup
        - inputCh <font color=blue>chan</font> *projectionInput
        - outputCh <font color=blue>chan</font> *projectionOutput

        - run(ctx context.Context) 

    }
    class projectionOutput << (S,Aquamarine) >> {
        - chk *chunk.Chunk
        - done <font color=blue>chan</font> error

    }
    class projectionWorker << (S,Aquamarine) >> {
        - proj *ProjectionExec
        - sctx sessionctx.Context
        - evaluatorSuit *expression.EvaluatorSuite
        - globalFinishCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - inputGiveBackCh <font color=blue>chan</font> *projectionInput
        - inputCh <font color=blue>chan</font> *projectionInput
        - outputCh <font color=blue>chan</font> *projectionOutput

        - run(ctx context.Context) 

    }
    class rangeFrameWindowProcessor << (S,Aquamarine) >> {
        - windowFuncs []aggfuncs.AggFunc
        - partialResults []aggfuncs.PartialResult
        - start *core.FrameBound
        - end *core.FrameBound
        - curRowIdx uint64
        - lastStartOffset uint64
        - lastEndOffset uint64
        - orderByCols []*expression.Column
        - expectedCmpResult int64

        - getStartOffset(ctx sessionctx.Context, rows []chunk.Row) (uint64, error)
        - getEndOffset(ctx sessionctx.Context, rows []chunk.Row) (uint64, error)
        - appendResult2Chunk(ctx sessionctx.Context, rows []chunk.Row, chk *chunk.Chunk, remained int) ([]chunk.Row, error)
        - consumeGroupRows(ctx sessionctx.Context, rows []chunk.Row) ([]chunk.Row, error)
        - resetPartialResult() 

    }
    class recordSet << (S,Aquamarine) >> {
        - fields []*ast.ResultField
        - executor Executor
        - stmt *ExecStmt
        - lastErr error
        - txnStartTS uint64

        + Fields() []*ast.ResultField
        + Next(ctx context.Context, req *chunk.Chunk) error
        + NewChunk() *chunk.Chunk
        + Close() error
        + OnFetchReturned() 

    }
    class recoverRows << (S,Aquamarine) >> {
        - handle int64
        - idxVals []types.Datum
        - skip bool

    }
    class regionKeyDecoder << (S,Aquamarine) >> {
        - physicalTableID int64
        - tablePrefix []byte
        - recordPrefix []byte
        - indexPrefix []byte
        - indexID int64

        - decodeRegionKey(key []byte) string

    }
    class regionMeta << (S,Aquamarine) >> {
        - region *metapb.Region
        - leaderID uint64
        - storeID uint64
        - start string
        - end string
        - scattering bool
        - writtenBytes int64
        - readBytes int64
        - approximateSize int64
        - approximateKeys int64

    }
    class rightOuterJoiner << (S,Aquamarine) >> {
        - tryToMatchInners(outer chunk.Row, inners chunk.Iterator, chk *chunk.Chunk) (bool, bool, error)
        - tryToMatchOuters(outers chunk.Iterator, inner chunk.Row, chk *chunk.Chunk, outerRowStatus []outerRowStatusFlag) ([]outerRowStatusFlag, error)
        - onMissMatch(_ bool, outer chunk.Row, chk *chunk.Chunk) 

        + Clone() joiner

    }
    class rowFrameWindowProcessor << (S,Aquamarine) >> {
        - windowFuncs []aggfuncs.AggFunc
        - partialResults []aggfuncs.PartialResult
        - start *core.FrameBound
        - end *core.FrameBound
        - curRowIdx uint64

        - getStartOffset(numRows uint64) uint64
        - getEndOffset(numRows uint64) uint64
        - consumeGroupRows(ctx sessionctx.Context, rows []chunk.Row) ([]chunk.Row, error)
        - appendResult2Chunk(ctx sessionctx.Context, rows []chunk.Row, chk *chunk.Chunk, remained int) ([]chunk.Row, error)
        - resetPartialResult() 

    }
    class rowHashMap << (S,Aquamarine) >> {
        - entryStore entryStore
        - hashTable <font color=blue>map</font>[uint64]entryAddr
        - length int

        + Put(hashKey uint64, rowPtr chunk.RowPtr) 
        + Get(hashKey uint64) []chunk.RowPtr
        + Len() int

    }
    interface ruleChecker  {
        - genSQL(timeRange core.QueryTimeRange) string
        - genResult(sql string, row chunk.Row) inspectionResult
        - getItem() string

    }
    class selectResultHook << (S,Aquamarine) >> {
        - selectResultFunc <font color=blue>func</font>(context.Context, sessionctx.Context, *kv.Request, []*types.FieldType, *statistics.QueryFeedback, []fmt.Stringer) (distsql.SelectResult, error)

        + SelectResult(ctx context.Context, sctx sessionctx.Context, kvReq *kv.Request, fieldTypes []*types.FieldType, fb *statistics.QueryFeedback, copPlanIDs []fmt.Stringer, rootPlanID fmt.Stringer) (distsql.SelectResult, error)

    }
    class semiJoiner << (S,Aquamarine) >> {
        - tryToMatchInners(outer chunk.Row, inners chunk.Iterator, chk *chunk.Chunk) (bool, bool, error)
        - tryToMatchOuters(outers chunk.Iterator, inner chunk.Row, chk *chunk.Chunk, outerRowStatus []outerRowStatusFlag) ([]outerRowStatusFlag, error)
        - onMissMatch(_ bool, outer chunk.Row, chk *chunk.Chunk) 

        + Clone() joiner

    }
    class shuffleOutput << (S,Aquamarine) >> {
        - chk *chunk.Chunk
        - err error
        - giveBackCh <font color=blue>chan</font> *chunk.Chunk

    }
    class shuffleWorker << (S,Aquamarine) >> {
        - childExec Executor
        - finishCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - executed bool
        - inputCh <font color=blue>chan</font> *chunk.Chunk
        - inputHolderCh <font color=blue>chan</font> *chunk.Chunk
        - outputCh <font color=blue>chan</font> *shuffleOutput
        - outputHolderCh <font color=blue>chan</font> *chunk.Chunk

        - run(ctx context.Context, waitGroup *sync.WaitGroup) 

        + Open(ctx context.Context) error
        + Close() error
        + Next(ctx context.Context, req *chunk.Chunk) error

    }
    class slowLogChecker << (S,Aquamarine) >> {
        - hasProcessPriv bool
        - user *auth.UserIdentity
        - enableTimeCheck bool
        - startTime types.Time
        - endTime types.Time

        - hasPrivilege(userName string) bool
        - isTimeValid(t types.Time) bool

    }
    class slowQueryRetriever << (S,Aquamarine) >> {
        - table *model.TableInfo
        - outputCols []*model.ColumnInfo
        - initialized bool
        - extractor *core.SlowQueryExtractor
        - files []logFile
        - fileIdx int
        - fileLine int
        - checker *slowLogChecker
        - parsedSlowLogCh <font color=blue>chan</font> parsedSlowLog

        - retrieve(ctx context.Context, sctx sessionctx.Context) ([][]types.Datum, error)
        - initialize(sctx sessionctx.Context) error
        - close() error
        - parseDataForSlowLog(ctx context.Context, sctx sessionctx.Context) 
        - dataForSlowLog(ctx context.Context) ([][]types.Datum, bool, error)
        - parseSlowLog(ctx sessionctx.Context, reader *bufio.Reader, maxRow int) ([][]types.Datum, error)
        - getAllFiles(sctx sessionctx.Context, logFilePath string) ([]logFile, error)
        - getFileStartTime(file *os.File) (time.Time, error)
        - getFileEndTime(file *os.File) (time.Time, error)
        - initializeAsyncParsing(ctx context.Context, sctx sessionctx.Context) 

    }
    class slowQueryTuple << (S,Aquamarine) >> {
        - time types.Time
        - txnStartTs uint64
        - user string
        - host string
        - connID uint64
        - queryTime float64
        - parseTime float64
        - compileTime float64
        - preWriteTime float64
        - waitPrewriteBinlogTime float64
        - commitTime float64
        - getCommitTSTime float64
        - commitBackoffTime float64
        - backoffTypes string
        - resolveLockTime float64
        - localLatchWaitTime float64
        - writeKeys uint64
        - writeSize uint64
        - prewriteRegion uint64
        - txnRetry uint64
        - copTime float64
        - processTime float64
        - waitTime float64
        - backOffTime float64
        - lockKeysTime float64
        - requestCount uint64
        - totalKeys uint64
        - processKeys uint64
        - db string
        - indexIDs string
        - digest string
        - statsInfo string
        - avgProcessTime float64
        - p90ProcessTime float64
        - maxProcessTime float64
        - maxProcessAddress string
        - avgWaitTime float64
        - p90WaitTime float64
        - maxWaitTime float64
        - maxWaitAddress string
        - memMax int64
        - diskMax int64
        - prevStmt string
        - sql string
        - isInternal bool
        - succ bool
        - planFromCache bool
        - plan string
        - planDigest string

        - setFieldValue(tz *time.Location, field string, value string, lineNum int, checker *slowLogChecker) (bool, error)
        - convertToDatumRow() []types.Datum

    }
    class splitRegionResult << (S,Aquamarine) >> {
        - splitRegions int
        - finishScatterNum int

    }
    class statsCache << (S,Aquamarine) >> {
        - mu sync.RWMutex
        - modifyTime time.Time
        - tableRows <font color=blue>map</font>[int64]uint64
        - colLength <font color=blue>map</font>[tableHistID]uint64

        - get(ctx sessionctx.Context) (<font color=blue>map</font>[int64]uint64, <font color=blue>map</font>[tableHistID]uint64, error)

    }
    class tableHistID << (S,Aquamarine) >> {
        - tableID int64
        - histID int64

    }
    class tableResultHandler << (S,Aquamarine) >> {
        - optionalResult distsql.SelectResult
        - result distsql.SelectResult
        - optionalFinished bool

        - open(optionalResult distsql.SelectResult, result distsql.SelectResult) 
        - nextChunk(ctx context.Context, chk *chunk.Chunk) error
        - nextRaw(ctx context.Context) ([]byte, error)

        + Close() error

    }
    class tableWorker << (S,Aquamarine) >> {
        - idxLookup *IndexLookUpExecutor
        - workCh <font color=blue>chan</font> *lookupTableTask
        - finished <font color=blue>chan</font> <font color=blue>struct</font>{}
        - buildTblReader <font color=blue>func</font>(context.Context, []int64) (Executor, error)
        - keepOrder bool
        - handleIdx int
        - memTracker *memory.Tracker

        - pickAndExecTask(ctx context.Context) 
        - compareData(ctx context.Context, task *lookupTableTask, tableReader Executor) error
        - executeTask(ctx context.Context, task *lookupTableTask) error

    }
    class thresholdCheckInspection << (S,Aquamarine) >> {
        - inspect(ctx context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult
        - inspectThreshold1(ctx context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult
        - inspectThreshold2(ctx context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult
        - inspectThreshold3(ctx context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult
        - inspectForLeaderDrop(ctx context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult

    }
    class tidbGlueSession << (S,Aquamarine) >> {
        - se sessionctx.Context
        - progress *brieTaskProgress
        - info *brieTaskInfo

        + GetDomain(store kv.Storage) (*domain.Domain, error)
        + CreateSession(store kv.Storage) (glue.Session, error)
        + Execute(ctx context.Context, sql string) error
        + CreateDatabase(ctx context.Context, schema *model.DBInfo) error
        + CreateTable(ctx context.Context, dbName model.CIStr, table *model.TableInfo) error
        + Close() 
        + Open( string,  client.SecurityOption) (kv.Storage, error)
        + OwnsStorage() bool
        + StartProgress(ctx context.Context, cmdName string, total int64, redirectLog bool) glue.Progress
        + Record(name string, value uint64) 

    }
    class toBeCheckedRow << (S,Aquamarine) >> {
        - row []types.Datum
        - rowValue []byte
        - handleKey *keyValueWithDupInfo
        - uniqueKeys []*keyValueWithDupInfo
        - t table.Table

    }
    class topNChunkHeap << (S,Aquamarine) >> {
        - greaterRow(rowI chunk.Row, rowJ chunk.Row) bool

        + Less(i int, j int) bool
        + Len() int
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}
        + Swap(i int, j int) 

    }
    class unionWorkerResult << (S,Aquamarine) >> {
        - chk *chunk.Chunk
        - err error
        - src <font color=blue>chan</font> *chunk.Chunk

    }
    class vecGroupChecker << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - groupOffset []int
        - groupCount int
        - nextGroupID int
        - lastGroupKeyOfPrevChk []byte
        - firstGroupKey []byte
        - lastGroupKey []byte
        - firstRowDatums []types.Datum
        - lastRowDatums []types.Datum
        - sameGroup []bool
        - allocateBuffer <font color=blue>func</font>(types.EvalType, int) (*chunk.Column, error)
        - releaseBuffer <font color=blue>func</font>(*chunk.Column) 

        + GroupByItems []expression.Expression

        - splitIntoGroups(chk *chunk.Chunk) (bool, error)
        - evalGroupItemsAndResolveGroups(item expression.Expression, chk *chunk.Chunk, numRows int) error
        - getNextGroup() int
        - isExhausted() bool
        - reset() 

    }
    class versionInspection << (S,Aquamarine) >> {
        - inspect(_ context.Context, sctx sessionctx.Context, filter inspectionFilter) []inspectionResult

    }
    class visibleChecker << (S,Aquamarine) >> {
        - defaultDB string
        - ctx sessionctx.Context
        - is infoschema.InfoSchema
        - manager privilege.Manager
        - ok bool

        + Enter(in ast.Node) (ast.Node, bool)
        + Leave(in ast.Node) (ast.Node, bool)

    }
    interface windowProcessor  {
        - consumeGroupRows(ctx sessionctx.Context, rows []chunk.Row) ([]chunk.Row, error)
        - appendResult2Chunk(ctx sessionctx.Context, rows []chunk.Row, chk *chunk.Chunk, remained int) ([]chunk.Row, error)
        - resetPartialResult() 

    }
    class "<font color=blue>func</font>() ([][]types.Datum, error)" as fontcolorbluefuncfonttypesDatumerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "v1.Range" as v1Range {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>map</font>[int64]<font color=blue>map</font>[int64][]types.Datum" as fontcolorbluemapfontint64fontcolorbluemapfontint64typesDatum {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>map</font>[string][]aggfuncs.PartialResult" as fontcolorbluemapfontstringaggfuncsPartialResult {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"executor.baseExecutor" *-- "executor.AdminPluginsExec"
"executor.baseExecutor" *-- "executor.AdminResetTelemetryIDExec"
"executor.baseExecutor" *-- "executor.AdminShowTelemetryExec"
"executor.baseExecutor" *-- "executor.AnalyzeExec"
"executor.AnalyzeFastExec" *-- "executor.AnalyzeTestFastExec"
"executor.baseExecutor" *-- "executor.BRIEExec"
"executor.baseExecutor" *-- "executor.BatchPointGetExec"
"executor.baseExecutor" *-- "executor.CancelDDLJobsExec"
"ast.ChangeStmt" *-- "executor.ChangeExec"
"executor.baseExecutor" *-- "executor.ChangeExec"
"executor.baseExecutor" *-- "executor.CheckIndexRangeExec"
"executor.baseExecutor" *-- "executor.CheckTableExec"
"executor.baseExecutor" *-- "executor.ChecksumTableExec"
"executor.baseExecutor" *-- "executor.CleanupIndexExec"
"executor.baseExecutor" *-- "executor.DDLExec"
"executor.DDLJobRetriever" *-- "executor.DDLJobsReaderExec"
"executor.baseExecutor" *-- "executor.DDLJobsReaderExec"
"executor.baseExecutor" *-- "executor.DeallocateExec"
"executor.baseExecutor" *-- "executor.DeleteExec"
"sync.Mutex" *-- "executor.DirtyDB"
"executor.baseExecutor" *-- "executor.ExecuteExec"
"executor.baseExecutor" *-- "executor.ExplainExec"
"executor.baseExecutor" *-- "executor.GrantExec"
"executor.baseExecutor" *-- "executor.HashAggExec"
"executor.baseHashAggWorker" *-- "executor.HashAggFinalWorker"
"executor.baseHashAggWorker" *-- "executor.HashAggPartialWorker"
"executor.baseExecutor" *-- "executor.HashJoinExec"
"executor.baseExecutor" *-- "executor.IndexAdviseExec"
"executor.baseExecutor" *-- "executor.IndexLookUpExecutor"
"executor.checkIndexValue" *-- "executor.IndexLookUpExecutor"
"executor.dataReaderBuilder" *-- "executor.IndexLookUpExecutor"
"executor.baseExecutor" *-- "executor.IndexLookUpJoin"
"executor.baseExecutor" *-- "executor.IndexLookUpMergeJoin"
"executor.baseExecutor" *-- "executor.IndexMergeReaderExecutor"
"executor.checkIndexValue" *-- "executor.IndexMergeReaderExecutor"
"executor.dataReaderBuilder" *-- "executor.IndexMergeReaderExecutor"
"executor.IndexLookUpJoin" *-- "executor.IndexNestedLoopHashJoin"
"executor.baseExecutor" *-- "executor.IndexReaderExecutor"
"executor.selectResultHook" *-- "executor.IndexReaderExecutor"
"executor.InsertValues" *-- "executor.InsertExec"
"executor.baseExecutor" *-- "executor.InsertValues"
"executor.baseExecutor" *-- "executor.LimitExec"
"executor.baseExecutor" *-- "executor.LoadDataExec"
"executor.InsertValues" *-- "executor.LoadDataInfo"
"executor.baseExecutor" *-- "executor.LoadStatsExec"
"executor.baseExecutor" *-- "executor.MaxOneRowExec"
"executor.baseExecutor" *-- "executor.MemTableReaderExec"
"executor.baseExecutor" *-- "executor.MergeJoinExec"
"executor.dummyCloser" *-- "executor.MetricRetriever"
"executor.dummyCloser" *-- "executor.MetricsSummaryByLabelRetriever"
"executor.dummyCloser" *-- "executor.MetricsSummaryRetriever"
"executor.baseExecutor" *-- "executor.NestedLoopApplyExec"
"executor.baseExecutor" *-- "executor.PointGetExecutor"
"executor.baseExecutor" *-- "executor.PrepareExec"
"executor.baseExecutor" *-- "executor.ProjectionExec"
"executor.baseExecutor" *-- "executor.RecoverIndexExec"
"executor.baseExecutor" *-- "executor.ReloadExprPushdownBlacklistExec"
"executor.baseExecutor" *-- "executor.ReloadOptRuleBlacklistExec"
"executor.InsertValues" *-- "executor.ReplaceExec"
"executor.baseExecutor" *-- "executor.RevokeExec"
"executor.baseExecutor" *-- "executor.SQLBindExec"
"executor.baseExecutor" *-- "executor.SelectIntoExec"
"executor.baseExecutor" *-- "executor.SelectLockExec"
"executor.baseExecutor" *-- "executor.SelectionExec"
"executor.baseExecutor" *-- "executor.SetConfigExec"
"executor.baseExecutor" *-- "executor.SetExecutor"
"executor.baseExecutor" *-- "executor.ShowDDLExec"
"executor.baseExecutor" *-- "executor.ShowDDLJobQueriesExec"
"executor.DDLJobRetriever" *-- "executor.ShowDDLJobsExec"
"executor.baseExecutor" *-- "executor.ShowDDLJobsExec"
"executor.baseExecutor" *-- "executor.ShowExec"
"executor.baseExecutor" *-- "executor.ShowNextRowIDExec"
"executor.baseExecutor" *-- "executor.ShowSlowExec"
"executor.baseExecutor" *-- "executor.ShuffleExec"
"executor.baseExecutor" *-- "executor.SimpleExec"
"executor.baseExecutor" *-- "executor.SortExec"
"executor.baseExecutor" *-- "executor.SplitIndexRegionExec"
"executor.splitRegionResult" *-- "executor.SplitIndexRegionExec"
"executor.baseExecutor" *-- "executor.SplitTableRegionExec"
"executor.splitRegionResult" *-- "executor.SplitTableRegionExec"
"executor.baseExecutor" *-- "executor.StreamAggExec"
"executor.baseExecutor" *-- "executor.TableDualExec"
"executor.baseExecutor" *-- "executor.TableReaderExecutor"
"executor.selectResultHook" *-- "executor.TableReaderExecutor"
"executor.baseExecutor" *-- "executor.TableScanExec"
"executor.SortExec" *-- "executor.TopNExec"
"executor.baseExecutor" *-- "executor.TraceExec"
"executor.baseExecutor" *-- "executor.UnionExec"
"executor.baseExecutor" *-- "executor.UnionScanExec"
"executor.baseExecutor" *-- "executor.UpdateExec"
"executor.baseExecutor" *-- "executor.WindowExec"
"executor.AnalyzeIndexExec" *-- "executor.analyzeIndexIncrementalExec"
"executor.AnalyzeColumnsExec" *-- "executor.analyzePKIncrementalExec"
"executor.baseJoiner" *-- "executor.antiLeftOuterSemiJoiner"
"executor.baseJoiner" *-- "executor.antiSemiJoiner"
"executor.dummyCloser" *-- "executor.clusterConfigRetriever"
"executor.dummyCloser" *-- "executor.clusterServerInfoRetriever"
"executor.inspectionName" *-- "executor.configInspection"
"core.Plan" *-- "executor.dataReaderBuilder"
"executor.executorBuilder" *-- "executor.dataReaderBuilder"
"executor.selectResultHook" *-- "executor.dataReaderBuilder"
"executor.innerWorker" *-- "executor.indexHashJoinInnerWorker"
"executor.outerWorker" *-- "executor.indexHashJoinOuterWorker"
"executor.lookUpJoinTask" *-- "executor.indexHashJoinTask"
"executor.checkIndexValue" *-- "executor.indexWorker"
"executor.baseJoiner" *-- "executor.innerJoiner"
"executor.innerMergeCtx" *-- "executor.innerMergeWorker"
"executor.innerCtx" *-- "executor.innerWorker"
"executor.dummyCloser" *-- "executor.inspectionResultRetriever"
"executor.dummyCloser" *-- "executor.inspectionRuleRetriever"
"executor.dummyCloser" *-- "executor.inspectionSummaryRetriever"
"executor.baseJoiner" *-- "executor.leftOuterJoiner"
"executor.baseJoiner" *-- "executor.leftOuterSemiJoiner"
"executor.dummyCloser" *-- "executor.memtableRetriever"
"core.PhysicalPlan" *-- "executor.mockPhysicalIndexReader"
"executor.outerMergeCtx" *-- "executor.outerMergeWorker"
"executor.outerCtx" *-- "executor.outerWorker"
"executor.baseJoiner" *-- "executor.rightOuterJoiner"
"executor.baseJoiner" *-- "executor.semiJoiner"
"executor.baseExecutor" *-- "executor.shuffleWorker"
"executor.checkIndexValue" *-- "executor.tableWorker"
"executor.TopNExec" *-- "executor.topNChunkHeap"

"executor.Closeable" <|-- "executor.BatchPointGetExec"
"executor.Closeable" <|-- "executor.CheckIndexRangeExec"
"executor.Closeable" <|-- "executor.CheckTableExec"
"executor.Closeable" <|-- "executor.CleanupIndexExec"
"executor.Closeable" <|-- "executor.DeleteExec"
"sqlexec.Statement" <|-- "executor.ExecStmt"
"executor.Closeable" <|-- "executor.ExplainExec"
"executor.Closeable" <|-- "executor.HashAggExec"
"executor.Closeable" <|-- "executor.HashJoinExec"
"executor.Closeable" <|-- "executor.IndexAdviseExec"
"executor.Closeable" <|-- "executor.IndexLookUpExecutor"
"executor.Closeable" <|-- "executor.IndexLookUpJoin"
"executor.Closeable" <|-- "executor.IndexLookUpMergeJoin"
"executor.Closeable" <|-- "executor.IndexMergeReaderExecutor"
"executor.Closeable" <|-- "executor.IndexNestedLoopHashJoin"
"executor.Closeable" <|-- "executor.IndexReaderExecutor"
"executor.Closeable" <|-- "executor.InsertExec"
"executor.insertCommon" <|-- "executor.InsertValues"
"executor.Closeable" <|-- "executor.LimitExec"
"executor.Closeable" <|-- "executor.LoadDataExec"
"executor.Closeable" <|-- "executor.LoadStatsExec"
"executor.Closeable" <|-- "executor.MemTableReaderExec"
"executor.Closeable" <|-- "executor.MergeJoinExec"
"executor.Closeable" <|-- "executor.NestedLoopApplyExec"
"kv.Getter" <|-- "executor.PessimisticLockCacheGetter"
"executor.Closeable" <|-- "executor.PointGetExecutor"
"executor.Closeable" <|-- "executor.ProjectionExec"
"executor.Closeable" <|-- "executor.ReplaceExec"
"executor.Closeable" <|-- "executor.SelectIntoExec"
"executor.Closeable" <|-- "executor.SelectionExec"
"executor.Closeable" <|-- "executor.ShuffleExec"
"executor.Closeable" <|-- "executor.SortExec"
"executor.Closeable" <|-- "executor.StreamAggExec"
"executor.Closeable" <|-- "executor.TableReaderExecutor"
"executor.Closeable" <|-- "executor.UnionExec"
"executor.Closeable" <|-- "executor.UpdateExec"
"executor.Closeable" <|-- "executor.WindowExec"
"executor.windowProcessor" <|-- "executor.aggWindowProcessor"
"executor.joiner" <|-- "executor.antiLeftOuterSemiJoiner"
"executor.joiner" <|-- "executor.antiSemiJoiner"
"executor.Closeable" <|-- "executor.baseExecutor"
"executor.Executor" <|-- "executor.baseExecutor"
"executor.ruleChecker" <|-- "executor.checkRegionHealth"
"executor.ruleChecker" <|-- "executor.checkStoreRegionTooMuch"
"executor.Closeable" <|-- "executor.chunkRowRecordSet"
"executor.memTableRetriever" <|-- "executor.clusterLogRetriever"
"executor.ruleChecker" <|-- "executor.compareStoreStatus"
"memory.ActionOnExceed" <|-- "executor.globalPanicOnExceed"
"executor.Closeable" <|-- "executor.hashRowContainer"
"executor.joiner" <|-- "executor.innerJoiner"
"executor.ruleChecker" <|-- "executor.inspectCPULoad"
"executor.ruleChecker" <|-- "executor.inspectDiskUsage"
"executor.ruleChecker" <|-- "executor.inspectSwapMemoryUsed"
"executor.ruleChecker" <|-- "executor.inspectVirtualMemUsage"
"executor.joiner" <|-- "executor.leftOuterJoiner"
"executor.joiner" <|-- "executor.leftOuterSemiJoiner"
"executor.partitionSplitter" <|-- "executor.partitionHashSplitter"
"executor.windowProcessor" <|-- "executor.rangeFrameWindowProcessor"
"executor.Closeable" <|-- "executor.recordSet"
"server.fetchNotifier" <|-- "executor.recordSet"
"executor.joiner" <|-- "executor.rightOuterJoiner"
"executor.windowProcessor" <|-- "executor.rowFrameWindowProcessor"
"executor.joiner" <|-- "executor.semiJoiner"
"executor.Closeable" <|-- "executor.shuffleWorker"
"executor.memTableRetriever" <|-- "executor.slowQueryRetriever"
"executor.Closeable" <|-- "executor.tableResultHandler"

namespace expensivequery {
    class Handle << (S,Aquamarine) >> {
        - exitCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - sm atomic.Value

        + SetSessionManager(sm util.SessionManager) *Handle
        + Run() 
        + LogOnQueryExceedMemQuota(connID uint64) 

    }
}


namespace expression {
    class Assignment << (S,Aquamarine) >> {
        + Col *Column
        + ColName model.CIStr
        + Expr Expression

    }
    class CNFExprs << (S,Aquamarine) >> {
        + Clone() CNFExprs
        + Shallow() CNFExprs

    }
    interface CollationInfo  {
        + HasCoercibility() bool
        + Coercibility() Coercibility
        + SetCoercibility(val Coercibility) 
        + CharsetAndCollation(ctx sessionctx.Context) (string, string)
        + SetCharsetAndCollation(chs string, coll string) 

    }
    class Column << (S,Aquamarine) >> {
        - hashcode []byte

        + RetType *types.FieldType
        + ID int64
        + UniqueID int64
        + Index int
        + VirtualExpr Expression
        + OrigName string
        + IsHidden bool
        + InOperand bool

        - resolveIndices(schema *Schema) error

        + Equal(_ sessionctx.Context, expr Expression) bool
        + VecEvalInt(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalReal(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalString(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalDecimal(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalTime(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalDuration(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalJSON(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + String() string
        + MarshalJSON() ([]byte, error)
        + GetType() *types.FieldType
        + Eval(row chunk.Row) (types.Datum, error)
        + EvalInt(ctx sessionctx.Context, row chunk.Row) (int64, bool, error)
        + EvalReal(ctx sessionctx.Context, row chunk.Row) (float64, bool, error)
        + EvalString(ctx sessionctx.Context, row chunk.Row) (string, bool, error)
        + EvalDecimal(ctx sessionctx.Context, row chunk.Row) (*types.MyDecimal, bool, error)
        + EvalTime(ctx sessionctx.Context, row chunk.Row) (types.Time, bool, error)
        + EvalDuration(ctx sessionctx.Context, row chunk.Row) (types.Duration, bool, error)
        + EvalJSON(ctx sessionctx.Context, row chunk.Row) (json.BinaryJSON, bool, error)
        + Clone() Expression
        + IsCorrelated() bool
        + ConstItem(_ *stmtctx.StatementContext) bool
        + Decorrelate(_ *Schema) Expression
        + HashCode(_ *stmtctx.StatementContext) []byte
        + ResolveIndices(schema *Schema) (Expression, error)
        + Vectorized() bool
        + ToInfo() *model.ColumnInfo
        + EvalVirtualColumn(row chunk.Row) (types.Datum, error)
        + SupportReverseEval() bool
        + ReverseEval(sc *stmtctx.StatementContext, res types.Datum, rType types.RoundingType) (types.Datum, error)
        + Coercibility() Coercibility
        + ExplainInfo() string
        + ExplainNormalizedInfo() string

    }
    class Constant << (S,Aquamarine) >> {
        - hashcode []byte

        + Value types.Datum
        + RetType *types.FieldType
        + DeferredExpr Expression
        + ParamMarker *ParamMarker

        - getLazyDatum(row chunk.Row) (types.Datum, bool, error)
        - resolveIndices(_ *Schema) error
        - format(dt types.Datum) string

        + String() string
        + MarshalJSON() ([]byte, error)
        + Clone() Expression
        + GetType() *types.FieldType
        + VecEvalInt(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalReal(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalString(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalDecimal(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalTime(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalDuration(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalJSON(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + Eval(row chunk.Row) (types.Datum, error)
        + EvalInt(ctx sessionctx.Context, row chunk.Row) (int64, bool, error)
        + EvalReal(ctx sessionctx.Context, row chunk.Row) (float64, bool, error)
        + EvalString(ctx sessionctx.Context, row chunk.Row) (string, bool, error)
        + EvalDecimal(ctx sessionctx.Context, row chunk.Row) (*types.MyDecimal, bool, error)
        + EvalTime(ctx sessionctx.Context, row chunk.Row) (types.Time, bool, error)
        + EvalDuration(ctx sessionctx.Context, row chunk.Row) (types.Duration, bool, error)
        + EvalJSON(ctx sessionctx.Context, row chunk.Row) (json.BinaryJSON, bool, error)
        + Equal(ctx sessionctx.Context, b Expression) bool
        + IsCorrelated() bool
        + ConstItem(sc *stmtctx.StatementContext) bool
        + Decorrelate(_ *Schema) Expression
        + HashCode(sc *stmtctx.StatementContext) []byte
        + ResolveIndices(_ *Schema) (Expression, error)
        + Vectorized() bool
        + SupportReverseEval() bool
        + ReverseEval(sc *stmtctx.StatementContext, res types.Datum, rType types.RoundingType) (types.Datum, error)
        + Coercibility() Coercibility
        + ExplainInfo() string
        + ExplainNormalizedInfo() string

    }
    class CorrelatedColumn << (S,Aquamarine) >> {
        + Data *types.Datum

        - resolveIndices(_ *Schema) error

        + Clone() Expression
        + VecEvalInt(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalReal(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalString(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalDecimal(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalTime(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalDuration(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalJSON(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + Eval(row chunk.Row) (types.Datum, error)
        + EvalInt(ctx sessionctx.Context, row chunk.Row) (int64, bool, error)
        + EvalReal(ctx sessionctx.Context, row chunk.Row) (float64, bool, error)
        + EvalString(ctx sessionctx.Context, row chunk.Row) (string, bool, error)
        + EvalDecimal(ctx sessionctx.Context, row chunk.Row) (*types.MyDecimal, bool, error)
        + EvalTime(ctx sessionctx.Context, row chunk.Row) (types.Time, bool, error)
        + EvalDuration(ctx sessionctx.Context, row chunk.Row) (types.Duration, bool, error)
        + EvalJSON(ctx sessionctx.Context, row chunk.Row) (json.BinaryJSON, bool, error)
        + Equal(ctx sessionctx.Context, expr Expression) bool
        + IsCorrelated() bool
        + ConstItem(_ *stmtctx.StatementContext) bool
        + Decorrelate(schema *Schema) Expression
        + ResolveIndices(_ *Schema) (Expression, error)

    }
    class EvaluatorSuite << (S,Aquamarine) >> {
        + Vectorizable() bool
        + Run(ctx sessionctx.Context, input *chunk.Chunk, output *chunk.Chunk) error

    }
    interface Expression  {
        - resolveIndices(schema *Schema) error

        + Eval(row chunk.Row) (types.Datum, error)
        + EvalInt(ctx sessionctx.Context, row chunk.Row) (int64, bool, error)
        + EvalReal(ctx sessionctx.Context, row chunk.Row) (float64, bool, error)
        + EvalString(ctx sessionctx.Context, row chunk.Row) (string, bool, error)
        + EvalDecimal(ctx sessionctx.Context, row chunk.Row) (*types.MyDecimal, bool, error)
        + EvalTime(ctx sessionctx.Context, row chunk.Row) (types.Time, bool, error)
        + EvalDuration(ctx sessionctx.Context, row chunk.Row) (types.Duration, bool, error)
        + EvalJSON(ctx sessionctx.Context, row chunk.Row) (json.BinaryJSON, bool, error)
        + GetType() *types.FieldType
        + Clone() Expression
        + Equal(ctx sessionctx.Context, e Expression) bool
        + IsCorrelated() bool
        + ConstItem(sc *stmtctx.StatementContext) bool
        + Decorrelate(schema *Schema) Expression
        + ResolveIndices(schema *Schema) (Expression, error)
        + ExplainInfo() string
        + ExplainNormalizedInfo() string
        + HashCode(sc *stmtctx.StatementContext) []byte

    }
    class KeyInfo << (S,Aquamarine) >> {
        + Clone() KeyInfo

    }
    class MysqlRng << (S,Aquamarine) >> {
        - seed1 uint32
        - seed2 uint32

        + Gen() float64

    }
    class ParamMarker << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - order int

        + GetUserVar() types.Datum

    }
    class PbConverter << (S,Aquamarine) >> {
        - client kv.Client
        - sc *stmtctx.StatementContext

        - conOrCorColToPBExpr(expr Expression) *tipb.Expr
        - encodeDatum(ft *types.FieldType, d types.Datum) (tipb.ExprType, []byte, bool)
        - columnToPBExpr(column *Column) *tipb.Expr
        - scalarFuncToPBExpr(expr *ScalarFunction) *tipb.Expr

        + ExprToPB(expr Expression) *tipb.Expr

    }
    interface PropagateConstantSolver  {
        + PropagateConstant(ctx sessionctx.Context, conditions []Expression) []Expression

    }
    interface ReverseExpr  {
        + SupportReverseEval() bool
        + ReverseEval(sc *stmtctx.StatementContext, res types.Datum, rType types.RoundingType) (types.Datum, error)

    }
    class ScalarFunction << (S,Aquamarine) >> {
        - hashcode []byte

        + FuncName model.CIStr
        + RetType *types.FieldType
        + Function builtinFunc

        - resolveIndices(schema *Schema) error
        - explainInfo(normalized bool) string

        + VecEvalInt(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalReal(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalString(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalDecimal(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalTime(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalDuration(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalJSON(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + GetArgs() []Expression
        + Vectorized() bool
        + SupportReverseEval() bool
        + ReverseEval(sc *stmtctx.StatementContext, res types.Datum, rType types.RoundingType) (types.Datum, error)
        + GetCtx() sessionctx.Context
        + String() string
        + MarshalJSON() ([]byte, error)
        + Clone() Expression
        + GetType() *types.FieldType
        + Equal(ctx sessionctx.Context, e Expression) bool
        + IsCorrelated() bool
        + ConstItem(sc *stmtctx.StatementContext) bool
        + Decorrelate(schema *Schema) Expression
        + Eval(row chunk.Row) (types.Datum, error)
        + EvalInt(ctx sessionctx.Context, row chunk.Row) (int64, bool, error)
        + EvalReal(ctx sessionctx.Context, row chunk.Row) (float64, bool, error)
        + EvalDecimal(ctx sessionctx.Context, row chunk.Row) (*types.MyDecimal, bool, error)
        + EvalString(ctx sessionctx.Context, row chunk.Row) (string, bool, error)
        + EvalTime(ctx sessionctx.Context, row chunk.Row) (types.Time, bool, error)
        + EvalDuration(ctx sessionctx.Context, row chunk.Row) (types.Duration, bool, error)
        + EvalJSON(ctx sessionctx.Context, row chunk.Row) (json.BinaryJSON, bool, error)
        + HashCode(sc *stmtctx.StatementContext) []byte
        + ResolveIndices(schema *Schema) (Expression, error)
        + GetSingleColumn(reverse bool) (*Column, bool)
        + Coercibility() Coercibility
        + HasCoercibility() bool
        + SetCoercibility(val Coercibility) 
        + CharsetAndCollation(ctx sessionctx.Context) (string, string)
        + SetCharsetAndCollation(chs string, coll string) 
        + ExplainInfo() string
        + ExplainNormalizedInfo() string

    }
    class Schema << (S,Aquamarine) >> {
        + Columns []*Column
        + Keys []KeyInfo

        + String() string
        + Clone() *Schema
        + RetrieveColumn(col *Column) *Column
        + IsUniqueKey(col *Column) bool
        + ColumnIndex(col *Column) int
        + Contains(col *Column) bool
        + Len() int
        + Append(col ...*Column) 
        + SetUniqueKeys(keys []KeyInfo) 
        + ColumnsIndices(cols []*Column) []int
        + ColumnsByIndices(offsets []int) []*Column

    }
    class VarAssignment << (S,Aquamarine) >> {
        + Name string
        + Expr Expression
        + IsDefault bool
        + IsGlobal bool
        + IsSystem bool
        + ExtendValue *Constant

    }
    interface VecExpr  {
        + Vectorized() bool
        + VecEvalInt(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalReal(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalString(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalDecimal(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalTime(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalDuration(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
        + VecEvalJSON(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error

    }
    class absFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class acosFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class addDateFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class addTimeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class aesDecryptFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class aesEncryptFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class aesModeAttr << (S,Aquamarine) >> {
        - modeName string
        - keySize int
        - ivRequired bool

    }
    class anyValueFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class arithmeticDivideFunctionClass << (S,Aquamarine) >> {
        - setType4DivDecimal(retTp *types.FieldType, a *types.FieldType, b *types.FieldType) 
        - setType4DivReal(retTp *types.FieldType) 
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class arithmeticIntDivideFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class arithmeticMinusFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class arithmeticModFunctionClass << (S,Aquamarine) >> {
        - setType4ModRealOrDecimal(retTp *types.FieldType, a *types.FieldType, b *types.FieldType, isDecimal bool) 
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class arithmeticMultiplyFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class arithmeticPlusFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class asciiFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class asinFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class atanFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class baseBuiltinCastFunc << (S,Aquamarine) >> {
        - inUnion bool

        - metadata() proto.Message
        - cloneFrom(from *baseBuiltinCastFunc) 

    }
    class baseBuiltinFunc << (S,Aquamarine) >> {
        - bufAllocator columnBufferAllocator
        - args []Expression
        - ctx sessionctx.Context
        - tp *types.FieldType
        - pbCode tipb.ScalarFuncSig
        - ctor collate.Collator
        - childrenVectorized bool
        - childrenReversed bool
        - childrenVectorizedOnce *sync.Once
        - childrenReversedOnce *sync.Once

        - metadata() proto.Message
        - setPbCode(c tipb.ScalarFuncSig) 
        - setCollator(ctor collate.Collator) 
        - collator() collate.Collator
        - getArgs() []Expression
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)
        - evalReal(row chunk.Row) (float64, bool, error)
        - evalString(row chunk.Row) (string, bool, error)
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - evalDuration(row chunk.Row) (types.Duration, bool, error)
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - supportReverseEval() bool
        - isChildrenReversed() bool
        - reverseEval(sc *stmtctx.StatementContext, res types.Datum, rType types.RoundingType) (types.Datum, error)
        - isChildrenVectorized() bool
        - getRetTp() *types.FieldType
        - equal(fun builtinFunc) bool
        - getCtx() sessionctx.Context
        - cloneFrom(from *baseBuiltinFunc) 

        + PbCode() tipb.ScalarFuncSig
        + Clone() builtinFunc

    }
    class baseDateArithmitical << (S,Aquamarine) >> {
        - intervalRegexp *regexp.Regexp

        - getDateFromString(ctx sessionctx.Context, args []Expression, row chunk.Row, unit string) (types.Time, bool, error)
        - getDateFromInt(ctx sessionctx.Context, args []Expression, row chunk.Row, unit string) (types.Time, bool, error)
        - getDateFromDatetime(ctx sessionctx.Context, args []Expression, row chunk.Row, unit string) (types.Time, bool, error)
        - getIntervalFromString(ctx sessionctx.Context, args []Expression, row chunk.Row, unit string) (string, bool, error)
        - getIntervalFromDecimal(ctx sessionctx.Context, args []Expression, row chunk.Row, unit string) (string, bool, error)
        - getIntervalFromInt(ctx sessionctx.Context, args []Expression, row chunk.Row, unit string) (string, bool, error)
        - getIntervalFromReal(ctx sessionctx.Context, args []Expression, row chunk.Row, unit string) (string, bool, error)
        - add(ctx sessionctx.Context, date types.Time, interval string, unit string) (types.Time, bool, error)
        - addDuration(ctx sessionctx.Context, d types.Duration, interval string, unit string) (types.Duration, bool, error)
        - subDuration(ctx sessionctx.Context, d types.Duration, interval string, unit string) (types.Duration, bool, error)
        - sub(ctx sessionctx.Context, date types.Time, interval string, unit string) (types.Time, bool, error)
        - vecGetDateFromInt(b *baseBuiltinFunc, input *chunk.Chunk, unit string, result *chunk.Column) error
        - vecGetDateFromString(b *baseBuiltinFunc, input *chunk.Chunk, unit string, result *chunk.Column) error
        - vecGetDateFromDatetime(b *baseBuiltinFunc, input *chunk.Chunk, unit string, result *chunk.Column) error
        - vecGetIntervalFromString(b *baseBuiltinFunc, input *chunk.Chunk, unit string, result *chunk.Column) error
        - vecGetIntervalFromDecimal(b *baseBuiltinFunc, input *chunk.Chunk, unit string, result *chunk.Column) error
        - vecGetIntervalFromInt(b *baseBuiltinFunc, input *chunk.Chunk, unit string, result *chunk.Column) error
        - vecGetIntervalFromReal(b *baseBuiltinFunc, input *chunk.Chunk, unit string, result *chunk.Column) error

    }
    class baseFunctionClass << (S,Aquamarine) >> {
        - funcName string
        - minArgs int
        - maxArgs int

        - verifyArgs(args []Expression) error

    }
    class baseInSig << (S,Aquamarine) >> {
        - nonConstArgs []Expression
        - hasNull bool

    }
    class basePropConstSolver << (S,Aquamarine) >> {
        - colMapper <font color=blue>map</font>[int64]int
        - eqList []*Constant
        - unionSet *disjointset.IntSet
        - columns []*Column
        - ctx sessionctx.Context

        - getColID(col *Column) int
        - insertCol(col *Column) 
        - tryToUpdateEQList(col *Column, con *Constant) (bool, bool)

    }
    class benchmarkFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class binFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class bitAndFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class bitCountFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class bitLengthFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class bitNegFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class bitOrFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class bitXorFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class builtinASCIISig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinAbsDecSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinAbsIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinAbsRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinAbsUIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinAcosSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinAddDateAndDurationSig << (S,Aquamarine) >> {
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateAndStringSig << (S,Aquamarine) >> {
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateDatetimeDecimalSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateDatetimeIntSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateDatetimeRealSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateDatetimeStringSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateDurationDecimalSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateDurationIntSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateDurationRealSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateDurationStringSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateIntDecimalSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateIntIntSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateIntRealSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateIntStringSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateStringDecimalSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateStringIntSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateStringRealSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDateStringStringSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDatetimeAndDurationSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDatetimeAndStringSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDurationAndDurationSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddDurationAndStringSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddStringAndDurationSig << (S,Aquamarine) >> {
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddStringAndStringSig << (S,Aquamarine) >> {
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddTimeDateTimeNullSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddTimeDurationNullSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinAddTimeStringNullSig << (S,Aquamarine) >> {
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinAesDecryptIVSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinAesDecryptSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinAesEncryptIVSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinAesEncryptSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinArithmeticDivideDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinArithmeticDivideRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinArithmeticIntDivideDecimalSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinArithmeticIntDivideIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - evalIntWithCtx(sctx sessionctx.Context, row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - divideUU(result *chunk.Column, lhsI64s []int64, rhsI64s []int64, resultI64s []int64) error
        - divideUS(result *chunk.Column, lhsI64s []int64, rhsI64s []int64, resultI64s []int64) error
        - divideSU(result *chunk.Column, lhsI64s []int64, rhsI64s []int64, resultI64s []int64) error
        - divideSS(result *chunk.Column, lhsI64s []int64, rhsI64s []int64, resultI64s []int64) error

        + Clone() builtinFunc

    }
    class builtinArithmeticMinusDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinArithmeticMinusIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - minusFUU(result *chunk.Column, lhi64s []int64, rhi64s []int64, resulti64s []int64) error
        - minusFUS(result *chunk.Column, lhi64s []int64, rhi64s []int64, resulti64s []int64) error
        - minusFSU(result *chunk.Column, lhi64s []int64, rhi64s []int64, resulti64s []int64) error
        - minusUU(result *chunk.Column, lhi64s []int64, rhi64s []int64, resulti64s []int64) error
        - minusUS(result *chunk.Column, lhi64s []int64, rhi64s []int64, resulti64s []int64) error
        - minusSU(result *chunk.Column, lhi64s []int64, rhi64s []int64, resulti64s []int64) error
        - minusSS(result *chunk.Column, lhi64s []int64, rhi64s []int64, resulti64s []int64) error

        + Clone() builtinFunc

    }
    class builtinArithmeticMinusRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinArithmeticModDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinArithmeticModIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - modUU(lh *chunk.Column, rh *chunk.Column) error
        - modUS(lh *chunk.Column, rh *chunk.Column) error
        - modSU(lh *chunk.Column, rh *chunk.Column) error
        - modSS(lh *chunk.Column, rh *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinArithmeticModRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinArithmeticMultiplyDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinArithmeticMultiplyIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinArithmeticMultiplyIntUnsignedSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinArithmeticMultiplyRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinArithmeticPlusDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinArithmeticPlusIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - plusUU(result *chunk.Column, lhi64s []int64, rhi64s []int64, resulti64s []int64) error
        - plusUS(result *chunk.Column, lhi64s []int64, rhi64s []int64, resulti64s []int64) error
        - plusSU(result *chunk.Column, lhi64s []int64, rhi64s []int64, resulti64s []int64) error
        - plusSS(result *chunk.Column, lhi64s []int64, rhi64s []int64, resulti64s []int64) error

        + Clone() builtinFunc

    }
    class builtinArithmeticPlusRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinAsinSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinAtan1ArgSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinAtan2ArgsSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinBenchmarkSig << (S,Aquamarine) >> {
        - constLoopCount int64

        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinBinSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinBitAndSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinBitCountSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinBitLengthSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinBitNegSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinBitOrSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinBitXorSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinCRC32Sig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCaseWhenDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCaseWhenDurationSig << (S,Aquamarine) >> {
        - evalDuration(row chunk.Row) (types.Duration, bool, error)
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCaseWhenIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCaseWhenJSONSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCaseWhenRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCaseWhenStringSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCaseWhenTimeSig << (S,Aquamarine) >> {
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCastDecimalAsDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastDecimalAsDurationSig << (S,Aquamarine) >> {
        - evalDuration(row chunk.Row) (types.Duration, bool, error)
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastDecimalAsIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastDecimalAsJSONSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastDecimalAsRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastDecimalAsStringSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastDecimalAsTimeSig << (S,Aquamarine) >> {
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastDurationAsDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastDurationAsDurationSig << (S,Aquamarine) >> {
        - evalDuration(row chunk.Row) (types.Duration, bool, error)
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastDurationAsIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastDurationAsJSONSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastDurationAsRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastDurationAsStringSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastDurationAsTimeSig << (S,Aquamarine) >> {
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastIntAsDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastIntAsDurationSig << (S,Aquamarine) >> {
        - evalDuration(row chunk.Row) (types.Duration, bool, error)
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCastIntAsIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCastIntAsJSONSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastIntAsRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCastIntAsStringSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastIntAsTimeSig << (S,Aquamarine) >> {
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastJSONAsDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastJSONAsDurationSig << (S,Aquamarine) >> {
        - evalDuration(row chunk.Row) (types.Duration, bool, error)
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastJSONAsIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastJSONAsJSONSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastJSONAsRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastJSONAsStringSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastJSONAsTimeSig << (S,Aquamarine) >> {
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastRealAsDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastRealAsDurationSig << (S,Aquamarine) >> {
        - evalDuration(row chunk.Row) (types.Duration, bool, error)
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastRealAsIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastRealAsJSONSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastRealAsRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCastRealAsStringSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastRealAsTimeSig << (S,Aquamarine) >> {
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastStringAsDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastStringAsDurationSig << (S,Aquamarine) >> {
        - evalDuration(row chunk.Row) (types.Duration, bool, error)
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastStringAsIntSig << (S,Aquamarine) >> {
        - handleOverflow(origRes int64, origStr string, origErr error, isNegative bool) (int64, error)
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastStringAsJSONSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastStringAsRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastStringAsStringSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastStringAsTimeSig << (S,Aquamarine) >> {
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastTimeAsDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastTimeAsDurationSig << (S,Aquamarine) >> {
        - evalDuration(row chunk.Row) (types.Duration, bool, error)
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastTimeAsIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastTimeAsJSONSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastTimeAsRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastTimeAsStringSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCastTimeAsTimeSig << (S,Aquamarine) >> {
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCeilDecToDecSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCeilDecToIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCeilIntToDecSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCeilIntToIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCeilRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCharLengthBinarySig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCharLengthUTF8Sig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCharSig << (S,Aquamarine) >> {
        - convertToBytes(ints []int64) []byte
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinCoalesceDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCoalesceDurationSig << (S,Aquamarine) >> {
        - evalDuration(row chunk.Row) (types.Duration, bool, error)
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCoalesceIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCoalesceJSONSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCoalesceRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCoalesceStringSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCoalesceTimeSig << (S,Aquamarine) >> {
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCoercibilitySig << (S,Aquamarine) >> {
        - evalInt(_ chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinCollationSig << (S,Aquamarine) >> {
        - evalString(_ chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinCompressSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinConcatSig << (S,Aquamarine) >> {
        - maxAllowedPacket uint64

        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinConcatWSSig << (S,Aquamarine) >> {
        - maxAllowedPacket uint64

        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinConnectionIDSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(_ chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinConvSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - conv(str string, fromBase int64, toBase int64) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinConvertSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinConvertTzSig << (S,Aquamarine) >> {
        - timezoneRegex *regexp.Regexp

        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - convertTz(dt types.Time, fromTzStr string, toTzStr string) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinCosSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCotSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinCurrentDateSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinCurrentRoleSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinCurrentTime0ArgSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinCurrentTime1ArgSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinCurrentUserSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinDatabaseSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinDateDiffSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinDateFormatSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinDateLiteralSig << (S,Aquamarine) >> {
        - literal types.Time

        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinDateSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinDayNameSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalIndex(input *chunk.Chunk, apply <font color=blue>func</font>(int, int) , applyNull <font color=blue>func</font>(int) ) error
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalIndex(row chunk.Row) (int64, bool, error)
        - evalString(row chunk.Row) (string, bool, error)
        - evalReal(row chunk.Row) (float64, bool, error)
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinDayOfMonthSig << (S,Aquamarine) >> {
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinDayOfWeekSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinDayOfYearSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinDecimalAnyValueSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)

        + Clone() builtinFunc

    }
    class builtinDecimalIsFalseSig << (S,Aquamarine) >> {
        - keepNull bool

        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinDecimalIsNullSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinDecimalIsTrueSig << (S,Aquamarine) >> {
        - keepNull bool

        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinDecodeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinDegreesSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinDurationAnyValueSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinDurationDurationTimeDiffSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinDurationIsNullSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinDurationStringTimeDiffSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinEQDecimalSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinEQDurationSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinEQIntSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinEQJSONSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinEQRealSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinEQStringSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinEQTimeSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinEltSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinEncodeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinExpSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinExportSet3ArgSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinExportSet4ArgSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinExportSet5ArgSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinExtractDatetimeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinExtractDurationSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinFieldIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinFieldRealSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinFieldStringSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinFindInSetSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinFloorDecToDecSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinFloorDecToIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinFloorIntToDecSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinFloorIntToIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinFloorRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinFormatBytesSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinFormatNanoTimeSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinFormatSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinFormatWithLocaleSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinFoundRowsSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinFromBase64Sig << (S,Aquamarine) >> {
        - maxAllowedPacket uint64

        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinFromDaysSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinFromUnixTime1ArgSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinFromUnixTime2ArgSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    interface builtinFunc  {
        - evalInt(row chunk.Row) (int64, bool, error)
        - evalReal(row chunk.Row) (float64, bool, error)
        - evalString(row chunk.Row) (string, bool, error)
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - evalDuration(row chunk.Row) (types.Duration, bool, error)
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - getArgs() []Expression
        - equal( builtinFunc) bool
        - getCtx() sessionctx.Context
        - getRetTp() *types.FieldType
        - setPbCode( tipb.ScalarFuncSig) 
        - setCollator(ctor collate.Collator) 
        - collator() collate.Collator
        - metadata() proto.Message

        + PbCode() tipb.ScalarFuncSig
        + Clone() builtinFunc

    }
    interface builtinFuncNew  {
        - evalIntWithCtx(ctx sessionctx.Context, row chunk.Row) (int64, bool, error)

    }
    class builtinGEDecimalSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinGEDurationSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinGEIntSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinGEJSONSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinGERealSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinGEStringSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinGETimeSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinGTDecimalSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinGTDurationSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinGTIntSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinGTJSONSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinGTRealSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinGTStringSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinGTTimeSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinGetFormatSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - getFormat(format string, location string) string
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinGetParamStringSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinGetVarSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinGreatestDecimalSig << (S,Aquamarine) >> {
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)

        + Clone() builtinFunc

    }
    class builtinGreatestIntSig << (S,Aquamarine) >> {
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinGreatestRealSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - evalReal(row chunk.Row) (float64, bool, error)

        + Clone() builtinFunc

    }
    class builtinGreatestStringSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinGreatestTimeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinHexIntArgSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinHexStrArgSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinHourSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinIfDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinIfDurationSig << (S,Aquamarine) >> {
        - evalDuration(row chunk.Row) (types.Duration, bool, error)
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinIfIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinIfJSONSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinIfNullDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinIfNullDurationSig << (S,Aquamarine) >> {
        - evalDuration(row chunk.Row) (types.Duration, bool, error)
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinIfNullIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinIfNullJSONSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinIfNullRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinIfNullStringSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinIfNullTimeSig << (S,Aquamarine) >> {
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinIfRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinIfStringSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinIfTimeSig << (S,Aquamarine) >> {
        - evalTime(row chunk.Row) (types.Time, bool, error)
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinInDecimalSig << (S,Aquamarine) >> {
        - hashSet set.StringSet

        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - buildHashMapForConstArgs(ctx sessionctx.Context) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinInDurationSig << (S,Aquamarine) >> {
        - hashSet <font color=blue>map</font>[time.Duration]<font color=blue>struct</font>{}

        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - buildHashMapForConstArgs(ctx sessionctx.Context) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinInIntSig << (S,Aquamarine) >> {
        - hashSet <font color=blue>map</font>[int64]bool

        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - buildHashMapForConstArgs(ctx sessionctx.Context) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinInJSONSig << (S,Aquamarine) >> {
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinInRealSig << (S,Aquamarine) >> {
        - hashSet set.Float64Set

        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - buildHashMapForConstArgs(ctx sessionctx.Context) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinInStringSig << (S,Aquamarine) >> {
        - hashSet set.StringSet

        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - buildHashMapForConstArgs(ctx sessionctx.Context) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinInTimeSig << (S,Aquamarine) >> {
        - hashSet <font color=blue>map</font>[types.Time]<font color=blue>struct</font>{}

        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - buildHashMapForConstArgs(ctx sessionctx.Context) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinInet6AtonSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinInet6NtoaSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinInetAtonSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinInetNtoaSig << (S,Aquamarine) >> {
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinInsertSig << (S,Aquamarine) >> {
        - maxAllowedPacket uint64

        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinInsertUTF8Sig << (S,Aquamarine) >> {
        - maxAllowedPacket uint64

        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinInstrSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinInstrUTF8Sig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinIntAnyValueSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinIntIsFalseSig << (S,Aquamarine) >> {
        - keepNull bool

        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinIntIsNullSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinIntIsTrueSig << (S,Aquamarine) >> {
        - keepNull bool

        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinIntervalIntSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)
        - binSearch(target int64, isUint1 bool, args []Expression, row chunk.Row) (int, error)

        + Clone() builtinFunc

    }
    class builtinIntervalRealSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)
        - binSearch(target float64, args []Expression, row chunk.Row) (int, error)

        + Clone() builtinFunc

    }
    class builtinIsIPv4CompatSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinIsIPv4MappedSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinIsIPv4Sig << (S,Aquamarine) >> {
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinIsIPv6Sig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinJSONAnyValueSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)

        + Clone() builtinFunc

    }
    class builtinJSONArrayAppendSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - appendJSONArray(res json.BinaryJSON, p string, v json.BinaryJSON) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONArrayInsertSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONArraySig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONContainsPathSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONContainsSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONDepthSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONExtractSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONInsertSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONKeys2ArgsSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONKeysSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONLengthSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONMergeSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONObjectSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONQuoteSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONRemoveSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONReplaceSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONSearchSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONSetSig << (S,Aquamarine) >> {
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONStorageSizeSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONTypeSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONUnquoteSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinJSONValidJSONSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinJSONValidOthersSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinJSONValidStringSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLEDecimalSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLEDurationSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLEIntSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLEJSONSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLERealSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLEStringSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLETimeSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLTDecimalSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLTDurationSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLTIntSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalIntWithCtx(ctx sessionctx.Context, row chunk.Row) (int64, bool, error)
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLTJSONSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLTRealSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLTStringSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLTTimeSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLTrimSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinLastDaySig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinLastInsertIDSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLastInsertIDWithIDSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLastValSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLeastDecimalSig << (S,Aquamarine) >> {
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)

        + Clone() builtinFunc

    }
    class builtinLeastIntSig << (S,Aquamarine) >> {
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLeastRealSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - evalReal(row chunk.Row) (float64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLeastStringSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinLeastTimeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinLeftShiftSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLeftSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinLeftUTF8Sig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLengthSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinLikeSig << (S,Aquamarine) >> {
        - pattern collate.WildcardPattern
        - isMemorizedPattern bool
        - once sync.Once

        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLocate2ArgsSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinLocate2ArgsUTF8Sig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinLocate3ArgsSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinLocate3ArgsUTF8Sig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinLockSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(_ chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLog10Sig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLog1ArgSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLog2ArgsSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLog2Sig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLogicAndSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLogicOrSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLogicXorSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinLowerSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinLpadSig << (S,Aquamarine) >> {
        - maxAllowedPacket uint64

        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinLpadUTF8Sig << (S,Aquamarine) >> {
        - maxAllowedPacket uint64

        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinMD5Sig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinMakeDateSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinMakeSetSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinMakeTimeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - getVecIntParam(arg Expression, input *chunk.Chunk, col *chunk.Column) error
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - getIntParam(arg Expression, row chunk.Row) (int64, bool, error)
        - makeTime(hour int64, minute int64, second float64, hourUnsignedFlag bool) (types.Duration, error)
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinMicroSecondSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinMinuteSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinMonthNameSig << (S,Aquamarine) >> {
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinMonthSig << (S,Aquamarine) >> {
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinNEDecimalSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinNEDurationSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinNEIntSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinNEJSONSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinNERealSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinNEStringSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinNETimeSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinNameConstDecimalSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)

        + Clone() builtinFunc

    }
    class builtinNameConstDurationSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinNameConstIntSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinNameConstJSONSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error
        - evalJSON(row chunk.Row) (json.BinaryJSON, bool, error)

        + Clone() builtinFunc

    }
    class builtinNameConstRealSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - evalReal(row chunk.Row) (float64, bool, error)

        + Clone() builtinFunc

    }
    class builtinNameConstStringSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinNameConstTimeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinNextValSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinNowWithArgSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinNowWithoutArgSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinNullEQDecimalSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinNullEQDurationSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinNullEQIntSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinNullEQJSONSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinNullEQRealSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinNullEQStringSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinNullEQTimeSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinNullTimeDiffSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinOctIntSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinOctStringSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinOrdSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinPISig << (S,Aquamarine) >> {
        - evalReal(_ chunk.Row) (float64, bool, error)
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinPasswordSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinPeriodAddSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinPeriodDiffSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinPowSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinQuarterSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinQuoteSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinRTrimSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinRadiansSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinRandSig << (S,Aquamarine) >> {
        - mu *sync.Mutex
        - mysqlRng *MysqlRng

        - evalReal(row chunk.Row) (float64, bool, error)
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinRandWithSeedFirstGenSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinRandomBytesSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinRealAnyValueSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - evalReal(row chunk.Row) (float64, bool, error)

        + Clone() builtinFunc

    }
    class builtinRealIsFalseSig << (S,Aquamarine) >> {
        - keepNull bool

        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinRealIsNullSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinRealIsTrueSig << (S,Aquamarine) >> {
        - keepNull bool

        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinRegexpSharedSig << (S,Aquamarine) >> {
        - compile <font color=blue>func</font>(string) (*regexp.Regexp, error)
        - memorizedRegexp *regexp.Regexp
        - memorizedErr error

        - isMemorizedRegexpInitialized() bool
        - initMemoizedRegexp(patterns *chunk.Column, n int) 
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - clone(from *builtinRegexpSharedSig) 
        - evalInt(row chunk.Row) (int64, bool, error)

    }
    class builtinRegexpSig << (S,Aquamarine) >> {
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinRegexpUTF8Sig << (S,Aquamarine) >> {
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinReleaseLockSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(_ chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinRepeatSig << (S,Aquamarine) >> {
        - maxAllowedPacket uint64

        - evalString(row chunk.Row) (string, bool, error)
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinReplaceSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinReverseSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinReverseUTF8Sig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinRightShiftSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinRightSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinRightUTF8Sig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinRoundDecSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinRoundIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinRoundRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinRoundWithFracDecSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinRoundWithFracIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinRoundWithFracRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinRowCountSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(_ chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinRowSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinRpadSig << (S,Aquamarine) >> {
        - maxAllowedPacket uint64

        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinRpadUTF8Sig << (S,Aquamarine) >> {
        - maxAllowedPacket uint64

        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinSHA1Sig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinSHA2Sig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinSecToTimeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinSecondSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinSetValSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinSetVarSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinSignSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinSinSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinSleepSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinSpaceSig << (S,Aquamarine) >> {
        - maxAllowedPacket uint64

        - evalString(row chunk.Row) (string, bool, error)
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinSqrtSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinStrToDateDateSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinStrToDateDatetimeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinStrToDateDurationSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinStrcmpSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinStringAnyValueSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinStringDurationTimeDiffSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinStringIsNullSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinStringStringTimeDiffSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinStringTimeTimeDiffSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateAndDurationSig << (S,Aquamarine) >> {
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateAndStringSig << (S,Aquamarine) >> {
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateDatetimeDecimalSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateDatetimeIntSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateDatetimeRealSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateDatetimeStringSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateDurationDecimalSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateDurationIntSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateDurationRealSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateDurationStringSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateIntDecimalSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateIntIntSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateIntRealSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateIntStringSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateStringDecimalSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateStringIntSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateStringRealSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDateStringStringSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDatetimeAndDurationSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDatetimeAndStringSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDurationAndDurationSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubDurationAndStringSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubStringAndDurationSig << (S,Aquamarine) >> {
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubStringAndStringSig << (S,Aquamarine) >> {
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubTimeDateTimeNullSig << (S,Aquamarine) >> {
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubTimeDurationNullSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubTimeStringNullSig << (S,Aquamarine) >> {
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinSubstring2ArgsSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinSubstring2ArgsUTF8Sig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinSubstring3ArgsSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinSubstring3ArgsUTF8Sig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinSubstringIndexSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinSysDateWithFspSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinSysDateWithoutFspSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinTanSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinTiDBDecodeKeySig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinTiDBDecodePlanSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinTiDBIsDDLOwnerSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(_ chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinTiDBVersionSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(_ chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinTidbParseTsoSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinTimeAnyValueSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinTimeFormatSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)
        - formatTime(ctx sessionctx.Context, t types.Duration, formatMask string) (string, error)

        + Clone() builtinFunc

    }
    class builtinTimeIsNullSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinTimeLiteralSig << (S,Aquamarine) >> {
        - duration types.Duration

        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinTimeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinTimeStringTimeDiffSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinTimeTimeTimeDiffSig << (S,Aquamarine) >> {
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinTimeToSecSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinTimestamp1ArgSig << (S,Aquamarine) >> {
        - isFloat bool

        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinTimestamp2ArgsSig << (S,Aquamarine) >> {
        - isFloat bool

        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinTimestampAddSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)
        - resolveType(typ uint8, unit string) uint8

        + Clone() builtinFunc

    }
    class builtinTimestampDiffSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinTimestampLiteralSig << (S,Aquamarine) >> {
        - tm types.Time

        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinToBase64Sig << (S,Aquamarine) >> {
        - maxAllowedPacket uint64

        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinToDaysSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinToSecondsSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinTrim1ArgSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinTrim2ArgsSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinTrim3ArgsSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinTruncateDecimalSig << (S,Aquamarine) >> {
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinTruncateIntSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinTruncateRealSig << (S,Aquamarine) >> {
        - evalReal(row chunk.Row) (float64, bool, error)
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinTruncateUintSig << (S,Aquamarine) >> {
        - evalInt(row chunk.Row) (int64, bool, error)
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinUTCDateSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinUTCTimeWithArgSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinUTCTimeWithoutArgSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - evalDuration(row chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinUTCTimestampWithArgSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinUTCTimestampWithoutArgSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(row chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinUUIDSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(_ chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinUnHexSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error

        + Clone() builtinFunc

    }
    class builtinUnaryMinusDecimalSig << (S,Aquamarine) >> {
        - constantArgOverflow bool

        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)

        + Clone() builtinFunc

    }
    class builtinUnaryMinusIntSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinUnaryMinusRealSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - evalReal(row chunk.Row) (float64, bool, error)

        + Clone() builtinFunc

    }
    class builtinUnaryNotDecimalSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinUnaryNotIntSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinUnaryNotRealSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinUncompressSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinUncompressedLengthSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinUnixTimestampCurrentSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinUnixTimestampDecSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - evalDecimal(row chunk.Row) (*types.MyDecimal, bool, error)

        + Clone() builtinFunc

    }
    class builtinUnixTimestampIntSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)
        - evalIntWithCtx(ctx sessionctx.Context, row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinUpperSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinUpperUTF8Sig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool

        + Clone() builtinFunc

    }
    class builtinUserSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinValuesDecimalSig << (S,Aquamarine) >> {
        - offset int

        - vectorized() bool
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - evalDecimal(_ chunk.Row) (*types.MyDecimal, bool, error)

        + Clone() builtinFunc

    }
    class builtinValuesDurationSig << (S,Aquamarine) >> {
        - offset int

        - vectorized() bool
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - evalDuration(_ chunk.Row) (types.Duration, bool, error)

        + Clone() builtinFunc

    }
    class builtinValuesIntSig << (S,Aquamarine) >> {
        - offset int

        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(_ chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinValuesJSONSig << (S,Aquamarine) >> {
        - offset int

        - vectorized() bool
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error
        - evalJSON(_ chunk.Row) (json.BinaryJSON, bool, error)

        + Clone() builtinFunc

    }
    class builtinValuesRealSig << (S,Aquamarine) >> {
        - offset int

        - vectorized() bool
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - evalReal(_ chunk.Row) (float64, bool, error)

        + Clone() builtinFunc

    }
    class builtinValuesStringSig << (S,Aquamarine) >> {
        - offset int

        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(_ chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinValuesTimeSig << (S,Aquamarine) >> {
        - offset int

        - vectorized() bool
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - evalTime(_ chunk.Row) (types.Time, bool, error)

        + Clone() builtinFunc

    }
    class builtinVersionSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinWeekDaySig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinWeekOfYearSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinWeekWithModeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinWeekWithoutModeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinWeightStringNullSig << (S,Aquamarine) >> {
        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinWeightStringSig << (S,Aquamarine) >> {
        - padding weightStringPadding
        - length int

        - evalString(row chunk.Row) (string, bool, error)

        + Clone() builtinFunc

    }
    class builtinYearSig << (S,Aquamarine) >> {
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vectorized() bool
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinYearWeekWithModeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class builtinYearWeekWithoutModeSig << (S,Aquamarine) >> {
        - vectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - evalInt(row chunk.Row) (int64, bool, error)

        + Clone() builtinFunc

    }
    class caseWhenFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class castAsDecimalFunctionClass << (S,Aquamarine) >> {
        - tp *types.FieldType

        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class castAsDurationFunctionClass << (S,Aquamarine) >> {
        - tp *types.FieldType

        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class castAsIntFunctionClass << (S,Aquamarine) >> {
        - tp *types.FieldType

        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class castAsJSONFunctionClass << (S,Aquamarine) >> {
        - tp *types.FieldType

        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class castAsRealFunctionClass << (S,Aquamarine) >> {
        - tp *types.FieldType

        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class castAsStringFunctionClass << (S,Aquamarine) >> {
        - tp *types.FieldType

        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class castAsTimeFunctionClass << (S,Aquamarine) >> {
        - tp *types.FieldType

        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class ceilFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class charFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class charLengthFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class charsetFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class coalesceFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class coercibilityFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class collationFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class collationInfo << (S,Aquamarine) >> {
        - coer Coercibility
        - coerInit bool
        - charset string
        - collation string
        - flen int

        + HasCoercibility() bool
        + Coercibility() Coercibility
        + SetCoercibility(val Coercibility) 
        + SetCharsetAndCollation(chs string, coll string) 
        + CharsetAndCollation(ctx sessionctx.Context) (string, string)

    }
    interface columnBufferAllocator  {
        - get(evalType types.EvalType, capacity int) (*chunk.Column, error)
        - put(buf *chunk.Column) 

    }
    class columnEvaluator << (S,Aquamarine) >> {
        - inputIdxToOutputIdxes <font color=blue>map</font>[int][]int

        - run(ctx sessionctx.Context, input *chunk.Chunk, output *chunk.Chunk) error

    }
    class compareFunctionClass << (S,Aquamarine) >> {
        - op opcode.Op

        - refineArgs(ctx sessionctx.Context, args []Expression) []Expression
        - getFunction(ctx sessionctx.Context, rawArgs []Expression) (builtinFunc, error)
        - generateCmpSigs(ctx sessionctx.Context, args []Expression, tp types.EvalType) (builtinFunc, error)

    }
    class compressFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class concatFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class concatWSFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class connectionIDFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class convFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class convertFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class convertTzFunctionClass << (S,Aquamarine) >> {
        - getDecimal(ctx sessionctx.Context, arg Expression) int
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class cosFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class cotFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class cowExprRef << (S,Aquamarine) >> {
        - ref []Expression
        - new []Expression

        + Set(i int, changed bool, val Expression) 
        + Result() []Expression

    }
    class crc32FunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class currentDateFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class currentRoleFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class currentTimeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class currentUserFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class databaseFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class dateDiffFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class dateFormatFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class dateFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class dateLiteralFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class dayNameFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class dayOfMonthFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class dayOfWeekFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class dayOfYearFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class decodeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class defaultEvaluator << (S,Aquamarine) >> {
        - outputIdxes []int
        - exprs []Expression
        - vectorizable bool

        - run(ctx sessionctx.Context, input *chunk.Chunk, output *chunk.Chunk) error

    }
    class defaultFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class degreesFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class desDecryptFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class desEncryptFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class eltFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class encodeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class encryptFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class expFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class exportSetFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class exprStack << (S,Aquamarine) >> {
        - stack []Expression

        - pop() Expression
        - popN(n int) []Expression
        - push(expr Expression) 
        - len() int

    }
    class expression.CNFExprs << (T, #FF7700) >>  {
    }
    class expression.Coercibility << (T, #FF7700) >>  {
    }
    class expression.CompareFunc << (T, #FF7700) >>  {
    }
    class expression.KeyInfo << (T, #FF7700) >>  {
    }
    class expression.inCastContext << (T, #FF7700) >>  {
    }
    class expression.weightStringPadding << (T, #FF7700) >>  {
    }
    class extractFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class fieldFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class findInSetFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class floorFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class formatBytesFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class formatFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class formatNanoTimeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class foundRowsFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class fromBase64FunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class fromDaysFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class fromUnixTimeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    interface functionClass  {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class getFormatFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class getParamFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class getVarFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)
        - resolveCollation(ctx sessionctx.Context, args []Expression, bf *baseBuiltinFunc) error

    }
    class greatestFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class hashPartitionPruner << (S,Aquamarine) >> {
        - unionSet *disjointset.IntSet
        - constantMap []*Constant
        - conditions []Expression
        - colMapper <font color=blue>map</font>[int64]int
        - numColumn int
        - ctx sessionctx.Context

        - getColID(col *Column) int
        - insertCol(col *Column) 
        - reduceColumnEQ() bool
        - reduceConstantEQ() bool
        - tryEvalPartitionExpr(piExpr Expression) (int64, bool, bool)
        - solve(ctx sessionctx.Context, conds []Expression, piExpr Expression) (int64, bool, bool)

    }
    class hexFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class hourFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class ifFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class ifNullFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class inCastContext << (S,Aquamarine) >> {
        + String() string

    }
    class inFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class inet6AtonFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class inet6NtoaFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class inetAtonFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class inetNtoaFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class insertFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class instrFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class intervalFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class isFreeLockFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class isIPv4CompatFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class isIPv4FunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class isIPv4MappedFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class isIPv6FunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class isNullFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class isTrueOrFalseFunctionClass << (S,Aquamarine) >> {
        - op opcode.Op
        - keepNull bool

        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class isUsedLockFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonArrayAppendFunctionClass << (S,Aquamarine) >> {
        - verifyArgs(args []Expression) error
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonArrayFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonArrayInsertFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonContainsFunctionClass << (S,Aquamarine) >> {
        - verifyArgs(args []Expression) error
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonContainsPathFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonDepthFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonExtractFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonInsertFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonKeysFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonLengthFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonMergeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonMergePatchFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonMergePreserveFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonObjectFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonPrettyFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonQuoteFunctionClass << (S,Aquamarine) >> {
        - verifyArgs(args []Expression) error
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonRemoveFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonReplaceFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonSearchFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonSetFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonStorageSizeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonTypeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonUnquoteFunctionClass << (S,Aquamarine) >> {
        - verifyArgs(args []Expression) error
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class jsonValidFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class lTrimFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class lastDayFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class lastInsertIDFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class lastValFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class leastFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class leftFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class leftShiftFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class lengthFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class likeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class loadFileFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class localSliceBuffer << (S,Aquamarine) >> {
        - buffers []*chunk.Column
        - head int
        - tail int
        - size int

        - get(evalType types.EvalType, capacity int) (*chunk.Column, error)
        - put(buf *chunk.Column) 

    }
    class locateFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class lockFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class log10FunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class log2FunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class logFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class logicAndFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class logicOrFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class logicXorFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class lowerFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class lpadFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class makeDateFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class makeSetFunctionClass << (S,Aquamarine) >> {
        - getFlen(ctx sessionctx.Context, args []Expression) int
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class makeTimeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class masterPosWaitFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class md5FunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class microSecondFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class minuteFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class monthFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class monthNameFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class nameConstFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class nextValFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class nowFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class octFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class oldPasswordFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class ordFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class passwordFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class periodAddFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class periodDiffFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class piFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class powFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class propConstSolver << (S,Aquamarine) >> {
        - conditions []Expression

        - propagateConstantEQ() 
        - propagateColumnEQ() 
        - setConds2ConstFalse() 
        - pickNewEQConds(visited []bool) <font color=blue>map</font>[int]*Constant
        - solve(conditions []Expression) []Expression

        + PropagateConstant(ctx sessionctx.Context, conditions []Expression) []Expression

    }
    class propOuterJoinConstSolver << (S,Aquamarine) >> {
        - joinConds []Expression
        - filterConds []Expression
        - outerSchema *Schema
        - innerSchema *Schema
        - nullSensitive bool

        - setConds2ConstFalse(filterConds bool) 
        - pickEQCondsOnOuterCol(retMapper <font color=blue>map</font>[int]*Constant, visited []bool, filterConds bool) <font color=blue>map</font>[int]*Constant
        - pickNewEQConds(visited []bool) <font color=blue>map</font>[int]*Constant
        - propagateConstantEQ() 
        - colsFromOuterAndInner(col1 *Column, col2 *Column) (*Column, *Column)
        - validColEqualCond(cond Expression) (*Column, *Column)
        - deriveConds(outerCol *Column, innerCol *Column, schema *Schema, fCondsOffset int, visited []bool, filterConds bool) []bool
        - propagateColumnEQ() 
        - solve(joinConds []Expression, filterConds []Expression) ([]Expression, []Expression)

    }
    class quarterFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class quoteFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class rTrimFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class radiansFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class randFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class randomBytesFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class regexpFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class releaseAllLocksFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class releaseLockFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class repeatFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class replaceFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)
        - fixLength(args []Expression) int

    }
    interface reverseBuiltinFunc  {
        - supportReverseEval() bool
        - isChildrenReversed() bool
        - reverseEval(sc *stmtctx.StatementContext, res types.Datum, rType types.RoundingType) (types.Datum, error)

    }
    class reverseFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class rightFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class rightShiftFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class roundFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class rowCountFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class rowFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class rpadFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class secToTimeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class secondFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class setValFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class setVarFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class sha1FunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class sha2FunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class signFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class simpleRewriter << (S,Aquamarine) >> {
        - schema *Schema
        - err error
        - ctx sessionctx.Context
        - names []*types.FieldName

        - rewriteColumn(nodeColName *ast.ColumnNameExpr) (*Column, error)
        - useCache() bool
        - binaryOpToExpression(v *ast.BinaryOperationExpr) 
        - funcCallToExpression(v *ast.FuncCallExpr) 
        - rewriteFuncCall(v *ast.FuncCallExpr, args []Expression) bool
        - constructBinaryOpFunction(l Expression, r Expression, op string) (Expression, error)
        - unaryOpToExpression(v *ast.UnaryOperationExpr) 
        - likeToScalarFunc(v *ast.PatternLikeExpr) 
        - regexpToScalarFunc(v *ast.PatternRegexpExpr) 
        - rowToScalarFunc(v *ast.RowExpr) 
        - betweenToExpression(v *ast.BetweenExpr) 
        - isNullToExpression(v *ast.IsNullExpr) 
        - notToExpression(hasNot bool, op string, tp *types.FieldType, args ...Expression) Expression
        - isTrueToScalarFunc(v *ast.IsTruthExpr) 
        - inToExpression(lLen int, not bool, tp *types.FieldType) 

        + Enter(inNode ast.Node) (ast.Node, bool)
        + Leave(originInNode ast.Node) (ast.Node, bool)

    }
    class sinFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class sleepFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class spaceFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class sqrtFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class strToDateFunctionClass << (S,Aquamarine) >> {
        - getRetTp(ctx sessionctx.Context, arg Expression) (byte, int8)
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class strcmpFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class subDateFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class subTimeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class substringFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class substringIndexFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class sysDateFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class tanFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class tidbDecodeKeyFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class tidbDecodePlanFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class tidbIsDDLOwnerFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class tidbParseTsoFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class tidbVersionFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class timeDiffFunctionClass << (S,Aquamarine) >> {
        - getArgEvalTp(fieldTp *types.FieldType) types.EvalType
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class timeFormatFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class timeFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class timeLiteralFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class timeToSecFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class timestampAddFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class timestampDiffFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class timestampFunctionClass << (S,Aquamarine) >> {
        - getDefaultFsp(tp *types.FieldType) int8
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class timestampLiteralFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class toBase64FunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class toDaysFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class toSecondsFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class trimFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class truncateFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class unaryMinusFunctionClass << (S,Aquamarine) >> {
        - handleIntOverflow(arg *Constant) bool
        - typeInfer(argExpr Expression) (types.EvalType, bool)
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class unaryNotFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class uncompressFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class uncompressedLengthFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class unhexFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class unixTimestampFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class upperFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class userFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class utcDateFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class utcTimeFunctionClass << (S,Aquamarine) >> {
        - getFlenAndDecimal4UTCTime(ctx sessionctx.Context, args []Expression) int
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class utcTimestampFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class uuidFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class uuidShortFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class validatePasswordStrengthFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class valuesFunctionClass << (S,Aquamarine) >> {
        - offset int
        - tp *types.FieldType

        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    interface vecBuiltinFunc  {
        - vectorized() bool
        - isChildrenVectorized() bool
        - vecEvalInt(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalReal(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalString(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalDecimal(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalTime(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalDuration(input *chunk.Chunk, result *chunk.Column) error
        - vecEvalJSON(input *chunk.Chunk, result *chunk.Column) error

    }
    class versionFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class weekDayFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class weekFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class weekOfYearFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class weightStringFunctionClass << (S,Aquamarine) >> {
        - verifyArgs(args []Expression) (weightStringPadding, int, error)
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class yearFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class yearWeekFunctionClass << (S,Aquamarine) >> {
        - getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error)

    }
    class "<font color=blue>func</font>(sessionctx.Context, Expression, Expression, chunk.Row, chunk.Row) (int64, bool, error)" as fontcolorbluefuncfontsessionctxContextExpressionExpressionchunkRowchunkRowint64boolerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"expression.collationInfo" *-- "expression.Column"
"expression.collationInfo" *-- "expression.Constant"
"expression.Column" *-- "expression.CorrelatedColumn"
"expression.columnEvaluator" *-- "expression.EvaluatorSuite"
"expression.defaultEvaluator" *-- "expression.EvaluatorSuite"
"expression.CollationInfo" *-- "expression.Expression"
"expression.ReverseExpr" *-- "expression.Expression"
"expression.VecExpr" *-- "expression.Expression"
"expression.baseFunctionClass" *-- "expression.absFunctionClass"
"expression.baseFunctionClass" *-- "expression.acosFunctionClass"
"expression.baseFunctionClass" *-- "expression.addDateFunctionClass"
"expression.baseFunctionClass" *-- "expression.addTimeFunctionClass"
"expression.baseFunctionClass" *-- "expression.aesDecryptFunctionClass"
"expression.baseFunctionClass" *-- "expression.aesEncryptFunctionClass"
"expression.baseFunctionClass" *-- "expression.anyValueFunctionClass"
"expression.baseFunctionClass" *-- "expression.arithmeticDivideFunctionClass"
"expression.baseFunctionClass" *-- "expression.arithmeticIntDivideFunctionClass"
"expression.baseFunctionClass" *-- "expression.arithmeticMinusFunctionClass"
"expression.baseFunctionClass" *-- "expression.arithmeticModFunctionClass"
"expression.baseFunctionClass" *-- "expression.arithmeticMultiplyFunctionClass"
"expression.baseFunctionClass" *-- "expression.arithmeticPlusFunctionClass"
"expression.baseFunctionClass" *-- "expression.asciiFunctionClass"
"expression.baseFunctionClass" *-- "expression.asinFunctionClass"
"expression.baseFunctionClass" *-- "expression.atanFunctionClass"
"expression.baseBuiltinFunc" *-- "expression.baseBuiltinCastFunc"
"expression.collationInfo" *-- "expression.baseBuiltinFunc"
"expression.baseBuiltinFunc" *-- "expression.baseInSig"
"expression.baseFunctionClass" *-- "expression.benchmarkFunctionClass"
"expression.baseFunctionClass" *-- "expression.binFunctionClass"
"expression.baseFunctionClass" *-- "expression.bitAndFunctionClass"
"expression.baseFunctionClass" *-- "expression.bitCountFunctionClass"
"expression.baseFunctionClass" *-- "expression.bitLengthFunctionClass"
"expression.baseFunctionClass" *-- "expression.bitNegFunctionClass"
"expression.baseFunctionClass" *-- "expression.bitOrFunctionClass"
"expression.baseFunctionClass" *-- "expression.bitXorFunctionClass"
"expression.baseBuiltinFunc" *-- "expression.builtinASCIISig"
"expression.baseBuiltinFunc" *-- "expression.builtinAbsDecSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAbsIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAbsRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAbsUIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAcosSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateAndDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateAndStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateDatetimeDecimalSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateDatetimeDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateDatetimeIntSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateDatetimeIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateDatetimeRealSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateDatetimeRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateDatetimeStringSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateDatetimeStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateDurationDecimalSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateDurationDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateDurationIntSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateDurationIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateDurationRealSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateDurationRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateDurationStringSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateDurationStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateIntDecimalSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateIntDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateIntIntSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateIntIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateIntRealSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateIntRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateIntStringSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateIntStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateStringDecimalSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateStringDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateStringIntSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateStringIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateStringRealSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateStringRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDateStringStringSig"
"expression.baseDateArithmitical" *-- "expression.builtinAddDateStringStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDatetimeAndDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDatetimeAndStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDurationAndDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddDurationAndStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddStringAndDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddStringAndStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddTimeDateTimeNullSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddTimeDurationNullSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAddTimeStringNullSig"
"expression.aesModeAttr" *-- "expression.builtinAesDecryptIVSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAesDecryptIVSig"
"expression.aesModeAttr" *-- "expression.builtinAesDecryptSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAesDecryptSig"
"expression.aesModeAttr" *-- "expression.builtinAesEncryptIVSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAesEncryptIVSig"
"expression.aesModeAttr" *-- "expression.builtinAesEncryptSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAesEncryptSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticDivideDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticDivideRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticIntDivideDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticIntDivideIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticMinusDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticMinusIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticMinusRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticModDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticModIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticModRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticMultiplyDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticMultiplyIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticMultiplyIntUnsignedSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticMultiplyRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticPlusDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticPlusIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinArithmeticPlusRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAsinSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAtan1ArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinAtan2ArgsSig"
"expression.baseBuiltinFunc" *-- "expression.builtinBenchmarkSig"
"expression.baseBuiltinFunc" *-- "expression.builtinBinSig"
"expression.baseBuiltinFunc" *-- "expression.builtinBitAndSig"
"expression.baseBuiltinFunc" *-- "expression.builtinBitCountSig"
"expression.baseBuiltinFunc" *-- "expression.builtinBitLengthSig"
"expression.baseBuiltinFunc" *-- "expression.builtinBitNegSig"
"expression.baseBuiltinFunc" *-- "expression.builtinBitOrSig"
"expression.baseBuiltinFunc" *-- "expression.builtinBitXorSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCRC32Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinCaseWhenDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCaseWhenDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCaseWhenIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCaseWhenJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCaseWhenRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCaseWhenStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCaseWhenTimeSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastDecimalAsDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastDecimalAsDurationSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastDecimalAsIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastDecimalAsJSONSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastDecimalAsRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastDecimalAsStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastDecimalAsTimeSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastDurationAsDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastDurationAsDurationSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastDurationAsIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastDurationAsJSONSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastDurationAsRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastDurationAsStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastDurationAsTimeSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastIntAsDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastIntAsDurationSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastIntAsIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastIntAsJSONSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastIntAsRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastIntAsStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastIntAsTimeSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastJSONAsDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastJSONAsDurationSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastJSONAsIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastJSONAsJSONSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastJSONAsRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastJSONAsStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastJSONAsTimeSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastRealAsDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastRealAsDurationSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastRealAsIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastRealAsJSONSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastRealAsRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastRealAsStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastRealAsTimeSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastStringAsDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastStringAsDurationSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastStringAsIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastStringAsJSONSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastStringAsRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastStringAsStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastStringAsTimeSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastTimeAsDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastTimeAsDurationSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastTimeAsIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastTimeAsJSONSig"
"expression.baseBuiltinCastFunc" *-- "expression.builtinCastTimeAsRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastTimeAsStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCastTimeAsTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCeilDecToDecSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCeilDecToIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCeilIntToDecSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCeilIntToIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCeilRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCharLengthBinarySig"
"expression.baseBuiltinFunc" *-- "expression.builtinCharLengthUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinCharSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCoalesceDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCoalesceDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCoalesceIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCoalesceJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCoalesceRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCoalesceStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCoalesceTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCoercibilitySig"
"expression.baseBuiltinFunc" *-- "expression.builtinCollationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCompressSig"
"expression.baseBuiltinFunc" *-- "expression.builtinConcatSig"
"expression.baseBuiltinFunc" *-- "expression.builtinConcatWSSig"
"expression.baseBuiltinFunc" *-- "expression.builtinConnectionIDSig"
"expression.baseBuiltinFunc" *-- "expression.builtinConvSig"
"expression.baseBuiltinFunc" *-- "expression.builtinConvertSig"
"expression.baseBuiltinFunc" *-- "expression.builtinConvertTzSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCosSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCotSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCurrentDateSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCurrentRoleSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCurrentTime0ArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCurrentTime1ArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinCurrentUserSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDatabaseSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDateDiffSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDateFormatSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDateLiteralSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDateSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDayNameSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDayOfMonthSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDayOfWeekSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDayOfYearSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDecimalAnyValueSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDecimalIsFalseSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDecimalIsNullSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDecimalIsTrueSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDecodeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDegreesSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDurationAnyValueSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDurationDurationTimeDiffSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDurationIsNullSig"
"expression.baseBuiltinFunc" *-- "expression.builtinDurationStringTimeDiffSig"
"expression.baseBuiltinFunc" *-- "expression.builtinEQDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinEQDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinEQIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinEQJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinEQRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinEQStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinEQTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinEltSig"
"expression.baseBuiltinFunc" *-- "expression.builtinEncodeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinExpSig"
"expression.baseBuiltinFunc" *-- "expression.builtinExportSet3ArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinExportSet4ArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinExportSet5ArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinExtractDatetimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinExtractDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFieldIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFieldRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFieldStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFindInSetSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFloorDecToDecSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFloorDecToIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFloorIntToDecSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFloorIntToIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFloorRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFormatBytesSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFormatNanoTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFormatSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFormatWithLocaleSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFoundRowsSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFromBase64Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinFromDaysSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFromUnixTime1ArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinFromUnixTime2ArgSig"
"expression.CollationInfo" *-- "expression.builtinFunc"
"expression.reverseBuiltinFunc" *-- "expression.builtinFunc"
"expression.vecBuiltinFunc" *-- "expression.builtinFunc"
"expression.baseBuiltinFunc" *-- "expression.builtinGEDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGEDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGEIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGEJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGERealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGEStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGETimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGTDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGTDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGTIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGTJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGTRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGTStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGTTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGetFormatSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGetParamStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGetVarSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGreatestDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGreatestIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGreatestRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGreatestStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinGreatestTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinHexIntArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinHexStrArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinHourSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfNullDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfNullDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfNullIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfNullJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfNullRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfNullStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfNullTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIfTimeSig"
"expression.baseInSig" *-- "expression.builtinInDecimalSig"
"expression.baseInSig" *-- "expression.builtinInDurationSig"
"expression.baseInSig" *-- "expression.builtinInIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinInJSONSig"
"expression.baseInSig" *-- "expression.builtinInRealSig"
"expression.baseInSig" *-- "expression.builtinInStringSig"
"expression.baseInSig" *-- "expression.builtinInTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinInet6AtonSig"
"expression.baseBuiltinFunc" *-- "expression.builtinInet6NtoaSig"
"expression.baseBuiltinFunc" *-- "expression.builtinInetAtonSig"
"expression.baseBuiltinFunc" *-- "expression.builtinInetNtoaSig"
"expression.baseBuiltinFunc" *-- "expression.builtinInsertSig"
"expression.baseBuiltinFunc" *-- "expression.builtinInsertUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinInstrSig"
"expression.baseBuiltinFunc" *-- "expression.builtinInstrUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinIntAnyValueSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIntIsFalseSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIntIsNullSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIntIsTrueSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIntervalIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIntervalRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIsIPv4CompatSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIsIPv4MappedSig"
"expression.baseBuiltinFunc" *-- "expression.builtinIsIPv4Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinIsIPv6Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONAnyValueSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONArrayAppendSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONArrayInsertSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONArraySig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONContainsPathSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONContainsSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONDepthSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONExtractSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONInsertSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONKeys2ArgsSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONKeysSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONLengthSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONMergeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONObjectSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONQuoteSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONRemoveSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONReplaceSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONSearchSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONSetSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONStorageSizeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONTypeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONUnquoteSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONValidJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONValidOthersSig"
"expression.baseBuiltinFunc" *-- "expression.builtinJSONValidStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLEDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLEDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLEIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLEJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLERealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLEStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLETimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLTDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLTDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLTIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLTJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLTRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLTStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLTTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLTrimSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLastDaySig"
"expression.baseBuiltinFunc" *-- "expression.builtinLastInsertIDSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLastInsertIDWithIDSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLastValSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLeastDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLeastIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLeastRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLeastStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLeastTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLeftShiftSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLeftSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLeftUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinLengthSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLikeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLocate2ArgsSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLocate2ArgsUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinLocate3ArgsSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLocate3ArgsUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinLockSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLog10Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinLog1ArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLog2ArgsSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLog2Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinLogicAndSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLogicOrSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLogicXorSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLowerSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLpadSig"
"expression.baseBuiltinFunc" *-- "expression.builtinLpadUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinMD5Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinMakeDateSig"
"expression.baseBuiltinFunc" *-- "expression.builtinMakeSetSig"
"expression.baseBuiltinFunc" *-- "expression.builtinMakeTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinMicroSecondSig"
"expression.baseBuiltinFunc" *-- "expression.builtinMinuteSig"
"expression.baseBuiltinFunc" *-- "expression.builtinMonthNameSig"
"expression.baseBuiltinFunc" *-- "expression.builtinMonthSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNEDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNEDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNEIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNEJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNERealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNEStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNETimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNameConstDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNameConstDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNameConstIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNameConstJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNameConstRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNameConstStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNameConstTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNextValSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNowWithArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNowWithoutArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNullEQDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNullEQDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNullEQIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNullEQJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNullEQRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNullEQStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNullEQTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinNullTimeDiffSig"
"expression.baseBuiltinFunc" *-- "expression.builtinOctIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinOctStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinOrdSig"
"expression.baseBuiltinFunc" *-- "expression.builtinPISig"
"expression.baseBuiltinFunc" *-- "expression.builtinPasswordSig"
"expression.baseBuiltinFunc" *-- "expression.builtinPeriodAddSig"
"expression.baseBuiltinFunc" *-- "expression.builtinPeriodDiffSig"
"expression.baseBuiltinFunc" *-- "expression.builtinPowSig"
"expression.baseBuiltinFunc" *-- "expression.builtinQuarterSig"
"expression.baseBuiltinFunc" *-- "expression.builtinQuoteSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRTrimSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRadiansSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRandSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRandWithSeedFirstGenSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRandomBytesSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRealAnyValueSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRealIsFalseSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRealIsNullSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRealIsTrueSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRegexpSharedSig"
"expression.builtinRegexpSharedSig" *-- "expression.builtinRegexpSig"
"expression.builtinRegexpSharedSig" *-- "expression.builtinRegexpUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinReleaseLockSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRepeatSig"
"expression.baseBuiltinFunc" *-- "expression.builtinReplaceSig"
"expression.baseBuiltinFunc" *-- "expression.builtinReverseSig"
"expression.baseBuiltinFunc" *-- "expression.builtinReverseUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinRightShiftSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRightSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRightUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinRoundDecSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRoundIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRoundRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRoundWithFracDecSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRoundWithFracIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRoundWithFracRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRowCountSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRowSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRpadSig"
"expression.baseBuiltinFunc" *-- "expression.builtinRpadUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinSHA1Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinSHA2Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinSecToTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSecondSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSetValSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSetVarSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSignSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSinSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSleepSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSpaceSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSqrtSig"
"expression.baseBuiltinFunc" *-- "expression.builtinStrToDateDateSig"
"expression.baseBuiltinFunc" *-- "expression.builtinStrToDateDatetimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinStrToDateDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinStrcmpSig"
"expression.baseBuiltinFunc" *-- "expression.builtinStringAnyValueSig"
"expression.baseBuiltinFunc" *-- "expression.builtinStringDurationTimeDiffSig"
"expression.baseBuiltinFunc" *-- "expression.builtinStringIsNullSig"
"expression.baseBuiltinFunc" *-- "expression.builtinStringStringTimeDiffSig"
"expression.baseBuiltinFunc" *-- "expression.builtinStringTimeTimeDiffSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateAndDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateAndStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateDatetimeDecimalSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateDatetimeDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateDatetimeIntSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateDatetimeIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateDatetimeRealSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateDatetimeRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateDatetimeStringSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateDatetimeStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateDurationDecimalSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateDurationDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateDurationIntSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateDurationIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateDurationRealSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateDurationRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateDurationStringSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateDurationStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateIntDecimalSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateIntDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateIntIntSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateIntIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateIntRealSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateIntRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateIntStringSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateIntStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateStringDecimalSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateStringDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateStringIntSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateStringIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateStringRealSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateStringRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDateStringStringSig"
"expression.baseDateArithmitical" *-- "expression.builtinSubDateStringStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDatetimeAndDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDatetimeAndStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDurationAndDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubDurationAndStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubStringAndDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubStringAndStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubTimeDateTimeNullSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubTimeDurationNullSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubTimeStringNullSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubstring2ArgsSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubstring2ArgsUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubstring3ArgsSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubstring3ArgsUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinSubstringIndexSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSysDateWithFspSig"
"expression.baseBuiltinFunc" *-- "expression.builtinSysDateWithoutFspSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTanSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTiDBDecodeKeySig"
"expression.baseBuiltinFunc" *-- "expression.builtinTiDBDecodePlanSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTiDBIsDDLOwnerSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTiDBVersionSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTidbParseTsoSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTimeAnyValueSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTimeFormatSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTimeIsNullSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTimeLiteralSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTimeStringTimeDiffSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTimeTimeTimeDiffSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTimeToSecSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTimestamp1ArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTimestamp2ArgsSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTimestampAddSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTimestampDiffSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTimestampLiteralSig"
"expression.baseBuiltinFunc" *-- "expression.builtinToBase64Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinToDaysSig"
"expression.baseBuiltinFunc" *-- "expression.builtinToSecondsSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTrim1ArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTrim2ArgsSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTrim3ArgsSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTruncateDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTruncateIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTruncateRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinTruncateUintSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUTCDateSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUTCTimeWithArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUTCTimeWithoutArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUTCTimestampWithArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUTCTimestampWithoutArgSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUUIDSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUnHexSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUnaryMinusDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUnaryMinusIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUnaryMinusRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUnaryNotDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUnaryNotIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUnaryNotRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUncompressSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUncompressedLengthSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUnixTimestampCurrentSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUnixTimestampDecSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUnixTimestampIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUpperSig"
"expression.baseBuiltinFunc" *-- "expression.builtinUpperUTF8Sig"
"expression.baseBuiltinFunc" *-- "expression.builtinUserSig"
"expression.baseBuiltinFunc" *-- "expression.builtinValuesDecimalSig"
"expression.baseBuiltinFunc" *-- "expression.builtinValuesDurationSig"
"expression.baseBuiltinFunc" *-- "expression.builtinValuesIntSig"
"expression.baseBuiltinFunc" *-- "expression.builtinValuesJSONSig"
"expression.baseBuiltinFunc" *-- "expression.builtinValuesRealSig"
"expression.baseBuiltinFunc" *-- "expression.builtinValuesStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinValuesTimeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinVersionSig"
"expression.baseBuiltinFunc" *-- "expression.builtinWeekDaySig"
"expression.baseBuiltinFunc" *-- "expression.builtinWeekOfYearSig"
"expression.baseBuiltinFunc" *-- "expression.builtinWeekWithModeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinWeekWithoutModeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinWeightStringNullSig"
"expression.baseBuiltinFunc" *-- "expression.builtinWeightStringSig"
"expression.baseBuiltinFunc" *-- "expression.builtinYearSig"
"expression.baseBuiltinFunc" *-- "expression.builtinYearWeekWithModeSig"
"expression.baseBuiltinFunc" *-- "expression.builtinYearWeekWithoutModeSig"
"expression.baseFunctionClass" *-- "expression.caseWhenFunctionClass"
"expression.baseFunctionClass" *-- "expression.castAsDecimalFunctionClass"
"expression.baseFunctionClass" *-- "expression.castAsDurationFunctionClass"
"expression.baseFunctionClass" *-- "expression.castAsIntFunctionClass"
"expression.baseFunctionClass" *-- "expression.castAsJSONFunctionClass"
"expression.baseFunctionClass" *-- "expression.castAsRealFunctionClass"
"expression.baseFunctionClass" *-- "expression.castAsStringFunctionClass"
"expression.baseFunctionClass" *-- "expression.castAsTimeFunctionClass"
"expression.baseFunctionClass" *-- "expression.ceilFunctionClass"
"expression.baseFunctionClass" *-- "expression.charFunctionClass"
"expression.baseFunctionClass" *-- "expression.charLengthFunctionClass"
"expression.baseFunctionClass" *-- "expression.charsetFunctionClass"
"expression.baseFunctionClass" *-- "expression.coalesceFunctionClass"
"expression.baseFunctionClass" *-- "expression.coercibilityFunctionClass"
"expression.baseFunctionClass" *-- "expression.collationFunctionClass"
"expression.baseFunctionClass" *-- "expression.compareFunctionClass"
"expression.baseFunctionClass" *-- "expression.compressFunctionClass"
"expression.baseFunctionClass" *-- "expression.concatFunctionClass"
"expression.baseFunctionClass" *-- "expression.concatWSFunctionClass"
"expression.baseFunctionClass" *-- "expression.connectionIDFunctionClass"
"expression.baseFunctionClass" *-- "expression.convFunctionClass"
"expression.baseFunctionClass" *-- "expression.convertFunctionClass"
"expression.baseFunctionClass" *-- "expression.convertTzFunctionClass"
"expression.baseFunctionClass" *-- "expression.cosFunctionClass"
"expression.baseFunctionClass" *-- "expression.cotFunctionClass"
"expression.baseFunctionClass" *-- "expression.crc32FunctionClass"
"expression.baseFunctionClass" *-- "expression.currentDateFunctionClass"
"expression.baseFunctionClass" *-- "expression.currentRoleFunctionClass"
"expression.baseFunctionClass" *-- "expression.currentTimeFunctionClass"
"expression.baseFunctionClass" *-- "expression.currentUserFunctionClass"
"expression.baseFunctionClass" *-- "expression.databaseFunctionClass"
"expression.baseFunctionClass" *-- "expression.dateDiffFunctionClass"
"expression.baseFunctionClass" *-- "expression.dateFormatFunctionClass"
"expression.baseFunctionClass" *-- "expression.dateFunctionClass"
"expression.baseFunctionClass" *-- "expression.dateLiteralFunctionClass"
"expression.baseFunctionClass" *-- "expression.dayNameFunctionClass"
"expression.baseFunctionClass" *-- "expression.dayOfMonthFunctionClass"
"expression.baseFunctionClass" *-- "expression.dayOfWeekFunctionClass"
"expression.baseFunctionClass" *-- "expression.dayOfYearFunctionClass"
"expression.baseFunctionClass" *-- "expression.decodeFunctionClass"
"expression.baseFunctionClass" *-- "expression.defaultFunctionClass"
"expression.baseFunctionClass" *-- "expression.degreesFunctionClass"
"expression.baseFunctionClass" *-- "expression.desDecryptFunctionClass"
"expression.baseFunctionClass" *-- "expression.desEncryptFunctionClass"
"expression.baseFunctionClass" *-- "expression.eltFunctionClass"
"expression.baseFunctionClass" *-- "expression.encodeFunctionClass"
"expression.baseFunctionClass" *-- "expression.encryptFunctionClass"
"expression.baseFunctionClass" *-- "expression.expFunctionClass"
"expression.baseFunctionClass" *-- "expression.exportSetFunctionClass"
"expression.baseFunctionClass" *-- "expression.extractFunctionClass"
"expression.baseFunctionClass" *-- "expression.fieldFunctionClass"
"expression.baseFunctionClass" *-- "expression.findInSetFunctionClass"
"expression.baseFunctionClass" *-- "expression.floorFunctionClass"
"expression.baseFunctionClass" *-- "expression.formatBytesFunctionClass"
"expression.baseFunctionClass" *-- "expression.formatFunctionClass"
"expression.baseFunctionClass" *-- "expression.formatNanoTimeFunctionClass"
"expression.baseFunctionClass" *-- "expression.foundRowsFunctionClass"
"expression.baseFunctionClass" *-- "expression.fromBase64FunctionClass"
"expression.baseFunctionClass" *-- "expression.fromDaysFunctionClass"
"expression.baseFunctionClass" *-- "expression.fromUnixTimeFunctionClass"
"expression.baseFunctionClass" *-- "expression.getFormatFunctionClass"
"expression.baseFunctionClass" *-- "expression.getParamFunctionClass"
"expression.baseFunctionClass" *-- "expression.getVarFunctionClass"
"expression.baseFunctionClass" *-- "expression.greatestFunctionClass"
"expression.baseFunctionClass" *-- "expression.hexFunctionClass"
"expression.baseFunctionClass" *-- "expression.hourFunctionClass"
"expression.baseFunctionClass" *-- "expression.ifFunctionClass"
"expression.baseFunctionClass" *-- "expression.ifNullFunctionClass"
"expression.baseFunctionClass" *-- "expression.inFunctionClass"
"expression.baseFunctionClass" *-- "expression.inet6AtonFunctionClass"
"expression.baseFunctionClass" *-- "expression.inet6NtoaFunctionClass"
"expression.baseFunctionClass" *-- "expression.inetAtonFunctionClass"
"expression.baseFunctionClass" *-- "expression.inetNtoaFunctionClass"
"expression.baseFunctionClass" *-- "expression.insertFunctionClass"
"expression.baseFunctionClass" *-- "expression.instrFunctionClass"
"expression.baseFunctionClass" *-- "expression.intervalFunctionClass"
"expression.baseFunctionClass" *-- "expression.isFreeLockFunctionClass"
"expression.baseFunctionClass" *-- "expression.isIPv4CompatFunctionClass"
"expression.baseFunctionClass" *-- "expression.isIPv4FunctionClass"
"expression.baseFunctionClass" *-- "expression.isIPv4MappedFunctionClass"
"expression.baseFunctionClass" *-- "expression.isIPv6FunctionClass"
"expression.baseFunctionClass" *-- "expression.isNullFunctionClass"
"expression.baseFunctionClass" *-- "expression.isTrueOrFalseFunctionClass"
"expression.baseFunctionClass" *-- "expression.isUsedLockFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonArrayAppendFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonArrayFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonArrayInsertFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonContainsFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonContainsPathFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonDepthFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonExtractFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonInsertFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonKeysFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonLengthFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonMergeFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonMergePatchFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonMergePreserveFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonObjectFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonPrettyFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonQuoteFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonRemoveFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonReplaceFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonSearchFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonSetFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonStorageSizeFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonTypeFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonUnquoteFunctionClass"
"expression.baseFunctionClass" *-- "expression.jsonValidFunctionClass"
"expression.baseFunctionClass" *-- "expression.lTrimFunctionClass"
"expression.baseFunctionClass" *-- "expression.lastDayFunctionClass"
"expression.baseFunctionClass" *-- "expression.lastInsertIDFunctionClass"
"expression.baseFunctionClass" *-- "expression.lastValFunctionClass"
"expression.baseFunctionClass" *-- "expression.leastFunctionClass"
"expression.baseFunctionClass" *-- "expression.leftFunctionClass"
"expression.baseFunctionClass" *-- "expression.leftShiftFunctionClass"
"expression.baseFunctionClass" *-- "expression.lengthFunctionClass"
"expression.baseFunctionClass" *-- "expression.likeFunctionClass"
"expression.baseFunctionClass" *-- "expression.loadFileFunctionClass"
"sync.Mutex" *-- "expression.localSliceBuffer"
"expression.baseFunctionClass" *-- "expression.locateFunctionClass"
"expression.baseFunctionClass" *-- "expression.lockFunctionClass"
"expression.baseFunctionClass" *-- "expression.log10FunctionClass"
"expression.baseFunctionClass" *-- "expression.log2FunctionClass"
"expression.baseFunctionClass" *-- "expression.logFunctionClass"
"expression.baseFunctionClass" *-- "expression.logicAndFunctionClass"
"expression.baseFunctionClass" *-- "expression.logicOrFunctionClass"
"expression.baseFunctionClass" *-- "expression.logicXorFunctionClass"
"expression.baseFunctionClass" *-- "expression.lowerFunctionClass"
"expression.baseFunctionClass" *-- "expression.lpadFunctionClass"
"expression.baseFunctionClass" *-- "expression.makeDateFunctionClass"
"expression.baseFunctionClass" *-- "expression.makeSetFunctionClass"
"expression.baseFunctionClass" *-- "expression.makeTimeFunctionClass"
"expression.baseFunctionClass" *-- "expression.masterPosWaitFunctionClass"
"expression.baseFunctionClass" *-- "expression.md5FunctionClass"
"expression.baseFunctionClass" *-- "expression.microSecondFunctionClass"
"expression.baseFunctionClass" *-- "expression.minuteFunctionClass"
"expression.baseFunctionClass" *-- "expression.monthFunctionClass"
"expression.baseFunctionClass" *-- "expression.monthNameFunctionClass"
"expression.baseFunctionClass" *-- "expression.nameConstFunctionClass"
"expression.baseFunctionClass" *-- "expression.nextValFunctionClass"
"expression.baseFunctionClass" *-- "expression.nowFunctionClass"
"expression.baseFunctionClass" *-- "expression.octFunctionClass"
"expression.baseFunctionClass" *-- "expression.oldPasswordFunctionClass"
"expression.baseFunctionClass" *-- "expression.ordFunctionClass"
"expression.baseFunctionClass" *-- "expression.passwordFunctionClass"
"expression.baseFunctionClass" *-- "expression.periodAddFunctionClass"
"expression.baseFunctionClass" *-- "expression.periodDiffFunctionClass"
"expression.baseFunctionClass" *-- "expression.piFunctionClass"
"expression.baseFunctionClass" *-- "expression.powFunctionClass"
"expression.basePropConstSolver" *-- "expression.propConstSolver"
"expression.basePropConstSolver" *-- "expression.propOuterJoinConstSolver"
"expression.baseFunctionClass" *-- "expression.quarterFunctionClass"
"expression.baseFunctionClass" *-- "expression.quoteFunctionClass"
"expression.baseFunctionClass" *-- "expression.rTrimFunctionClass"
"expression.baseFunctionClass" *-- "expression.radiansFunctionClass"
"expression.baseFunctionClass" *-- "expression.randFunctionClass"
"expression.baseFunctionClass" *-- "expression.randomBytesFunctionClass"
"expression.baseFunctionClass" *-- "expression.regexpFunctionClass"
"expression.baseFunctionClass" *-- "expression.releaseAllLocksFunctionClass"
"expression.baseFunctionClass" *-- "expression.releaseLockFunctionClass"
"expression.baseFunctionClass" *-- "expression.repeatFunctionClass"
"expression.baseFunctionClass" *-- "expression.replaceFunctionClass"
"expression.baseFunctionClass" *-- "expression.reverseFunctionClass"
"expression.baseFunctionClass" *-- "expression.rightFunctionClass"
"expression.baseFunctionClass" *-- "expression.rightShiftFunctionClass"
"expression.baseFunctionClass" *-- "expression.roundFunctionClass"
"expression.baseFunctionClass" *-- "expression.rowCountFunctionClass"
"expression.baseFunctionClass" *-- "expression.rowFunctionClass"
"expression.baseFunctionClass" *-- "expression.rpadFunctionClass"
"expression.baseFunctionClass" *-- "expression.secToTimeFunctionClass"
"expression.baseFunctionClass" *-- "expression.secondFunctionClass"
"expression.baseFunctionClass" *-- "expression.setValFunctionClass"
"expression.baseFunctionClass" *-- "expression.setVarFunctionClass"
"expression.baseFunctionClass" *-- "expression.sha1FunctionClass"
"expression.baseFunctionClass" *-- "expression.sha2FunctionClass"
"expression.baseFunctionClass" *-- "expression.signFunctionClass"
"expression.exprStack" *-- "expression.simpleRewriter"
"expression.baseFunctionClass" *-- "expression.sinFunctionClass"
"expression.baseFunctionClass" *-- "expression.sleepFunctionClass"
"expression.baseFunctionClass" *-- "expression.spaceFunctionClass"
"expression.baseFunctionClass" *-- "expression.sqrtFunctionClass"
"expression.baseFunctionClass" *-- "expression.strToDateFunctionClass"
"expression.baseFunctionClass" *-- "expression.strcmpFunctionClass"
"expression.baseFunctionClass" *-- "expression.subDateFunctionClass"
"expression.baseFunctionClass" *-- "expression.subTimeFunctionClass"
"expression.baseFunctionClass" *-- "expression.substringFunctionClass"
"expression.baseFunctionClass" *-- "expression.substringIndexFunctionClass"
"expression.baseFunctionClass" *-- "expression.sysDateFunctionClass"
"expression.baseFunctionClass" *-- "expression.tanFunctionClass"
"expression.baseFunctionClass" *-- "expression.tidbDecodeKeyFunctionClass"
"expression.baseFunctionClass" *-- "expression.tidbDecodePlanFunctionClass"
"expression.baseFunctionClass" *-- "expression.tidbIsDDLOwnerFunctionClass"
"expression.baseFunctionClass" *-- "expression.tidbParseTsoFunctionClass"
"expression.baseFunctionClass" *-- "expression.tidbVersionFunctionClass"
"expression.baseFunctionClass" *-- "expression.timeDiffFunctionClass"
"expression.baseFunctionClass" *-- "expression.timeFormatFunctionClass"
"expression.baseFunctionClass" *-- "expression.timeFunctionClass"
"expression.baseFunctionClass" *-- "expression.timeLiteralFunctionClass"
"expression.baseFunctionClass" *-- "expression.timeToSecFunctionClass"
"expression.baseFunctionClass" *-- "expression.timestampAddFunctionClass"
"expression.baseFunctionClass" *-- "expression.timestampDiffFunctionClass"
"expression.baseFunctionClass" *-- "expression.timestampFunctionClass"
"expression.baseFunctionClass" *-- "expression.timestampLiteralFunctionClass"
"expression.baseFunctionClass" *-- "expression.toBase64FunctionClass"
"expression.baseFunctionClass" *-- "expression.toDaysFunctionClass"
"expression.baseFunctionClass" *-- "expression.toSecondsFunctionClass"
"expression.baseFunctionClass" *-- "expression.trimFunctionClass"
"expression.baseFunctionClass" *-- "expression.truncateFunctionClass"
"expression.baseFunctionClass" *-- "expression.unaryMinusFunctionClass"
"expression.baseFunctionClass" *-- "expression.unaryNotFunctionClass"
"expression.baseFunctionClass" *-- "expression.uncompressFunctionClass"
"expression.baseFunctionClass" *-- "expression.uncompressedLengthFunctionClass"
"expression.baseFunctionClass" *-- "expression.unhexFunctionClass"
"expression.baseFunctionClass" *-- "expression.unixTimestampFunctionClass"
"expression.baseFunctionClass" *-- "expression.upperFunctionClass"
"expression.baseFunctionClass" *-- "expression.userFunctionClass"
"expression.baseFunctionClass" *-- "expression.utcDateFunctionClass"
"expression.baseFunctionClass" *-- "expression.utcTimeFunctionClass"
"expression.baseFunctionClass" *-- "expression.utcTimestampFunctionClass"
"expression.baseFunctionClass" *-- "expression.uuidFunctionClass"
"expression.baseFunctionClass" *-- "expression.uuidShortFunctionClass"
"expression.baseFunctionClass" *-- "expression.validatePasswordStrengthFunctionClass"
"expression.baseFunctionClass" *-- "expression.valuesFunctionClass"
"expression.baseFunctionClass" *-- "expression.versionFunctionClass"
"expression.baseFunctionClass" *-- "expression.weekDayFunctionClass"
"expression.baseFunctionClass" *-- "expression.weekFunctionClass"
"expression.baseFunctionClass" *-- "expression.weekOfYearFunctionClass"
"expression.baseFunctionClass" *-- "expression.weightStringFunctionClass"
"expression.baseFunctionClass" *-- "expression.yearFunctionClass"
"expression.baseFunctionClass" *-- "expression.yearWeekFunctionClass"

"expression.Expression" <|-- "expression.Column"
"expression.ReverseExpr" <|-- "expression.Column"
"expression.VecExpr" <|-- "expression.Column"
"expression.Expression" <|-- "expression.Constant"
"expression.ReverseExpr" <|-- "expression.Constant"
"expression.VecExpr" <|-- "expression.Constant"
"expression.CollationInfo" <|-- "expression.ScalarFunction"
"expression.Expression" <|-- "expression.ScalarFunction"
"expression.ReverseExpr" <|-- "expression.ScalarFunction"
"expression.VecExpr" <|-- "expression.ScalarFunction"
"expression.functionClass" <|-- "expression.absFunctionClass"
"expression.functionClass" <|-- "expression.acosFunctionClass"
"expression.functionClass" <|-- "expression.addDateFunctionClass"
"expression.functionClass" <|-- "expression.addTimeFunctionClass"
"expression.functionClass" <|-- "expression.aesDecryptFunctionClass"
"expression.functionClass" <|-- "expression.aesEncryptFunctionClass"
"expression.functionClass" <|-- "expression.anyValueFunctionClass"
"expression.functionClass" <|-- "expression.arithmeticDivideFunctionClass"
"expression.functionClass" <|-- "expression.arithmeticIntDivideFunctionClass"
"expression.functionClass" <|-- "expression.arithmeticMinusFunctionClass"
"expression.functionClass" <|-- "expression.arithmeticModFunctionClass"
"expression.functionClass" <|-- "expression.arithmeticMultiplyFunctionClass"
"expression.functionClass" <|-- "expression.arithmeticPlusFunctionClass"
"expression.functionClass" <|-- "expression.asciiFunctionClass"
"expression.functionClass" <|-- "expression.asinFunctionClass"
"expression.functionClass" <|-- "expression.atanFunctionClass"
"expression.builtinFunc" <|-- "expression.baseBuiltinFunc"
"expression.reverseBuiltinFunc" <|-- "expression.baseBuiltinFunc"
"expression.vecBuiltinFunc" <|-- "expression.baseBuiltinFunc"
"expression.functionClass" <|-- "expression.benchmarkFunctionClass"
"expression.functionClass" <|-- "expression.binFunctionClass"
"expression.functionClass" <|-- "expression.bitAndFunctionClass"
"expression.functionClass" <|-- "expression.bitCountFunctionClass"
"expression.functionClass" <|-- "expression.bitLengthFunctionClass"
"expression.functionClass" <|-- "expression.bitNegFunctionClass"
"expression.functionClass" <|-- "expression.bitOrFunctionClass"
"expression.functionClass" <|-- "expression.bitXorFunctionClass"
"expression.builtinFuncNew" <|-- "expression.builtinArithmeticIntDivideIntSig"
"expression.builtinFuncNew" <|-- "expression.builtinLTIntSig"
"expression.builtinFuncNew" <|-- "expression.builtinUnixTimestampIntSig"
"expression.functionClass" <|-- "expression.caseWhenFunctionClass"
"expression.functionClass" <|-- "expression.castAsDecimalFunctionClass"
"expression.functionClass" <|-- "expression.castAsDurationFunctionClass"
"expression.functionClass" <|-- "expression.castAsIntFunctionClass"
"expression.functionClass" <|-- "expression.castAsJSONFunctionClass"
"expression.functionClass" <|-- "expression.castAsRealFunctionClass"
"expression.functionClass" <|-- "expression.castAsStringFunctionClass"
"expression.functionClass" <|-- "expression.castAsTimeFunctionClass"
"expression.functionClass" <|-- "expression.ceilFunctionClass"
"expression.functionClass" <|-- "expression.charFunctionClass"
"expression.functionClass" <|-- "expression.charLengthFunctionClass"
"expression.functionClass" <|-- "expression.charsetFunctionClass"
"expression.functionClass" <|-- "expression.coalesceFunctionClass"
"expression.functionClass" <|-- "expression.coercibilityFunctionClass"
"expression.functionClass" <|-- "expression.collationFunctionClass"
"expression.CollationInfo" <|-- "expression.collationInfo"
"expression.functionClass" <|-- "expression.compareFunctionClass"
"expression.functionClass" <|-- "expression.compressFunctionClass"
"expression.functionClass" <|-- "expression.concatFunctionClass"
"expression.functionClass" <|-- "expression.concatWSFunctionClass"
"expression.functionClass" <|-- "expression.connectionIDFunctionClass"
"expression.functionClass" <|-- "expression.convFunctionClass"
"expression.functionClass" <|-- "expression.convertFunctionClass"
"expression.functionClass" <|-- "expression.convertTzFunctionClass"
"expression.functionClass" <|-- "expression.cosFunctionClass"
"expression.functionClass" <|-- "expression.cotFunctionClass"
"expression.functionClass" <|-- "expression.crc32FunctionClass"
"expression.functionClass" <|-- "expression.currentDateFunctionClass"
"expression.functionClass" <|-- "expression.currentRoleFunctionClass"
"expression.functionClass" <|-- "expression.currentTimeFunctionClass"
"expression.functionClass" <|-- "expression.currentUserFunctionClass"
"expression.functionClass" <|-- "expression.databaseFunctionClass"
"expression.functionClass" <|-- "expression.dateDiffFunctionClass"
"expression.functionClass" <|-- "expression.dateFormatFunctionClass"
"expression.functionClass" <|-- "expression.dateFunctionClass"
"expression.functionClass" <|-- "expression.dateLiteralFunctionClass"
"expression.functionClass" <|-- "expression.dayNameFunctionClass"
"expression.functionClass" <|-- "expression.dayOfMonthFunctionClass"
"expression.functionClass" <|-- "expression.dayOfWeekFunctionClass"
"expression.functionClass" <|-- "expression.dayOfYearFunctionClass"
"expression.functionClass" <|-- "expression.decodeFunctionClass"
"expression.functionClass" <|-- "expression.defaultFunctionClass"
"expression.functionClass" <|-- "expression.degreesFunctionClass"
"expression.functionClass" <|-- "expression.desDecryptFunctionClass"
"expression.functionClass" <|-- "expression.desEncryptFunctionClass"
"expression.functionClass" <|-- "expression.eltFunctionClass"
"expression.functionClass" <|-- "expression.encodeFunctionClass"
"expression.functionClass" <|-- "expression.encryptFunctionClass"
"expression.functionClass" <|-- "expression.expFunctionClass"
"expression.functionClass" <|-- "expression.exportSetFunctionClass"
"expression.functionClass" <|-- "expression.extractFunctionClass"
"expression.functionClass" <|-- "expression.fieldFunctionClass"
"expression.functionClass" <|-- "expression.findInSetFunctionClass"
"expression.functionClass" <|-- "expression.floorFunctionClass"
"expression.functionClass" <|-- "expression.formatBytesFunctionClass"
"expression.functionClass" <|-- "expression.formatFunctionClass"
"expression.functionClass" <|-- "expression.formatNanoTimeFunctionClass"
"expression.functionClass" <|-- "expression.foundRowsFunctionClass"
"expression.functionClass" <|-- "expression.fromBase64FunctionClass"
"expression.functionClass" <|-- "expression.fromDaysFunctionClass"
"expression.functionClass" <|-- "expression.fromUnixTimeFunctionClass"
"expression.functionClass" <|-- "expression.getFormatFunctionClass"
"expression.functionClass" <|-- "expression.getParamFunctionClass"
"expression.functionClass" <|-- "expression.getVarFunctionClass"
"expression.functionClass" <|-- "expression.greatestFunctionClass"
"expression.functionClass" <|-- "expression.hexFunctionClass"
"expression.functionClass" <|-- "expression.hourFunctionClass"
"expression.functionClass" <|-- "expression.ifFunctionClass"
"expression.functionClass" <|-- "expression.ifNullFunctionClass"
"expression.functionClass" <|-- "expression.inFunctionClass"
"expression.functionClass" <|-- "expression.inet6AtonFunctionClass"
"expression.functionClass" <|-- "expression.inet6NtoaFunctionClass"
"expression.functionClass" <|-- "expression.inetAtonFunctionClass"
"expression.functionClass" <|-- "expression.inetNtoaFunctionClass"
"expression.functionClass" <|-- "expression.insertFunctionClass"
"expression.functionClass" <|-- "expression.instrFunctionClass"
"expression.functionClass" <|-- "expression.intervalFunctionClass"
"expression.functionClass" <|-- "expression.isFreeLockFunctionClass"
"expression.functionClass" <|-- "expression.isIPv4CompatFunctionClass"
"expression.functionClass" <|-- "expression.isIPv4FunctionClass"
"expression.functionClass" <|-- "expression.isIPv4MappedFunctionClass"
"expression.functionClass" <|-- "expression.isIPv6FunctionClass"
"expression.functionClass" <|-- "expression.isNullFunctionClass"
"expression.functionClass" <|-- "expression.isTrueOrFalseFunctionClass"
"expression.functionClass" <|-- "expression.isUsedLockFunctionClass"
"expression.functionClass" <|-- "expression.jsonArrayAppendFunctionClass"
"expression.functionClass" <|-- "expression.jsonArrayFunctionClass"
"expression.functionClass" <|-- "expression.jsonArrayInsertFunctionClass"
"expression.functionClass" <|-- "expression.jsonContainsFunctionClass"
"expression.functionClass" <|-- "expression.jsonContainsPathFunctionClass"
"expression.functionClass" <|-- "expression.jsonDepthFunctionClass"
"expression.functionClass" <|-- "expression.jsonExtractFunctionClass"
"expression.functionClass" <|-- "expression.jsonInsertFunctionClass"
"expression.functionClass" <|-- "expression.jsonKeysFunctionClass"
"expression.functionClass" <|-- "expression.jsonLengthFunctionClass"
"expression.functionClass" <|-- "expression.jsonMergeFunctionClass"
"expression.functionClass" <|-- "expression.jsonMergePatchFunctionClass"
"expression.functionClass" <|-- "expression.jsonMergePreserveFunctionClass"
"expression.functionClass" <|-- "expression.jsonObjectFunctionClass"
"expression.functionClass" <|-- "expression.jsonPrettyFunctionClass"
"expression.functionClass" <|-- "expression.jsonQuoteFunctionClass"
"expression.functionClass" <|-- "expression.jsonRemoveFunctionClass"
"expression.functionClass" <|-- "expression.jsonReplaceFunctionClass"
"expression.functionClass" <|-- "expression.jsonSearchFunctionClass"
"expression.functionClass" <|-- "expression.jsonSetFunctionClass"
"expression.functionClass" <|-- "expression.jsonStorageSizeFunctionClass"
"expression.functionClass" <|-- "expression.jsonTypeFunctionClass"
"expression.functionClass" <|-- "expression.jsonUnquoteFunctionClass"
"expression.functionClass" <|-- "expression.jsonValidFunctionClass"
"expression.functionClass" <|-- "expression.lTrimFunctionClass"
"expression.functionClass" <|-- "expression.lastDayFunctionClass"
"expression.functionClass" <|-- "expression.lastInsertIDFunctionClass"
"expression.functionClass" <|-- "expression.lastValFunctionClass"
"expression.functionClass" <|-- "expression.leastFunctionClass"
"expression.functionClass" <|-- "expression.leftFunctionClass"
"expression.functionClass" <|-- "expression.leftShiftFunctionClass"
"expression.functionClass" <|-- "expression.lengthFunctionClass"
"expression.functionClass" <|-- "expression.likeFunctionClass"
"expression.functionClass" <|-- "expression.loadFileFunctionClass"
"expression.columnBufferAllocator" <|-- "expression.localSliceBuffer"
"expression.functionClass" <|-- "expression.locateFunctionClass"
"expression.functionClass" <|-- "expression.lockFunctionClass"
"expression.functionClass" <|-- "expression.log10FunctionClass"
"expression.functionClass" <|-- "expression.log2FunctionClass"
"expression.functionClass" <|-- "expression.logFunctionClass"
"expression.functionClass" <|-- "expression.logicAndFunctionClass"
"expression.functionClass" <|-- "expression.logicOrFunctionClass"
"expression.functionClass" <|-- "expression.logicXorFunctionClass"
"expression.functionClass" <|-- "expression.lowerFunctionClass"
"expression.functionClass" <|-- "expression.lpadFunctionClass"
"expression.functionClass" <|-- "expression.makeDateFunctionClass"
"expression.functionClass" <|-- "expression.makeSetFunctionClass"
"expression.functionClass" <|-- "expression.makeTimeFunctionClass"
"expression.functionClass" <|-- "expression.masterPosWaitFunctionClass"
"expression.functionClass" <|-- "expression.md5FunctionClass"
"expression.functionClass" <|-- "expression.microSecondFunctionClass"
"expression.functionClass" <|-- "expression.minuteFunctionClass"
"expression.functionClass" <|-- "expression.monthFunctionClass"
"expression.functionClass" <|-- "expression.monthNameFunctionClass"
"expression.functionClass" <|-- "expression.nameConstFunctionClass"
"expression.functionClass" <|-- "expression.nextValFunctionClass"
"expression.functionClass" <|-- "expression.nowFunctionClass"
"expression.functionClass" <|-- "expression.octFunctionClass"
"expression.functionClass" <|-- "expression.oldPasswordFunctionClass"
"expression.functionClass" <|-- "expression.ordFunctionClass"
"expression.functionClass" <|-- "expression.passwordFunctionClass"
"expression.functionClass" <|-- "expression.periodAddFunctionClass"
"expression.functionClass" <|-- "expression.periodDiffFunctionClass"
"expression.functionClass" <|-- "expression.piFunctionClass"
"expression.functionClass" <|-- "expression.powFunctionClass"
"expression.PropagateConstantSolver" <|-- "expression.propConstSolver"
"expression.functionClass" <|-- "expression.quarterFunctionClass"
"expression.functionClass" <|-- "expression.quoteFunctionClass"
"expression.functionClass" <|-- "expression.rTrimFunctionClass"
"expression.functionClass" <|-- "expression.radiansFunctionClass"
"expression.functionClass" <|-- "expression.randFunctionClass"
"expression.functionClass" <|-- "expression.randomBytesFunctionClass"
"expression.functionClass" <|-- "expression.regexpFunctionClass"
"expression.functionClass" <|-- "expression.releaseAllLocksFunctionClass"
"expression.functionClass" <|-- "expression.releaseLockFunctionClass"
"expression.functionClass" <|-- "expression.repeatFunctionClass"
"expression.functionClass" <|-- "expression.replaceFunctionClass"
"expression.functionClass" <|-- "expression.reverseFunctionClass"
"expression.functionClass" <|-- "expression.rightFunctionClass"
"expression.functionClass" <|-- "expression.rightShiftFunctionClass"
"expression.functionClass" <|-- "expression.roundFunctionClass"
"expression.functionClass" <|-- "expression.rowCountFunctionClass"
"expression.functionClass" <|-- "expression.rowFunctionClass"
"expression.functionClass" <|-- "expression.rpadFunctionClass"
"expression.functionClass" <|-- "expression.secToTimeFunctionClass"
"expression.functionClass" <|-- "expression.secondFunctionClass"
"expression.functionClass" <|-- "expression.setValFunctionClass"
"expression.functionClass" <|-- "expression.setVarFunctionClass"
"expression.functionClass" <|-- "expression.sha1FunctionClass"
"expression.functionClass" <|-- "expression.sha2FunctionClass"
"expression.functionClass" <|-- "expression.signFunctionClass"
"expression.functionClass" <|-- "expression.sinFunctionClass"
"expression.functionClass" <|-- "expression.sleepFunctionClass"
"expression.functionClass" <|-- "expression.spaceFunctionClass"
"expression.functionClass" <|-- "expression.sqrtFunctionClass"
"expression.functionClass" <|-- "expression.strToDateFunctionClass"
"expression.functionClass" <|-- "expression.strcmpFunctionClass"
"expression.functionClass" <|-- "expression.subDateFunctionClass"
"expression.functionClass" <|-- "expression.subTimeFunctionClass"
"expression.functionClass" <|-- "expression.substringFunctionClass"
"expression.functionClass" <|-- "expression.substringIndexFunctionClass"
"expression.functionClass" <|-- "expression.sysDateFunctionClass"
"expression.functionClass" <|-- "expression.tanFunctionClass"
"expression.functionClass" <|-- "expression.tidbDecodeKeyFunctionClass"
"expression.functionClass" <|-- "expression.tidbDecodePlanFunctionClass"
"expression.functionClass" <|-- "expression.tidbIsDDLOwnerFunctionClass"
"expression.functionClass" <|-- "expression.tidbParseTsoFunctionClass"
"expression.functionClass" <|-- "expression.tidbVersionFunctionClass"
"expression.functionClass" <|-- "expression.timeDiffFunctionClass"
"expression.functionClass" <|-- "expression.timeFormatFunctionClass"
"expression.functionClass" <|-- "expression.timeFunctionClass"
"expression.functionClass" <|-- "expression.timeLiteralFunctionClass"
"expression.functionClass" <|-- "expression.timeToSecFunctionClass"
"expression.functionClass" <|-- "expression.timestampAddFunctionClass"
"expression.functionClass" <|-- "expression.timestampDiffFunctionClass"
"expression.functionClass" <|-- "expression.timestampFunctionClass"
"expression.functionClass" <|-- "expression.timestampLiteralFunctionClass"
"expression.functionClass" <|-- "expression.toBase64FunctionClass"
"expression.functionClass" <|-- "expression.toDaysFunctionClass"
"expression.functionClass" <|-- "expression.toSecondsFunctionClass"
"expression.functionClass" <|-- "expression.trimFunctionClass"
"expression.functionClass" <|-- "expression.truncateFunctionClass"
"expression.functionClass" <|-- "expression.unaryMinusFunctionClass"
"expression.functionClass" <|-- "expression.unaryNotFunctionClass"
"expression.functionClass" <|-- "expression.uncompressFunctionClass"
"expression.functionClass" <|-- "expression.uncompressedLengthFunctionClass"
"expression.functionClass" <|-- "expression.unhexFunctionClass"
"expression.functionClass" <|-- "expression.unixTimestampFunctionClass"
"expression.functionClass" <|-- "expression.upperFunctionClass"
"expression.functionClass" <|-- "expression.userFunctionClass"
"expression.functionClass" <|-- "expression.utcDateFunctionClass"
"expression.functionClass" <|-- "expression.utcTimeFunctionClass"
"expression.functionClass" <|-- "expression.utcTimestampFunctionClass"
"expression.functionClass" <|-- "expression.uuidFunctionClass"
"expression.functionClass" <|-- "expression.uuidShortFunctionClass"
"expression.functionClass" <|-- "expression.validatePasswordStrengthFunctionClass"
"expression.functionClass" <|-- "expression.valuesFunctionClass"
"expression.functionClass" <|-- "expression.versionFunctionClass"
"expression.functionClass" <|-- "expression.weekDayFunctionClass"
"expression.functionClass" <|-- "expression.weekFunctionClass"
"expression.functionClass" <|-- "expression.weekOfYearFunctionClass"
"expression.functionClass" <|-- "expression.weightStringFunctionClass"
"expression.functionClass" <|-- "expression.yearFunctionClass"
"expression.functionClass" <|-- "expression.yearWeekFunctionClass"

namespace filesort {
    class Builder << (S,Aquamarine) >> {
        - sc *stmtctx.StatementContext
        - keySize int
        - valSize int
        - bufSize int
        - nWorkers int
        - byDesc []bool
        - tmpDir string

        + SetSC(sc *stmtctx.StatementContext) *Builder
        + SetSchema(keySize int, valSize int) *Builder
        + SetBuf(bufSize int) *Builder
        + SetWorkers(nWorkers int) *Builder
        + SetDesc(byDesc []bool) *Builder
        + SetDir(tmpDir string) *Builder
        + Build() (*FileSorter, error)

    }
    class FileSorter << (S,Aquamarine) >> {
        - sc *stmtctx.StatementContext
        - byDesc []bool
        - workers []*Worker
        - nWorkers int
        - cWorker int
        - mu sync.Mutex
        - tmpDir string
        - files []string
        - nFiles int
        - cursor int
        - rowHeap *rowHeap
        - fds []*os.File
        - rowBytes []byte
        - head []byte
        - dcod []types.Datum
        - keySize int
        - valSize int
        - maxRowSize int
        - wg sync.WaitGroup
        - closed bool
        - fetched bool
        - external bool

        - getUniqueFileName() string
        - appendFileName(fn string) 
        - closeAllFiles() error
        - internalSort() (*comparableRow, error)
        - externalSort() (*comparableRow, error)
        - openAllFiles() error
        - fetchNextRow(index int) (*comparableRow, error)

        + Input(key []types.Datum, val []types.Datum, handle int64) error
        + Output() ([]types.Datum, []types.Datum, int64, error)
        + Close() error

    }
    class Worker << (S,Aquamarine) >> {
        - ctx *FileSorter
        - busy int32
        - keySize int
        - valSize int
        - rowSize int
        - bufSize int
        - buf []*comparableRow
        - head []byte
        - err error

        - input(row *comparableRow) 
        - flushToFile() 

        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool

    }
    class comparableRow << (S,Aquamarine) >> {
        - key []types.Datum
        - val []types.Datum
        - handle int64

    }
    class item << (S,Aquamarine) >> {
        - index int
        - value *comparableRow

    }
    class rowHeap << (S,Aquamarine) >> {
        - sc *stmtctx.StatementContext
        - ims []*item
        - byDesc []bool
        - err error

        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}

    }
}

"executor.Closeable" <|-- "filesort.FileSorter"

namespace format {
    interface Formatter  {
        + Format(format string, args ...<font color=blue>interface</font>{}) (int, error)

    }
    class flatFormatter << (S,Aquamarine) >> {
        + Format(format string, args ...<font color=blue>interface</font>{}) (int, error)

    }
    class format.flatFormatter << (T, #FF7700) >>  {
    }
    class indentFormatter << (S,Aquamarine) >> {
        - indent []byte
        - indentLevel int
        - state int

        - format(flat bool, format string, args ...<font color=blue>interface</font>{}) (int, error)

        + Format(format string, args ...<font color=blue>interface</font>{}) (int, error)

    }
}
"io.Writer" *-- "format.indentFormatter"

"format.Formatter" <|-- "format.flatFormatter"
"format.Formatter" <|-- "format.indentFormatter"

namespace gcworker {
    class GCWorker << (S,Aquamarine) >> {
        - uuid string
        - desc string
        - store tikv.Storage
        - pdClient client.Client
        - gcIsRunning bool
        - lastFinish time.Time
        - cancel context.CancelFunc
        - done <font color=blue>chan</font> error

        - start(ctx context.Context, wg *sync.WaitGroup) 
        - tick(ctx context.Context) 
        - leaderTick(ctx context.Context) error
        - prepare() (bool, uint64, error)
        - checkPrepare(ctx context.Context) (bool, uint64, error)
        - calSafePointByMinStartTS(ctx context.Context, safePoint time.Time) time.Time
        - getOracleTime() (time.Time, error)
        - checkGCEnable() (bool, error)
        - checkUseAutoConcurrency() (bool, error)
        - loadBooleanWithDefault(key string, defaultValue bool) (bool, error)
        - getGCConcurrency(ctx context.Context) (int, error)
        - checkGCInterval(now time.Time) (bool, error)
        - validateGCLiftTime(lifeTime time.Duration) (time.Duration, error)
        - calculateNewSafePoint(ctx context.Context, now time.Time) (*time.Time, uint64, error)
        - setGCWorkerServiceSafePoint(ctx context.Context, safePoint uint64) (uint64, error)
        - runGCJob(ctx context.Context, safePoint uint64, concurrency int) error
        - deleteRanges(ctx context.Context, safePoint uint64, concurrency int) error
        - redoDeleteRanges(ctx context.Context, safePoint uint64, concurrency int) error
        - doUnsafeDestroyRangeRequest(ctx context.Context, startKey []byte, endKey []byte, concurrency int) error
        - getUpStoresForGC(ctx context.Context) ([]*metapb.Store, error)
        - getUpStoresMapForGC(ctx context.Context) (<font color=blue>map</font>[uint64]*metapb.Store, error)
        - loadGCConcurrencyWithDefault() (int, error)
        - checkUseDistributedGC() (bool, error)
        - checkUsePhysicalScanLock() (bool, error)
        - resolveLocks(ctx context.Context, safePoint uint64, concurrency int, usePhysical bool) (bool, error)
        - legacyResolveLocks(ctx context.Context, safePoint uint64, concurrency int) error
        - resolveLocksForRange(ctx context.Context, safePoint uint64, startKey []byte, endKey []byte) (tikv.RangeTaskStat, error)
        - resolveLocksPhysical(ctx context.Context, safePoint uint64) error
        - registerLockObservers(ctx context.Context, safePoint uint64, stores <font color=blue>map</font>[uint64]*metapb.Store) error
        - checkLockObservers(ctx context.Context, safePoint uint64, stores <font color=blue>map</font>[uint64]*metapb.Store) (<font color=blue>map</font>[uint64]<font color=blue>interface</font>{}, error)
        - removeLockObservers(ctx context.Context, safePoint uint64, stores <font color=blue>map</font>[uint64]*metapb.Store) 
        - physicalScanAndResolveLocks(ctx context.Context, safePoint uint64, stores <font color=blue>map</font>[uint64]*metapb.Store) (<font color=blue>map</font>[uint64]<font color=blue>interface</font>{}, error)
        - resolveLocksAcrossRegions(ctx context.Context, locks []*tikv.Lock) error
        - uploadSafePointToPD(ctx context.Context, safePoint uint64) error
        - doGCForRange(ctx context.Context, startKey []byte, endKey []byte, safePoint uint64) (tikv.RangeTaskStat, error)
        - doGCForRegion(bo *tikv.Backoffer, safePoint uint64, region tikv.RegionVerID) (*errorpb.Error, error)
        - doGC(ctx context.Context, safePoint uint64, concurrency int) error
        - checkLeader() (bool, error)
        - saveSafePoint(kv tikv.SafePointKV, t uint64) error
        - saveTime(key string, t time.Time) error
        - loadTime(key string) (*time.Time, error)
        - saveDuration(key string, d time.Duration) error
        - loadDuration(key string) (*time.Duration, error)
        - loadDurationWithDefault(key string, def time.Duration) (*time.Duration, error)
        - loadValueFromSysTable(key string) (string, error)
        - saveValueToSysTable(key string, value string) error

        + Start() 
        + Close() 

    }
    class MockGCWorker << (S,Aquamarine) >> {
        - worker *GCWorker

        + DeleteRanges(ctx context.Context, safePoint uint64) error

    }
    class gcworker.mergeReceiver << (T, #FF7700) >>  {
    }
    class mergeLockScanner << (S,Aquamarine) >> {
        - safePoint uint64
        - client tikv.Client
        - stores <font color=blue>map</font>[uint64]*metapb.Store
        - receivers mergeReceiver
        - currentLock *tikv.Lock
        - scanLockLimit uint32

        - startWithReceivers(receivers []*receiver) 
        - physicalScanLocksForStore(ctx context.Context, safePoint uint64, store *metapb.Store, lockCh <font color=blue>chan</font> scanLockResult) error

        + Start(ctx context.Context) error
        + Next() *tikv.Lock
        + NextBatch(batchSize int) []*tikv.Lock
        + GetSucceededStores() <font color=blue>map</font>[uint64]<font color=blue>interface</font>{}

    }
    class mergeReceiver << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}

    }
    class receiver << (S,Aquamarine) >> {
        + Ch <font color=blue>chan</font> scanLockResult
        + StoreID uint64
        + NextLock *tikv.Lock
        + Err error

        + PeekNextLock() *tikv.Lock
        + TakeNextLock() *tikv.Lock

    }
    class scanLockResult << (S,Aquamarine) >> {
        + Lock *tikv.Lock
        + Err error

    }
}

"tikv.GCHandler" <|-- "gcworker.GCWorker"

namespace hack {
    class hack.MutableString << (T, #FF7700) >>  {
    }
}


namespace handle {
    class Handle << (S,Aquamarine) >> {
        - mu <font color=blue>struct</font>{sync.Mutex, sessionctx.Context, errorRateDeltaMap, <font color=blue>map</font>[int64]int64, int64}
        - statsCache <font color=blue>struct</font>{sync.Mutex, atomic.Value}
        - restrictedExec sqlexec.RestrictedSQLExecutor
        - ddlEventCh <font color=blue>chan</font> *util.Event
        - listHead *SessionStatsCollector
        - globalMap tableDeltaMap
        - feedback []*statistics.QueryFeedback
        - lease atomic.Duration

        - gcTableStats(is infoschema.InfoSchema, physicalID int64) error
        - deleteHistStatsFromKV(physicalID int64, histID int64, isIndex int) error
        - insertTableStats2KV(info *model.TableInfo, physicalID int64) error
        - insertColStats2KV(physicalID int64, colInfo *model.ColumnInfo) error
        - initStatsMeta4Chunk(is infoschema.InfoSchema, cache *statsCache, iter *chunk.Iterator4Chunk) 
        - initStatsMeta(is infoschema.InfoSchema) (statsCache, error)
        - initStatsHistograms4Chunk(is infoschema.InfoSchema, cache *statsCache, iter *chunk.Iterator4Chunk) 
        - initStatsHistograms(is infoschema.InfoSchema, cache *statsCache) error
        - initStatsTopN4Chunk(cache *statsCache, iter *chunk.Iterator4Chunk) 
        - initStatsTopN(cache *statsCache) error
        - initStatsBuckets(cache *statsCache) error
        - merge(s *SessionStatsCollector, rateMap errorRateDeltaMap) 
        - sweepList() 
        - dumpTableStatCountToKV(id int64, delta variable.TableDelta) (bool, error)
        - dumpTableStatColSizeToKV(id int64, delta variable.TableDelta) error
        - handleSingleHistogramUpdate(is infoschema.InfoSchema, rows []chunk.Row) error
        - deleteOutdatedFeedback(tableID int64, histID int64, isIndex int64) error
        - dumpStatsUpdateToKV(tableID int64, isIndex int64, q *statistics.QueryFeedback, hist *statistics.Histogram, cms *statistics.CMSketch) error
        - getAutoAnalyzeParameters() <font color=blue>map</font>[string]string
        - autoAnalyzeTable(tblInfo *model.TableInfo, statsTbl *statistics.Table, start time.Time, end time.Time, ratio float64, sql string) bool
        - execAutoAnalyze(sql string) 
        - logDetailedInfo(q *statistics.QueryFeedback) 
        - dumpRangeFeedback(sc *stmtctx.StatementContext, ran *ranger.Range, rangeCount float64, q *statistics.QueryFeedback) error
        - getTableByPhysicalID(is infoschema.InfoSchema, physicalID int64) (table.Table, bool)
        - updateStatsCache(newCache statsCache) 
        - cmSketchFromStorage(reader *statsReader, tblID int64, isIndex int64, histID int64) (*statistics.CMSketch, error)
        - indexStatsFromStorage(reader *statsReader, row chunk.Row, table *statistics.Table, tableInfo *model.TableInfo) error
        - columnStatsFromStorage(reader *statsReader, row chunk.Row, table *statistics.Table, tableInfo *model.TableInfo, loadAll bool) error
        - tableStatsFromStorage(tableInfo *model.TableInfo, physicalID int64, loadAll bool, historyStatsExec sqlexec.RestrictedSQLExecutor) (*statistics.Table, error)
        - histogramFromStorage(reader *statsReader, tableID int64, colID int64, tp *types.FieldType, distinct int64, isIndex int, ver uint64, nullCount int64, totColSize int64, corr float64) (*statistics.Histogram, error)
        - columnCountFromStorage(reader *statsReader, tableID int64, colID int64) (int64, error)
        - statsMetaByTableIDFromStorage(tableID int64, historyStatsExec sqlexec.RestrictedSQLExecutor) (uint64, int64, error)
        - getStatsReader(history sqlexec.RestrictedSQLExecutor) (*statsReader, error)
        - releaseStatsReader(reader *statsReader) error
        - tableStatsToJSON(dbName string, tableInfo *model.TableInfo, physicalID int64, historyStatsExec sqlexec.RestrictedSQLExecutor) (*JSONTable, error)
        - loadStatsFromJSON(tableInfo *model.TableInfo, physicalID int64, jsonTbl *JSONTable) error

        + GCStats(is infoschema.InfoSchema, ddlLease time.Duration) error
        + DeleteTableStatsFromKV(physicalID int64) error
        + HandleDDLEvent(t *util.Event) error
        + DDLEventCh() <font color=blue>chan</font> *util.Event
        + InitStats(is infoschema.InfoSchema) error
        + NewSessionStatsCollector() *SessionStatsCollector
        + DumpStatsDeltaToKV(mode dumpMode) error
        + DumpStatsFeedbackToKV() error
        + DumpFeedbackToKV(fb *statistics.QueryFeedback) error
        + UpdateStatsByLocalFeedback(is infoschema.InfoSchema) 
        + UpdateErrorRate(is infoschema.InfoSchema) 
        + HandleUpdateStats(is infoschema.InfoSchema) error
        + HandleAutoAnalyze(is infoschema.InfoSchema) 
        + RecalculateExpectCount(q *statistics.QueryFeedback) error
        + DumpFeedbackForIndex(q *statistics.QueryFeedback, t *statistics.Table) error
        + Clear() 
        + Lease() time.Duration
        + SetLease(lease time.Duration) 
        + GetQueryFeedback() []*statistics.QueryFeedback
        + Update(is infoschema.InfoSchema) error
        + GetTableStats(tblInfo *model.TableInfo) *statistics.Table
        + GetPartitionStats(tblInfo *model.TableInfo, pid int64) *statistics.Table
        + LoadNeededHistograms() error
        + LastUpdateVersion() uint64
        + SetLastUpdateVersion(version uint64) 
        + FlushStats() 
        + SaveStatsToStorage(tableID int64, count int64, isIndex int, hg *statistics.Histogram, cms *statistics.CMSketch, isAnalyzed int64) error
        + SaveMetaToStorage(tableID int64, count int64, modifyCount int64) error
        + DumpStatsToJSON(dbName string, tableInfo *model.TableInfo, historyStatsExec sqlexec.RestrictedSQLExecutor) (*JSONTable, error)
        + LoadStatsFromJSON(is infoschema.InfoSchema, jsonTbl *JSONTable) error

    }
    class JSONTable << (S,Aquamarine) >> {
        + DatabaseName string
        + TableName string
        + Columns <font color=blue>map</font>[string]*jsonColumn
        + Indices <font color=blue>map</font>[string]*jsonColumn
        + Count int64
        + ModifyCount int64
        + Partitions <font color=blue>map</font>[string]*JSONTable

    }
    class SessionStatsCollector << (S,Aquamarine) >> {
        - mapper tableDeltaMap
        - feedback []*statistics.QueryFeedback
        - rateMap errorRateDeltaMap
        - next *SessionStatsCollector
        - deleted bool

        + Delete() 
        + Update(id int64, delta int64, count int64, colSize *<font color=blue>map</font>[int64]int64) 
        + StoreQueryFeedback(feedback <font color=blue>interface</font>{}, h *Handle) error

    }
    class errorRateDelta << (S,Aquamarine) >> {
        + PkID int64
        + PkErrorRate *statistics.ErrorRate
        + IdxErrorRate <font color=blue>map</font>[int64]*statistics.ErrorRate

    }
    class errorRateDeltaMap << (S,Aquamarine) >> {
        - update(tableID int64, histID int64, rate float64, isIndex bool) 
        - merge(deltaMap errorRateDeltaMap) 
        - clear(tableID int64, histID int64, isIndex bool) 

    }
    class handle.dumpMode << (T, #FF7700) >>  {
    }
    class handle.errorRateDeltaMap << (T, #FF7700) >>  {
    }
    class handle.tableDeltaMap << (T, #FF7700) >>  {
    }
    class jsonColumn << (S,Aquamarine) >> {
        + Histogram *tipb.Histogram
        + CMSketch *tipb.CMSketch
        + NullCount int64
        + TotColSize int64
        + LastUpdateVersion uint64
        + Correlation float64

    }
    class statsCache << (S,Aquamarine) >> {
        - tables <font color=blue>map</font>[int64]*statistics.Table
        - version uint64

        - copy() statsCache
        - update(tables []*statistics.Table, deletedIDs []int64, newVersion uint64) statsCache

    }
    class statsReader << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - history sqlexec.RestrictedSQLExecutor

        - read(sql string) ([]chunk.Row, []*ast.ResultField, error)
        - isHistory() bool

    }
    class tableDeltaMap << (S,Aquamarine) >> {
        - update(id int64, delta int64, count int64, colSize *<font color=blue>map</font>[int64]int64) 

    }
    class "<font color=blue>map</font>[int64]variable.TableDelta" as fontcolorbluemapfontint64variableTableDelta {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"sync.Mutex" *-- "handle.SessionStatsCollector"


namespace helper {
    class FrameItem << (S,Aquamarine) >> {
        + DBName string
        + TableName string
        + TableID int64
        + IsRecord bool
        + RecordID int64
        + IndexName string
        + IndexID int64
        + IndexValues []string

    }
    class Helper << (S,Aquamarine) >> {
        + Store tikv.Storage
        + RegionCache *tikv.RegionCache

        - requestPD(method string, uri string, body io.Reader, res <font color=blue>interface</font>{}) error

        + GetMvccByEncodedKey(encodedKey kv.Key) (*kvrpcpb.MvccGetByKeyResponse, error)
        + ScrapeHotInfo(rw string, allSchemas []*model.DBInfo) ([]HotTableIndex, error)
        + FetchHotRegion(rw string) (<font color=blue>map</font>[uint64]RegionMetric, error)
        + FetchRegionTableIndex(metrics <font color=blue>map</font>[uint64]RegionMetric, allSchemas []*model.DBInfo) ([]HotTableIndex, error)
        + FindTableIndexOfRegion(allSchemas []*model.DBInfo, hotRange *RegionFrameRange) *FrameItem
        + GetRegionsTableInfo(regionsInfo *RegionsInfo, schemas []*model.DBInfo) <font color=blue>map</font>[int64][]TableInfo
        + GetRegionsInfo() (*RegionsInfo, error)
        + GetRegionInfoByID(regionID uint64) (*RegionInfo, error)
        + GetStoresStat() (*StoresStat, error)

    }
    class HotRegionsStat << (S,Aquamarine) >> {
        + RegionsStat []RegionStat

    }
    class HotTableIndex << (S,Aquamarine) >> {
        + RegionID uint64
        + RegionMetric *RegionMetric
        + DbName string
        + TableName string
        + TableID int64
        + IndexName string
        + IndexID int64

    }
    class RegionEpoch << (S,Aquamarine) >> {
        + ConfVer int64
        + Version int64

    }
    class RegionFrameRange << (S,Aquamarine) >> {
        - region *tikv.KeyLocation

        + First *FrameItem
        + Last *FrameItem

        + GetRecordFrame(tableID int64, dbName string, tableName string) *FrameItem
        + GetIndexFrame(tableID int64, indexID int64, dbName string, tableName string, indexName string) *FrameItem

    }
    class RegionInfo << (S,Aquamarine) >> {
        + ID int64
        + StartKey string
        + EndKey string
        + Epoch RegionEpoch
        + Peers []RegionPeer
        + Leader RegionPeer
        + DownPeers []RegionPeerStat
        + PendingPeers []RegionPeer
        + WrittenBytes int64
        + ReadBytes int64
        + ApproximateSize int64
        + ApproximateKeys int64

        - getStartKey() string
        - getEndKey() string

    }
    class RegionMetric << (S,Aquamarine) >> {
        + FlowBytes uint64
        + MaxHotDegree int
        + Count int

    }
    class RegionPeer << (S,Aquamarine) >> {
        + ID int64
        + StoreID int64
        + IsLearner bool

    }
    class RegionPeerStat << (S,Aquamarine) >> {
        + DownSec int64

    }
    class RegionStat << (S,Aquamarine) >> {
        + RegionID uint64
        + FlowBytes float64
        + HotDegree int

    }
    class RegionsInfo << (S,Aquamarine) >> {
        + Count int64
        + Regions []RegionInfo

    }
    class StoreBaseStat << (S,Aquamarine) >> {
        + ID int64
        + Address string
        + State int64
        + StateName string
        + Version string
        + Labels []StoreLabel
        + StatusAddress string
        + GitHash string
        + StartTimestamp int64

    }
    class StoreDetailStat << (S,Aquamarine) >> {
        + Capacity string
        + Available string
        + LeaderCount int64
        + LeaderWeight float64
        + LeaderScore float64
        + LeaderSize int64
        + RegionCount int64
        + RegionWeight float64
        + RegionScore float64
        + RegionSize int64
        + StartTs time.Time
        + LastHeartbeatTs time.Time
        + Uptime string

    }
    class StoreHotRegionInfos << (S,Aquamarine) >> {
        + AsPeer <font color=blue>map</font>[uint64]*HotRegionsStat
        + AsLeader <font color=blue>map</font>[uint64]*HotRegionsStat

    }
    class StoreLabel << (S,Aquamarine) >> {
        + Key string
        + Value string

    }
    class StoreStat << (S,Aquamarine) >> {
        + Store StoreBaseStat
        + Status StoreDetailStat

    }
    class StoresStat << (S,Aquamarine) >> {
        + Count int
        + Stores []StoreStat

    }
    class TableInfo << (S,Aquamarine) >> {
        + DB *model.DBInfo
        + Table *model.TableInfo
        + IsIndex bool
        + Index *model.IndexInfo

    }
    class TblIndex << (S,Aquamarine) >> {
        + DbName string
        + TableName string
        + TableID int64
        + IndexName string
        + IndexID int64

    }
    class TypeContext << (S,Aquamarine) >> {
        + ETName string
        + TypeName string
        + TypeNameInColumn string
        + TypeNameGo string
        + Fixed bool

    }
    class byRegionStartKey << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool

    }
    class byTableStartKey << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool

    }
    class helper.byRegionStartKey << (T, #FF7700) >>  {
    }
    class helper.byTableStartKey << (T, #FF7700) >>  {
    }
    class tableInfoWithKeyRange << (S,Aquamarine) >> {
        + StartKey string
        + EndKey string

        - getStartKey() string
        - getEndKey() string

    }
    interface withKeyRange  {
        - getStartKey() string
        - getEndKey() string

    }
}
"helper.RegionPeer" *-- "helper.RegionPeerStat"
"helper.TableInfo" *-- "helper.tableInfoWithKeyRange"

"helper.withKeyRange" <|-- "helper.RegionInfo"
"helper.withKeyRange" <|-- "helper.tableInfoWithKeyRange"

namespace hint {
    class BlockHintProcessor << (S,Aquamarine) >> {
        - selectStmtOffset int

        + QbNameMap <font color=blue>map</font>[string]int
        + QbHints <font color=blue>map</font>[int][]*types.TableOptimizerHint
        + Ctx sessionctx.Context

        - checkQueryBlockHints(hints []*types.TableOptimizerHint, offset int) 
        - getBlockOffset(blockName model.CIStr, nodeType NodeType) int
        - checkTableQBName(tables []types.HintTable, nodeType NodeType) bool

        + MaxSelectStmtOffset() int
        + Enter(in types.Node) (types.Node, bool)
        + Leave(in types.Node) (types.Node, bool)
        + GetHintOffset(qbName model.CIStr, nodeType NodeType, currentOffset int) int
        + GetCurrentStmtHints(hints []*types.TableOptimizerHint, nodeType NodeType, currentOffset int) []*types.TableOptimizerHint

    }
    class HintsSet << (S,Aquamarine) >> {
        - tableHints [][]*types.TableOptimizerHint
        - indexHints [][]*types.IndexHint

        + GetFirstTableHints() []*types.TableOptimizerHint
        + ContainTableHint(hint string) bool
        + Restore() (string, error)

    }
    class hint.NodeType << (T, #FF7700) >>  {
    }
    class hintProcessor << (S,Aquamarine) >> {
        - bindHint2Ast bool
        - tableCounter int
        - indexCounter int

        + Enter(in types.Node) (types.Node, bool)
        + Leave(in types.Node) (types.Node, bool)

    }
}
"hint.HintsSet" *-- "hint.hintProcessor"


namespace implementation {
    class ApplyImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64
        + GetCostLimit(costLimit float64, children ...memo.Implementation) float64

    }
    class HashJoinImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64
        + AttachChildren(children ...memo.Implementation) memo.Implementation

    }
    class IndexReaderImpl << (S,Aquamarine) >> {
        - tblColHists *statistics.HistColl

        + GetCostLimit(costLimit float64, children ...memo.Implementation) float64
        + CalcCost(outCount float64, children ...memo.Implementation) float64

    }
    class IndexScanImpl << (S,Aquamarine) >> {
        - tblColHists *statistics.HistColl

        + CalcCost(outCount float64, children ...memo.Implementation) float64

    }
    class LimitImpl << (S,Aquamarine) >> {
    }
    class MaxOneRowImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64

    }
    class MemTableScanImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64

    }
    class MergeJoinImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64
        + AttachChildren(children ...memo.Implementation) memo.Implementation

    }
    class NominalSortImpl << (S,Aquamarine) >> {
        + AttachChildren(children ...memo.Implementation) memo.Implementation

    }
    class ProjectionImpl << (S,Aquamarine) >> {
    }
    class ShowImpl << (S,Aquamarine) >> {
    }
    class SortImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64
        + AttachChildren(children ...memo.Implementation) memo.Implementation

    }
    class TableDualImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64

    }
    class TableReaderImpl << (S,Aquamarine) >> {
        - tblColHists *statistics.HistColl

        + CalcCost(outCount float64, children ...memo.Implementation) float64
        + GetCostLimit(costLimit float64, children ...memo.Implementation) float64

    }
    class TableScanImpl << (S,Aquamarine) >> {
        - tblColHists *statistics.HistColl
        - tblCols []*expression.Column

        + CalcCost(outCount float64, children ...memo.Implementation) float64

    }
    class TiDBHashAggImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64
        + AttachChildren(children ...memo.Implementation) memo.Implementation

    }
    class TiDBSelectionImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64

    }
    class TiDBTopNImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64

    }
    class TiKVHashAggImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64

    }
    class TiKVSelectionImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64

    }
    class TiKVTopNImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64

    }
    class UnionAllImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64
        + GetCostLimit(costLimit float64, children ...memo.Implementation) float64

    }
    class WindowImpl << (S,Aquamarine) >> {
        + CalcCost(outCount float64, children ...memo.Implementation) float64

    }
    class baseImpl << (S,Aquamarine) >> {
        - cost float64
        - plan core.PhysicalPlan

        + CalcCost(outCount float64, children ...memo.Implementation) float64
        + SetCost(cost float64) 
        + GetCost() float64
        + GetPlan() core.PhysicalPlan
        + AttachChildren(children ...memo.Implementation) memo.Implementation
        + ScaleCostLimit(costLimit float64) float64
        + GetCostLimit(costLimit float64, children ...memo.Implementation) float64

    }
}
"implementation.baseImpl" *-- "implementation.ApplyImpl"
"implementation.baseImpl" *-- "implementation.HashJoinImpl"
"implementation.baseImpl" *-- "implementation.IndexReaderImpl"
"implementation.baseImpl" *-- "implementation.IndexScanImpl"
"implementation.baseImpl" *-- "implementation.LimitImpl"
"implementation.baseImpl" *-- "implementation.MaxOneRowImpl"
"implementation.baseImpl" *-- "implementation.MemTableScanImpl"
"implementation.baseImpl" *-- "implementation.MergeJoinImpl"
"implementation.baseImpl" *-- "implementation.NominalSortImpl"
"implementation.baseImpl" *-- "implementation.ProjectionImpl"
"implementation.baseImpl" *-- "implementation.ShowImpl"
"implementation.baseImpl" *-- "implementation.SortImpl"
"implementation.baseImpl" *-- "implementation.TableDualImpl"
"implementation.baseImpl" *-- "implementation.TableReaderImpl"
"implementation.baseImpl" *-- "implementation.TableScanImpl"
"implementation.baseImpl" *-- "implementation.TiDBHashAggImpl"
"implementation.baseImpl" *-- "implementation.TiDBSelectionImpl"
"implementation.baseImpl" *-- "implementation.TiDBTopNImpl"
"implementation.baseImpl" *-- "implementation.TiKVHashAggImpl"
"implementation.baseImpl" *-- "implementation.TiKVSelectionImpl"
"implementation.baseImpl" *-- "implementation.TiKVTopNImpl"
"implementation.baseImpl" *-- "implementation.UnionAllImpl"
"implementation.baseImpl" *-- "implementation.WindowImpl"

"memo.Implementation" <|-- "implementation.baseImpl"

namespace infoschema {
    class Builder << (S,Aquamarine) >> {
        - is *infoSchema
        - handle *Handle

        - copySortedTables(oldTableID int64, newTableID int64) 
        - applyCreateSchema(m *meta.Meta, diff *model.SchemaDiff) error
        - applyModifySchemaCharsetAndCollate(m *meta.Meta, diff *model.SchemaDiff) error
        - applyDropSchema(schemaID int64) []int64
        - copySortedTablesBucket(bucketIdx int) 
        - applyCreateTable(m *meta.Meta, dbInfo *model.DBInfo, tableID int64, allocs autoid.Allocators, tp model.ActionType, affected []int64) ([]int64, error)
        - applyDropTable(dbInfo *model.DBInfo, tableID int64, affected []int64) []int64
        - copySchemasMap(oldIS *infoSchema) 
        - copySchemaTables(dbName string) *model.DBInfo
        - createSchemaTablesForDB(di *model.DBInfo, tableFromMeta tableFromMetaFunc) error

        + ApplyDiff(m *meta.Meta, diff *model.SchemaDiff) ([]int64, error)
        + InitWithOldInfoSchema() *Builder
        + InitWithDBInfos(dbInfos []*model.DBInfo, schemaVersion int64) (*Builder, error)
        + Build() 

    }
    class Handle << (S,Aquamarine) >> {
        - value atomic.Value
        - store kv.Storage

        + Get() InfoSchema
        + IsValid() bool
        + EmptyClone() *Handle

    }
    interface InfoSchema  {
        + SchemaByName(schema model.CIStr) (*model.DBInfo, bool)
        + SchemaExists(schema model.CIStr) bool
        + TableByName(schema model.CIStr, table model.CIStr) (table.Table, error)
        + TableExists(schema model.CIStr, table model.CIStr) bool
        + SchemaByID(id int64) (*model.DBInfo, bool)
        + SchemaByTable(tableInfo *model.TableInfo) (*model.DBInfo, bool)
        + TableByID(id int64) (table.Table, bool)
        + AllocByID(id int64) (autoid.Allocators, bool)
        + AllSchemaNames() []string
        + AllSchemas() []*model.DBInfo
        + Clone() []*model.DBInfo
        + SchemaTables(schema model.CIStr) []table.Table
        + SchemaMetaVersion() int64
        + TableIsView(schema model.CIStr, table model.CIStr) bool
        + TableIsSequence(schema model.CIStr, table model.CIStr) bool
        + FindTableByPartitionID(partitionID int64) (table.Table, *model.DBInfo)

    }
    class MetricTableDef << (S,Aquamarine) >> {
        + PromQL string
        + Labels []string
        + Quantile float64
        + Comment string

        - genColumnInfos() []columnInfo
        - genLabelCondition(labels <font color=blue>map</font>[string]set.StringSet) string

        + GenPromQL(sctx sessionctx.Context, labels <font color=blue>map</font>[string]set.StringSet, quantile float64) string

    }
    class SchemasSorter << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool

    }
    class ServerInfo << (S,Aquamarine) >> {
        + ServerType string
        + Address string
        + StatusAddr string
        + Version string
        + GitHash string
        + StartTimestamp int64

    }
    class VirtualTable << (S,Aquamarine) >> {
        + IterRecords(ctx sessionctx.Context, startKey kv.Key, cols []*table.Column, fn table.RecordIterFunc) error
        + RowWithCols(ctx sessionctx.Context, h int64, cols []*table.Column) ([]types.Datum, error)
        + Row(ctx sessionctx.Context, h int64) ([]types.Datum, error)
        + Cols() []*table.Column
        + VisibleCols() []*table.Column
        + HiddenCols() []*table.Column
        + WritableCols() []*table.Column
        + DeletableCols() []*table.Column
        + Indices() []table.Index
        + WritableIndices() []table.Index
        + DeletableIndices() []table.Index
        + RecordPrefix() kv.Key
        + IndexPrefix() kv.Key
        + FirstKey() kv.Key
        + RecordKey(h int64) kv.Key
        + AddRecord(ctx sessionctx.Context, r []types.Datum, opts ...table.AddRecordOption) (int64, error)
        + RemoveRecord(ctx sessionctx.Context, h int64, r []types.Datum) error
        + UpdateRecord(ctx sessionctx.Context, h int64, oldData []types.Datum, newData []types.Datum, touched []bool) error
        + Allocators(_ sessionctx.Context) autoid.Allocators
        + RebaseAutoID(ctx sessionctx.Context, newBase int64, isSetStep bool, tp autoid.AllocatorType) error
        + Meta() *model.TableInfo
        + GetPhysicalID() int64
        + Seek(ctx sessionctx.Context, h int64) (int64, bool, error)
        + Type() table.Type

    }
    class columnInfo << (S,Aquamarine) >> {
        - name string
        - tp byte
        - size int
        - decimal int
        - flag uint
        - deflt <font color=blue>interface</font>{}
        - comment string

    }
    class infoSchema << (S,Aquamarine) >> {
        - schemaMap <font color=blue>map</font>[string]*schemaTables
        - sortedTablesBuckets []sortedTables
        - schemaMetaVersion int64

        + SchemaByName(schema model.CIStr) (*model.DBInfo, bool)
        + SchemaMetaVersion() int64
        + SchemaExists(schema model.CIStr) bool
        + TableByName(schema model.CIStr, table model.CIStr) (table.Table, error)
        + TableIsView(schema model.CIStr, table model.CIStr) bool
        + TableIsSequence(schema model.CIStr, table model.CIStr) bool
        + TableExists(schema model.CIStr, table model.CIStr) bool
        + SchemaByID(id int64) (*model.DBInfo, bool)
        + SchemaByTable(tableInfo *model.TableInfo) (*model.DBInfo, bool)
        + TableByID(id int64) (table.Table, bool)
        + AllocByID(id int64) (autoid.Allocators, bool)
        + AllSchemaNames() []string
        + AllSchemas() []*model.DBInfo
        + SchemaTables(schema model.CIStr) []table.Table
        + FindTableByPartitionID(partitionID int64) (table.Table, *model.DBInfo)
        + Clone() []*model.DBInfo
        + SequenceByName(schema model.CIStr, sequence model.CIStr) (util.SequenceTable, error)

    }
    class infoschema.SchemasSorter << (T, #FF7700) >>  {
    }
    class infoschema.sortedTables << (T, #FF7700) >>  {
    }
    class infoschema.tableFromMetaFunc << (T, #FF7700) >>  {
    }
    class infoschemaTable << (S,Aquamarine) >> {
        - meta *model.TableInfo
        - cols []*table.Column
        - tp table.Type

        - getRows(ctx sessionctx.Context, cols []*table.Column) ([][]types.Datum, error)

        + IterRecords(ctx sessionctx.Context, startKey kv.Key, cols []*table.Column, fn table.RecordIterFunc) error
        + RowWithCols(ctx sessionctx.Context, h int64, cols []*table.Column) ([]types.Datum, error)
        + Row(ctx sessionctx.Context, h int64) ([]types.Datum, error)
        + Cols() []*table.Column
        + VisibleCols() []*table.Column
        + HiddenCols() []*table.Column
        + WritableCols() []*table.Column
        + DeletableCols() []*table.Column
        + Indices() []table.Index
        + WritableIndices() []table.Index
        + DeletableIndices() []table.Index
        + RecordPrefix() kv.Key
        + IndexPrefix() kv.Key
        + FirstKey() kv.Key
        + RecordKey(h int64) kv.Key
        + AddRecord(ctx sessionctx.Context, r []types.Datum, opts ...table.AddRecordOption) (int64, error)
        + RemoveRecord(ctx sessionctx.Context, h int64, r []types.Datum) error
        + UpdateRecord(ctx sessionctx.Context, h int64, oldData []types.Datum, newData []types.Datum, touched []bool) error
        + Allocators(_ sessionctx.Context) autoid.Allocators
        + RebaseAutoID(ctx sessionctx.Context, newBase int64, isSetStep bool, tp autoid.AllocatorType) error
        + Meta() *model.TableInfo
        + GetPhysicalID() int64
        + Seek(ctx sessionctx.Context, h int64) (int64, bool, error)
        + Type() table.Type

    }
    class metricSchemaTable << (S,Aquamarine) >> {
    }
    class schemaTables << (S,Aquamarine) >> {
        - dbInfo *model.DBInfo
        - tables <font color=blue>map</font>[string]table.Table

    }
    class sortedTables << (S,Aquamarine) >> {
        - searchTable(id int64) int

        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool

    }
    class virtualTableDriver << (S,Aquamarine) >> {
        + TableFromMeta <font color=blue>func</font>(autoid.Allocators, *model.TableInfo) (table.Table, error)

    }
    class "<font color=blue>func</font>(autoid.Allocators, *model.TableInfo) (table.Table, error)" as fontcolorbluefuncfontautoidAllocatorsmodelTableInfotableTableerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "[]table.Table" as tableTable {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "[]*model.DBInfo" as modelDBInfo {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"infoschema.infoschemaTable" *-- "infoschema.metricSchemaTable"
"model.DBInfo" *-- "infoschema.virtualTableDriver"

"table.PhysicalTable" <|-- "infoschema.VirtualTable"
"table.Table" <|-- "infoschema.VirtualTable"
"infoschema.InfoSchema" <|-- "infoschema.infoSchema"
"util.SequenceSchema" <|-- "infoschema.infoSchema"
"table.PhysicalTable" <|-- "infoschema.infoschemaTable"
"table.Table" <|-- "infoschema.infoschemaTable"

namespace infosync {
    class InfoSyncer << (S,Aquamarine) >> {
        - etcdCli *clientv3.Client
        - info *ServerInfo
        - serverInfoPath string
        - minStartTS uint64
        - minStartTSPath string
        - manager util.SessionManager
        - session *concurrency.Session
        - topologySession *concurrency.Session
        - prometheusAddr string
        - modifyTime time.Time

        - init(ctx context.Context) error
        - getServerInfoByID(ctx context.Context, id string) (*ServerInfo, error)
        - getAllServerInfo(ctx context.Context) (<font color=blue>map</font>[string]*ServerInfo, error)
        - storeServerInfo(ctx context.Context) error
        - getTopologyInfo() topologyInfo
        - storeMinStartTS(ctx context.Context) error
        - newSessionAndStoreServerInfo(ctx context.Context, retryCnt int) error
        - newTopologySessionAndStoreServerInfo(ctx context.Context, retryCnt int) error
        - updateTopologyAliveness(ctx context.Context) error
        - getPrometheusAddr() (string, error)
        - getPrometheusAddrFromEtcd(k string) (string, error)

        + SetSessionManager(manager util.SessionManager) 
        + RemoveServerInfo() 
        + StoreTopologyInfo(ctx context.Context) error
        + GetMinStartTS() uint64
        + RemoveMinStartTS() 
        + ReportMinStartTS(store kv.Storage) 
        + Done() <font color=blue>chan</font> <font color=blue>struct</font>{}
        + TopologyDone() <font color=blue>chan</font> <font color=blue>struct</font>{}
        + Restart(ctx context.Context) error
        + RestartTopology(ctx context.Context) error

    }
    class ServerInfo << (S,Aquamarine) >> {
        + ID string
        + IP string
        + Port uint
        + StatusPort uint
        + Lease string
        + BinlogStatus string
        + StartTimestamp int64

    }
    class ServerVersionInfo << (S,Aquamarine) >> {
        + Version string
        + GitHash string

    }
    class metricStorage << (S,Aquamarine) >> {
        + PDServer <font color=blue>struct</font>{string}

    }
    class prometheus << (S,Aquamarine) >> {
        + IP string
        + BinaryPath string
        + Port int

    }
    class topologyInfo << (S,Aquamarine) >> {
        + StatusPort uint
        + DeployPath string
        + StartTimestamp int64

    }
}
"infosync.ServerVersionInfo" *-- "infosync.ServerInfo"
"infosync.ServerVersionInfo" *-- "infosync.topologyInfo"


namespace json {
    class BinaryJSON << (S,Aquamarine) >> {
        + TypeCode TypeCode
        + Value []byte

        - extractTo(buf []BinaryJSON, pathExpr PathExpression) []BinaryJSON
        - objectSearchKey(key []byte) (BinaryJSON, bool)
        - extractToCallback(pathExpr PathExpression, callbackFn extractCallbackFn, fullpath PathExpression) (bool, error)
        - marshalTo(buf []byte) ([]byte, error)
        - arrayGetElem(idx int) BinaryJSON
        - objectGetKey(i int) []byte
        - objectGetVal(i int) BinaryJSON
        - valEntryGet(valEntryOff int) BinaryJSON
        - marshalFloat64To(buf []byte) ([]byte, error)
        - marshalArrayTo(buf []byte) ([]byte, error)
        - marshalObjTo(buf []byte) ([]byte, error)

        + Type() string
        + Unquote() (string, error)
        + Extract(pathExprList []PathExpression) (BinaryJSON, bool)
        + Modify(pathExprList []PathExpression, values []BinaryJSON, mt ModifyType) (BinaryJSON, error)
        + ArrayInsert(pathExpr PathExpression, value BinaryJSON) (BinaryJSON, error)
        + Remove(pathExprList []PathExpression) (BinaryJSON, error)
        + GetElemDepth() int
        + Search(containType string, search string, escape byte, pathExpres []PathExpression) (BinaryJSON, bool, error)
        + Walk(walkFn BinaryJSONWalkFunc, pathExprList ...PathExpression) error
        + String() string
        + Copy() BinaryJSON
        + MarshalJSON() ([]byte, error)
        + GetInt64() int64
        + GetUint64() uint64
        + GetFloat64() float64
        + GetString() []byte
        + GetKeys() BinaryJSON
        + GetElemCount() int
        + UnmarshalJSON(data []byte) error

    }
    class PathExpression << (S,Aquamarine) >> {
        - legs []pathLeg
        - flags pathExpressionFlag

        - popOneLeg() (pathLeg, PathExpression)
        - popOneLastLeg() (PathExpression, pathLeg)
        - pushBackOneIndexLeg(index int) PathExpression
        - pushBackOneKeyLeg(key string) PathExpression

        + ContainsAnyAsterisk() bool
        + String() string

    }
    class binaryModifier << (S,Aquamarine) >> {
        - bj BinaryJSON
        - modifyPtr *byte
        - modifyValue BinaryJSON

        - set(path PathExpression, newBj BinaryJSON) BinaryJSON
        - replace(path PathExpression, newBj BinaryJSON) BinaryJSON
        - insert(path PathExpression, newBj BinaryJSON) BinaryJSON
        - doInsert(path PathExpression, newBj BinaryJSON) 
        - remove(path PathExpression) BinaryJSON
        - doRemove(path PathExpression) 
        - rebuild() BinaryJSON
        - rebuildTo(buf []byte) ([]byte, TypeCode)

    }
    class field << (S,Aquamarine) >> {
        - key string
        - val <font color=blue>interface</font>{}

    }
    class json.BinaryJSONWalkFunc << (T, #FF7700) >>  {
    }
    class json.ModifyType << (T, #FF7700) >>  {
    }
    class json.TypeCode << (T, #FF7700) >>  {
    }
    class json.extractCallbackFn << (T, #FF7700) >>  {
    }
    class json.pathExpressionFlag << (T, #FF7700) >>  {
    }
    class json.pathLegType << (T, #FF7700) >>  {
    }
    class pathExpressionFlag << (S,Aquamarine) >> {
        - containsAnyAsterisk() bool

    }
    class pathLeg << (S,Aquamarine) >> {
        - typ pathLegType
        - arrayIndex int
        - dotKey string

    }
}


namespace kv {
    interface BatchGetter  {
        + BatchGet(ctx context.Context, keys []Key) (<font color=blue>map</font>[string][]byte, error)

    }
    class BufferBatchGetter << (S,Aquamarine) >> {
        - buffer MemBuffer
        - middle Getter
        - snapshot Snapshot

        + BatchGet(ctx context.Context, keys []Key) (<font color=blue>map</font>[string][]byte, error)

    }
    class BufferStore << (S,Aquamarine) >> {
        - r Retriever

        + Get(ctx context.Context, k Key) ([]byte, error)
        + Iter(k Key, upperBound Key) (Iterator, error)
        + IterReverse(k Key) (Iterator, error)
        + WalkBuffer(f <font color=blue>func</font>(Key, []byte) error) error

    }
    interface Client  {
        + Send(ctx context.Context, req *Request, vars *Variables) Response
        + IsRequestTypeSupported(reqType int64, subType int64) bool

    }
    interface Driver  {
        + Open(path string) (Storage, error)

    }
    interface Getter  {
        + Get(ctx context.Context, k Key) ([]byte, error)

    }
    class InjectedSnapshot << (S,Aquamarine) >> {
        - cfg *InjectionConfig

        + Get(ctx context.Context, k Key) ([]byte, error)
        + BatchGet(ctx context.Context, keys []Key) (<font color=blue>map</font>[string][]byte, error)

    }
    class InjectedStore << (S,Aquamarine) >> {
        - cfg *InjectionConfig

        + Begin() (Transaction, error)
        + BeginWithStartTS(startTS uint64) (Transaction, error)
        + GetSnapshot(ver Version) (Snapshot, error)

    }
    class InjectedTransaction << (S,Aquamarine) >> {
        - cfg *InjectionConfig

        + Get(ctx context.Context, k Key) ([]byte, error)
        + BatchGet(ctx context.Context, keys []Key) (<font color=blue>map</font>[string][]byte, error)
        + Commit(ctx context.Context) error

    }
    class InjectionConfig << (S,Aquamarine) >> {
        - getError error
        - commitError error

        + SetGetError(err error) 
        + SetCommitError(err error) 

    }
    interface Iterator  {
        + Valid() bool
        + Key() Key
        + Value() []byte
        + Next() error
        + Close() 

    }
    class Key << (S,Aquamarine) >> {
        + Next() Key
        + PrefixNext() Key
        + Cmp(another Key) int
        + HasPrefix(prefix Key) bool
        + Clone() Key
        + String() string

    }
    class KeyRange << (S,Aquamarine) >> {
        + StartKey Key
        + EndKey Key

        + IsPoint() bool

    }
    class LockCtx << (S,Aquamarine) >> {
        + Killed *uint32
        + ForUpdateTS uint64
        + LockWaitTime int64
        + WaitStartTime time.Time
        + PessimisticLockWaited *int32
        + LockKeysDuration *time.Duration
        + LockKeysCount *int32
        + ReturnValues bool
        + Values <font color=blue>map</font>[string]ReturnedValue
        + ValuesLock sync.Mutex
        + LockExpired *uint32

    }
    interface MemBuffer  {
        + Size() int
        + Len() int
        + NewStagingBuffer() MemBuffer
        + Flush() (int, error)
        + Discard() 

    }
    interface MockTxn  {
        + GetOption(opt Option) <font color=blue>interface</font>{}

    }
    interface Mutator  {
        + Set(k Key, v []byte) error
        + Delete(k Key) error

    }
    interface Options  {
        + Get(opt Option) (<font color=blue>interface</font>{}, bool)

    }
    class ReplicaReadType << (S,Aquamarine) >> {
        + IsFollowerRead() bool

    }
    class Request << (S,Aquamarine) >> {
        + Tp int64
        + StartTs uint64
        + Data []byte
        + KeyRanges []KeyRange
        + Concurrency int
        + IsolationLevel IsoLevel
        + Priority int
        + MemTracker *memory.Tracker
        + KeepOrder bool
        + Desc bool
        + NotFillCache bool
        + SyncLog bool
        + Streaming bool
        + ReplicaRead ReplicaReadType
        + StoreType StoreType
        + Cacheable bool
        + SchemaVar int64
        + BatchCop bool
        + TaskID uint64

    }
    class RequestTypeSupportedChecker << (S,Aquamarine) >> {
        - supportExpr(exprType tipb.ExprType) bool

        + IsRequestTypeSupported(reqType int64, subType int64) bool

    }
    interface Response  {
        + Next(ctx context.Context) (ResultSubset, error)
        + Close() error

    }
    interface ResultSubset  {
        + GetData() []byte
        + GetStartKey() Key
        + GetExecDetails() *execdetails.ExecDetails
        + MemSize() int64
        + RespTime() time.Duration

    }
    interface Retriever  {
        + Iter(k Key, upperBound Key) (Iterator, error)
        + IterReverse(k Key) (Iterator, error)

    }
    interface RetrieverMutator  {
    }
    class ReturnedValue << (S,Aquamarine) >> {
        + Value []byte
        + AlreadyLocked bool

    }
    interface Snapshot  {
        + BatchGet(ctx context.Context, keys []Key) (<font color=blue>map</font>[string][]byte, error)
        + SetOption(opt Option, val <font color=blue>interface</font>{}) 
        + DelOption(opt Option) 

    }
    interface SplittableStore  {
        + SplitRegions(ctx context.Context, splitKey [][]byte, scatter bool) ([]uint64, error)
        + WaitScatterRegionFinish(ctx context.Context, regionID uint64, backOff int) error
        + CheckRegionInScattering(regionID uint64) (bool, error)

    }
    interface Storage  {
        + Begin() (Transaction, error)
        + BeginWithStartTS(startTS uint64) (Transaction, error)
        + GetSnapshot(ver Version) (Snapshot, error)
        + GetClient() Client
        + Close() error
        + UUID() string
        + CurrentVersion() (Version, error)
        + GetOracle() oracle.Oracle
        + SupportDeleteRange() bool
        + Name() string
        + Describe() string
        + ShowStatus(ctx context.Context, key string) (<font color=blue>interface</font>{}, error)

    }
    class StoreType << (S,Aquamarine) >> {
        + Name() string

    }
    interface Transaction  {
        + Commit( context.Context) error
        + Rollback() error
        + String() string
        + LockKeys(ctx context.Context, lockCtx *LockCtx, keys ...Key) error
        + SetOption(opt Option, val <font color=blue>interface</font>{}) 
        + DelOption(opt Option) 
        + IsReadOnly() bool
        + StartTS() uint64
        + Valid() bool
        + GetMemBuffer() MemBuffer
        + GetSnapshot() Snapshot
        + SetVars(vars *Variables) 
        + GetVars() *Variables
        + BatchGet(ctx context.Context, keys []Key) (<font color=blue>map</font>[string][]byte, error)
        + IsPessimistic() bool

    }
    class UnionIter << (S,Aquamarine) >> {
        - dirtyIt Iterator
        - snapshotIt Iterator
        - dirtyValid bool
        - snapshotValid bool
        - curIsDirty bool
        - isValid bool
        - reverse bool

        - dirtyNext() error
        - snapshotNext() error
        - updateCur() error

        + Next() error
        + Value() []byte
        + Key() Key
        + Valid() bool
        + Close() 

    }
    interface UnionStore  {
        + GetKeyExistErrInfo(k Key) *existErrInfo
        + DeleteKeyExistErrInfo(k Key) 
        + WalkBuffer(f <font color=blue>func</font>(Key, []byte) error) error
        + SetOption(opt Option, val <font color=blue>interface</font>{}) 
        + DelOption(opt Option) 
        + GetOption(opt Option) <font color=blue>interface</font>{}
        + GetMemBuffer() MemBuffer

    }
    class Variables << (S,Aquamarine) >> {
        + BackoffLockFast int
        + BackOffWeight int
        + Hook <font color=blue>func</font>(string, *Variables) 
        + Killed *uint32

    }
    class Version << (S,Aquamarine) >> {
        + Ver uint64

        + Cmp(another Version) int

    }
    interface VersionProvider  {
        + CurrentVersion() (Version, error)

    }
    class existErrInfo << (S,Aquamarine) >> {
        - idxName string
        - value string

        + GetIdxName() string
        + GetValue() string
        + Err() error

    }
    class kv.AssertionType << (T, #FF7700) >>  {
    }
    class kv.FnKeyCmp << (T, #FF7700) >>  {
    }
    class kv.IsoLevel << (T, #FF7700) >>  {
    }
    class kv.Key << (T, #FF7700) >>  {
    }
    class kv.Option << (T, #FF7700) >>  {
    }
    class kv.ReplicaReadType << (T, #FF7700) >>  {
    }
    class kv.StoreType << (T, #FF7700) >>  {
    }
    class kv.options << (T, #FF7700) >>  {
    }
    class memDbBuffer << (S,Aquamarine) >> {
        - sandbox *memdb.Sandbox
        - entrySizeLimit int
        - bufferLenLimit uint64
        - bufferSizeLimit uint64

        + Iter(k Key, upperBound Key) (Iterator, error)
        + IterReverse(k Key) (Iterator, error)
        + Get(ctx context.Context, k Key) ([]byte, error)
        + Set(k Key, v []byte) error
        + Delete(k Key) error
        + Size() int
        + Len() int
        + NewStagingBuffer() MemBuffer
        + Flush() (int, error)
        + Discard() 

    }
    class memDbIter << (S,Aquamarine) >> {
        - iter memdb.Iterator
        - start []byte
        - end []byte
        - reverse bool

        + Next() error
        + Valid() bool
        + Key() Key
        + Value() []byte
        + Close() 

    }
    class mockSnapshot << (S,Aquamarine) >> {
        - store MemBuffer

        + Get(ctx context.Context, k Key) ([]byte, error)
        + SetPriority(priority int) 
        + BatchGet(ctx context.Context, keys []Key) (<font color=blue>map</font>[string][]byte, error)
        + Iter(k Key, upperBound Key) (Iterator, error)
        + IterReverse(k Key) (Iterator, error)
        + SetOption(opt Option, val <font color=blue>interface</font>{}) 
        + DelOption(opt Option) 

    }
    class mockStorage << (S,Aquamarine) >> {
        + Begin() (Transaction, error)
        + BeginWithStartTS(startTS uint64) (Transaction, error)
        + GetSnapshot(ver Version) (Snapshot, error)
        + Close() error
        + UUID() string
        + CurrentVersion() (Version, error)
        + GetClient() Client
        + GetOracle() oracle.Oracle
        + SupportDeleteRange() bool
        + Name() string
        + Describe() string
        + ShowStatus(ctx context.Context, key string) (<font color=blue>interface</font>{}, error)

    }
    class mockTxn << (S,Aquamarine) >> {
        - opts <font color=blue>map</font>[Option]<font color=blue>interface</font>{}
        - valid bool

        + Commit(ctx context.Context) error
        + Rollback() error
        + String() string
        + LockKeys(_ context.Context, _ *LockCtx, _ ...Key) error
        + SetOption(opt Option, val <font color=blue>interface</font>{}) 
        + DelOption(opt Option) 
        + GetOption(opt Option) <font color=blue>interface</font>{}
        + IsReadOnly() bool
        + StartTS() uint64
        + Get(ctx context.Context, k Key) ([]byte, error)
        + BatchGet(ctx context.Context, keys []Key) (<font color=blue>map</font>[string][]byte, error)
        + Iter(k Key, upperBound Key) (Iterator, error)
        + IterReverse(k Key) (Iterator, error)
        + Set(k Key, v []byte) error
        + Delete(k Key) error
        + Valid() bool
        + Len() int
        + Size() int
        + GetMemBuffer() MemBuffer
        + GetSnapshot() Snapshot
        + NewStagingBuffer() MemBuffer
        + Flush() (int, error)
        + Discard() 
        + Reset() 
        + SetVars(vars *Variables) 
        + GetVars() *Variables
        + IsPessimistic() bool

    }
    class options << (S,Aquamarine) >> {
        + Get(opt Option) (<font color=blue>interface</font>{}, bool)

    }
    class unionStore << (S,Aquamarine) >> {
        - keyExistErrs <font color=blue>map</font>[string]*existErrInfo
        - opts options

        + Get(ctx context.Context, k Key) ([]byte, error)
        + GetKeyExistErrInfo(k Key) *existErrInfo
        + DeleteKeyExistErrInfo(k Key) 
        + SetOption(opt Option, val <font color=blue>interface</font>{}) 
        + DelOption(opt Option) 
        + GetOption(opt Option) <font color=blue>interface</font>{}
        + GetMemBuffer() MemBuffer
        + NewStagingBuffer() MemBuffer
        + Flush() (int, error)
        + Discard() 

    }
}
"kv.MemBuffer" *-- "kv.BufferStore"
"kv.Snapshot" *-- "kv.InjectedSnapshot"
"kv.Storage" *-- "kv.InjectedStore"
"kv.Transaction" *-- "kv.InjectedTransaction"
"sync.RWMutex" *-- "kv.InjectionConfig"
"kv.RetrieverMutator" *-- "kv.MemBuffer"
"kv.Transaction" *-- "kv.MockTxn"
"kv.Getter" *-- "kv.Retriever"
"kv.Mutator" *-- "kv.RetrieverMutator"
"kv.Retriever" *-- "kv.RetrieverMutator"
"kv.Retriever" *-- "kv.Snapshot"
"kv.MemBuffer" *-- "kv.Transaction"
"kv.MemBuffer" *-- "kv.UnionStore"
"kv.BufferStore" *-- "kv.unionStore"

"kv.BatchGetter" <|-- "kv.BufferBatchGetter"
"kv.Getter" <|-- "kv.BufferStore"
"kv.Retriever" <|-- "kv.BufferStore"
"kv.BatchGetter" <|-- "kv.InjectedSnapshot"
"kv.Getter" <|-- "kv.InjectedSnapshot"
"kv.BatchGetter" <|-- "kv.InjectedTransaction"
"kv.Getter" <|-- "kv.InjectedTransaction"
"kv.Iterator" <|-- "kv.UnionIter"
"kv.Getter" <|-- "kv.memDbBuffer"
"kv.MemBuffer" <|-- "kv.memDbBuffer"
"kv.Mutator" <|-- "kv.memDbBuffer"
"kv.Retriever" <|-- "kv.memDbBuffer"
"kv.Iterator" <|-- "kv.memDbIter"
"kv.BatchGetter" <|-- "kv.mockSnapshot"
"kv.Getter" <|-- "kv.mockSnapshot"
"kv.Retriever" <|-- "kv.mockSnapshot"
"kv.Snapshot" <|-- "kv.mockSnapshot"
"executor.Closeable" <|-- "kv.mockStorage"
"kv.Storage" <|-- "kv.mockStorage"
"kv.VersionProvider" <|-- "kv.mockStorage"
"kv.BatchGetter" <|-- "kv.mockTxn"
"kv.Getter" <|-- "kv.mockTxn"
"kv.MemBuffer" <|-- "kv.mockTxn"
"kv.MockTxn" <|-- "kv.mockTxn"
"kv.Mutator" <|-- "kv.mockTxn"
"kv.Retriever" <|-- "kv.mockTxn"
"kv.Snapshot" <|-- "kv.mockTxn"
"kv.Transaction" <|-- "kv.mockTxn"
"kv.Options" <|-- "kv.options"
"kv.Getter" <|-- "kv.unionStore"
"kv.MockTxn" <|-- "kv.unionStore"

namespace kvcache {
    interface Key  {
        + Hash() []byte

    }
    class SimpleLRUCache << (S,Aquamarine) >> {
        - capacity uint
        - size uint
        - quota uint64
        - guard float64
        - elements <font color=blue>map</font>[string]*list.Element
        - cache *list.List

        + Get(key Key) (Value, bool)
        + Put(key Key, value Value) 
        + Delete(key Key) 
        + DeleteAll() 
        + Size() int
        + Values() []Value
        + Keys() []Key
        + SetCapacity(capacity uint) error

    }
    interface Value  {
    }
    class cacheEntry << (S,Aquamarine) >> {
        - key Key
        - value Value

    }
}


namespace latch {
    class Latches << (S,Aquamarine) >> {
        - slots []latch

        - genLock(startTS uint64, keys [][]byte) *Lock
        - genSlotIDs(keys [][]byte) []int
        - slotID(key []byte) int
        - acquire(lock *Lock) acquireResult
        - release(lock *Lock, wakeupList []*Lock) []*Lock
        - releaseSlot(lock *Lock) *Lock
        - acquireSlot(lock *Lock) acquireResult
        - recycle(currentTS uint64) 

    }
    class LatchesScheduler << (S,Aquamarine) >> {
        - latches *Latches
        - unlockCh <font color=blue>chan</font> *Lock
        - closed bool
        - lastRecycleTime uint64

        - run() 
        - wakeup(wakeupList []*Lock) 

        + Close() 
        + Lock(startTS uint64, keys [][]byte) *Lock
        + UnLock(lock *Lock) 

    }
    class Lock << (S,Aquamarine) >> {
        - keys [][]byte
        - requiredSlots []int
        - acquiredCount int
        - startTS uint64
        - commitTS uint64
        - wg sync.WaitGroup
        - isStale bool

        - isLocked() bool

        + IsStale() bool
        + SetCommitTS(commitTS uint64) 

    }
    class bytesSlice << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool

    }
    class latch << (S,Aquamarine) >> {
        - queue *node
        - count int
        - waiting []*Lock

        - recycle(currentTS uint64) int

    }
    class latch.acquireResult << (T, #FF7700) >>  {
    }
    class latch.bytesSlice << (T, #FF7700) >>  {
    }
    class node << (S,Aquamarine) >> {
        - slotID int
        - key []byte
        - maxCommitTS uint64
        - value *Lock
        - next *node

    }
}
"sync.RWMutex" *-- "latch.LatchesScheduler"
"sync.Mutex" *-- "latch.latch"


namespace localpool {
    class LocalPool << (S,Aquamarine) >> {
        - sizePerProc int
        - slots []*slot
        - newFn <font color=blue>func</font>() <font color=blue>interface</font>{}
        - resetFn <font color=blue>func</font>(<font color=blue>interface</font>{}) 

        + Get() <font color=blue>interface</font>{}
        + Put(obj <font color=blue>interface</font>{}) bool
        + Get() <font color=blue>interface</font>{}
        + Put(obj <font color=blue>interface</font>{}) bool

    }
    class slot << (S,Aquamarine) >> {
        - objs []<font color=blue>interface</font>{}
        - getHit int
        - getMiss int
        - putHit int
        - putMiss int

    }
}


namespace lock {
    class Checker << (S,Aquamarine) >> {
        - ctx sessionctx.Context
        - is infoschema.InfoSchema

        + CheckTableLock(db string, table string, privilege errno.PrivilegeType) error
        + CheckLockInDB(db string, privilege errno.PrivilegeType) error

    }
}


namespace logutil {
    class FileLogConfig << (S,Aquamarine) >> {
    }
    class LogConfig << (S,Aquamarine) >> {
        + SlowQueryFile string

    }
    class contextHook << (S,Aquamarine) >> {
        + Fire(entry *logrus.Entry) error
        + Levels() []logrus.Level

    }
    class ctxLogKeyType << (S,Aquamarine) >> {
    }
    class hexStringer << (S,Aquamarine) >> {
        + String() string

    }
    class slowLogFormatter << (S,Aquamarine) >> {
        + Format(entry *logrus.Entry) ([]byte, error)

    }
    class textFormatter << (S,Aquamarine) >> {
        + DisableTimestamp bool
        + EnableEntryOrder bool

        + Format(entry *logrus.Entry) ([]byte, error)

    }
}
"log.FileLogConfig" *-- "logutil.FileLogConfig"
"log.Config" *-- "logutil.LogConfig"
"proto.Message" *-- "logutil.hexStringer"


namespace main {
    class CompareContext << (S,Aquamarine) >> {
        + CompareName string
        + Operator string

    }
    class Config << (S,Aquamarine) >> {
        - configFile string

        + DBCfg DBConfig
        + DDLCfg DDLConfig
        + StatsCfg StatsConfig
        + SysCfg SysConfig

        - configFromFile(path string) error

        + Parse(arguments []string) error
        + String() string

    }
    class DBConfig << (S,Aquamarine) >> {
        + Host string
        + User string
        + Password string
        + Name string
        + Port int

        + String() string

    }
    class DDLConfig << (S,Aquamarine) >> {
        + TableSQL string
        + IndexSQL string

    }
    class StatsConfig << (S,Aquamarine) >> {
        + Path string

    }
    class SysConfig << (S,Aquamarine) >> {
        + LogLevel string
        + WorkerCount int
        + JobCount int
        + Batch int

    }
    class benchDB << (S,Aquamarine) >> {
        - store tikv.Storage
        - session session.Session

        - mustExec(sql string) 
        - mustParseWork(work string) (string, string)
        - mustParseInt(s string) int
        - mustParseRange(s string) int
        - mustParseSpec(s string) int
        - createTable() 
        - truncateTable() 
        - runCountTimes(name string, count int, f <font color=blue>func</font>() ) 
        - insertRows(spec string) 
        - updateRandomRows(spec string) 
        - updateRangeRows(spec string) 
        - selectRows(spec string) 
        - query(spec string) 

    }
    class column << (S,Aquamarine) >> {
        - idx int
        - name string
        - data *datum
        - tp *types.FieldType
        - comment string
        - min string
        - max string
        - incremental bool
        - set []string
        - table *table
        - hist *histogram

        - parseRule(kvs []string, uniq bool) 
        - parseColumnComment(uniq bool) 
        - parseColumn(cd *ast.ColumnDef) 
        - parseColumnOptions(ops []*ast.ColumnOption) 

        + String() string

    }
    class comparableRow << (S,Aquamarine) >> {
        - key []types.Datum
        - val []types.Datum
        - handle int64

    }
    class datum << (S,Aquamarine) >> {
        - intValue int64
        - minIntValue int64
        - maxIntValue int64
        - timeValue time.Time
        - remains uint64
        - repeats uint64
        - step int64
        - probability uint32
        - init bool
        - useRange bool

        - setInitInt64Value(min int64, max int64) 
        - updateRemains() 
        - nextInt64() int64
        - nextString(n int) string
        - nextTime() string
        - nextDate() string
        - nextTimestamp() string
        - nextYear() string

    }
    class function << (S,Aquamarine) >> {
        + FuncName string
        + Sigs []sig
        + Tmpl *template.Template
        + FuncName string
        + Sigs []sig
        + FuncName string
        + Sigs []sig

    }
    class histogram << (S,Aquamarine) >> {
        - index *model.IndexInfo
        - avgLen int

        - getRandomBoundIdx() int
        - randInt() int64
        - getAvgLen(maxLen int) int
        - randString() string
        - randDate(unit string, mysqlFmt string, dateFmt string) string

    }
    class query << (S,Aquamarine) >> {
        + Query string
        + Line int

    }
    class sig << (S,Aquamarine) >> {
        + Arg0 TypeContext
        + SigName string
        + Input TypeContext
        + SigName string
        + TypeA TypeContext
        + FieldTypeA string
        + TestTypeA string
        + AllNull bool

    }
    class table << (S,Aquamarine) >> {
        - name string
        - columns []*column
        - columnList string
        - indices <font color=blue>map</font>[string]*column
        - uniqIndices <font color=blue>map</font>[string]*column
        - tblInfo *model.TableInfo

        - printColumns() string
        - findCol(cols []*column, name string) *column
        - parseTableConstraint(cons *ast.Constraint) 
        - buildColumnList() 

        + String() string

    }
    class tester << (S,Aquamarine) >> {
        - name string
        - tx *sql.Tx
        - buf bytes.Buffer
        - enableQueryLog bool
        - singleQuery bool
        - expectedErrs []string
        - resultFD *os.File
        - ctx sessionctx.Context

        - loadQueries() ([]query, error)
        - parserErrorHandle(query query, err error) error
        - executeDefault(qText string) error
        - execute(query query) error
        - create(tableName string, qText string) error
        - commit() error
        - rollback() error
        - analyze(tableName string) error
        - executeStmt(query string) error
        - openResult() error
        - flushResult() error
        - statsFileName(tableName string) string
        - testFileName() string
        - resultFileName() string

        + Run() error

    }
    class typeContext << (S,Aquamarine) >> {
        + ETName string
        + TypeName string
        + TypeNameInColumn string
        + Fixed bool

    }
}
"flag.FlagSet" *-- "main.Config"
"sync.Mutex" *-- "main.datum"
"statistics.Histogram" *-- "main.histogram"


namespace memdb {
    class Iterator << (S,Aquamarine) >> {
        - sb *Sandbox
        - curr *node
        - key []byte
        - val []byte

        - updateState(node *node, nodeData []byte) 
        - changeToAddr(addr arenaAddr) 

        + Valid() bool
        + Key() []byte
        + Value() []byte
        + Next() 
        + Prev() 
        + Seek(seekKey []byte) 
        + SeekForPrev(target []byte) 
        + SeekForExclusivePrev(target []byte) 
        + SeekToFirst() 
        + SeekToLast() 

    }
    class Sandbox << (S,Aquamarine) >> {
        - frozen bool
        - done bool
        - head headNode
        - parent *Sandbox
        - arena *arena
        - height int
        - length int
        - size int
        - arenaSnap arenaSnapshot

        - prepareOverwrite(next []nodeWithAddr) int
        - getHead() nodeWithAddr
        - randomHeight() int
        - findSpliceForLevel(key []byte, before nodeWithAddr, level int) (nodeWithAddr, nodeWithAddr, bool)
        - findGreaterEqual(key []byte) (*node, []byte, bool)
        - findLess(key []byte, allowEqual bool) (*node, []byte, bool)
        - findLast() (*node, []byte)
        - merge(new *Sandbox) int

        + Get(key []byte) []byte
        + Put(key []byte, value []byte) 
        + Derive() *Sandbox
        + Flush() int
        + GetParent() *Sandbox
        + Discard() 
        + Len() int
        + Size() int
        + NewIterator() Iterator

    }
    class arena << (S,Aquamarine) >> {
        - blockSize int
        - blocks []arenaBlock

        - snapshot() arenaSnapshot
        - revert(snap arenaSnapshot) 
        - newNode(key []byte, v []byte, height int) (*node, arenaAddr)
        - getFrom(addr arenaAddr) []byte
        - alloc(size int) (arenaAddr, []byte)
        - enlarge(allocSize int, blockSize int) 
        - allocInLastBlock(size int) (arenaAddr, []byte)

    }
    class arenaAddr << (S,Aquamarine) >> {
        - blockIdx uint32
        - blockOffset uint32

        - isNull() bool

    }
    class arenaBlock << (S,Aquamarine) >> {
        - buf []byte
        - length int

        - getFrom(offset uint32) []byte
        - alloc(size int) (uint32, []byte)

    }
    class arenaSnapshot << (S,Aquamarine) >> {
        - blockSize int
        - blocks int
        - offsetInBlock int

    }
    class headNode << (S,Aquamarine) >> {
        - prev arenaAddr
        - nexts []arenaAddr

    }
    class mergeState << (S,Aquamarine) >> {
        - height int
        - hitHeight int
        - prev []nodeWithAddr
        - next []nodeWithAddr

        - calculateRecomputeHeight(key []byte, sb *Sandbox) int

    }
    class node << (S,Aquamarine) >> {
        - prev arenaAddr
        - nextsBase arenaAddr

        - nodeLen() int
        - getKey(buf []byte) []byte
        - getValue(buf []byte) []byte
        - nexts(level int) arenaAddr
        - setNexts(level int, val arenaAddr) 
        - nextsAddr(idx int) *arenaAddr
        - getNext(arena *arena, level int) (*node, []byte)

    }
    class nodeHeader << (S,Aquamarine) >> {
        - height uint16
        - keyLen uint16
        - valLen uint32

    }
    class nodeWithAddr << (S,Aquamarine) >> {
        - addr arenaAddr

    }
}
"memdb.nodeHeader" *-- "memdb.headNode"
"memdb.nodeHeader" *-- "memdb.node"
"memdb.node" *-- "memdb.nodeWithAddr"


namespace memo {
    class EngineType << (S,Aquamarine) >> {
        + String() string

    }
    class EngineTypeSet << (S,Aquamarine) >> {
        + Contains(tp EngineType) bool

    }
    class ExploreMark << (S,Aquamarine) >> {
        + SetExplored(round int) 
        + SetUnexplored(round int) 
        + Explored(round int) bool

    }
    class ExprIter << (S,Aquamarine) >> {
        - matched bool

        + Children []*ExprIter

        + Next() bool
        + Matched() bool
        + Reset() bool
        + GetExpr() *GroupExpr

    }
    class Group << (S,Aquamarine) >> {
        - hasBuiltKeyInfo bool

        + Equivalents *list.List
        + FirstExpr <font color=blue>map</font>[Operand]*list.Element
        + Fingerprints <font color=blue>map</font>[string]*list.Element
        + ImplMap <font color=blue>map</font>[string]Implementation
        + Prop *property.LogicalProperty
        + EngineType EngineType
        + SelfFingerprint string

        + SetEngineType(e EngineType) *Group
        + FingerPrint() string
        + Insert(e *GroupExpr) bool
        + Delete(e *GroupExpr) 
        + DeleteAll() 
        + Exists(e *GroupExpr) bool
        + GetFirstElem(operand Operand) *list.Element
        + GetImpl(prop *property.PhysicalProperty) Implementation
        + InsertImpl(prop *property.PhysicalProperty, impl Implementation) 
        + BuildKeyInfo() 

    }
    class GroupExpr << (S,Aquamarine) >> {
        - selfFingerprint string
        - appliedRuleSet <font color=blue>map</font>[uint64]<font color=blue>struct</font>{}

        + ExprNode core.LogicalPlan
        + Children []*Group
        + Group *Group

        + FingerPrint() string
        + SetChildren(children ...*Group) 
        + Schema() *expression.Schema
        + AddAppliedRule(rule <font color=blue>interface</font>{}) 
        + HasAppliedRule(rule <font color=blue>interface</font>{}) bool

    }
    interface Implementation  {
        + CalcCost(outCount float64, children ...Implementation) float64
        + SetCost(cost float64) 
        + GetCost() float64
        + GetPlan() core.PhysicalPlan
        + AttachChildren(children ...Implementation) Implementation
        + GetCostLimit(costLimit float64, children ...Implementation) float64

    }
    class Operand << (S,Aquamarine) >> {
        + Match(t Operand) bool

    }
    class Pattern << (S,Aquamarine) >> {
        + Children []*Pattern

        + Match(o Operand, e EngineType) bool
        + MatchOperandAny(e EngineType) bool
        + SetChildren(children ...*Pattern) 

    }
    class memo.EngineType << (T, #FF7700) >>  {
    }
    class memo.EngineTypeSet << (T, #FF7700) >>  {
    }
    class memo.ExploreMark << (T, #FF7700) >>  {
    }
    class memo.Operand << (T, #FF7700) >>  {
    }
}
"list.Element" *-- "memo.ExprIter"
"memo.Group" *-- "memo.ExprIter"
"memo.Pattern" *-- "memo.ExprIter"
"memo.ExploreMark" *-- "memo.Group"
"memo.ExploreMark" *-- "memo.GroupExpr"
"memo.EngineTypeSet" *-- "memo.Pattern"
"memo.Operand" *-- "memo.Pattern"


namespace memory {
    interface ActionOnExceed  {
        + Action(t *Tracker) 
        + SetLogHook(hook <font color=blue>func</font>(uint64) ) 
        + SetFallback(a ActionOnExceed) 

    }
    class LogOnExceed << (S,Aquamarine) >> {
        - mutex sync.Mutex
        - acted bool
        - logHook <font color=blue>func</font>(uint64) 

        + ConnID uint64

        + SetLogHook(hook <font color=blue>func</font>(uint64) ) 
        + Action(t *Tracker) 
        + SetFallback( ActionOnExceed) 

    }
    class PanicOnExceed << (S,Aquamarine) >> {
        - mutex sync.Mutex
        - acted bool
        - logHook <font color=blue>func</font>(uint64) 

        + ConnID uint64

        + SetLogHook(hook <font color=blue>func</font>(uint64) ) 
        + Action(t *Tracker) 
        + SetFallback( ActionOnExceed) 

    }
    class Tracker << (S,Aquamarine) >> {
        - mu <font color=blue>struct</font>{sync.Mutex, []*Tracker}
        - actionMu <font color=blue>struct</font>{sync.Mutex, ActionOnExceed}
        - label fmt.Stringer
        - bytesConsumed int64
        - bytesLimit int64
        - maxConsumed int64
        - parent *Tracker
        - isGlobal bool

        - remove(oldChild *Tracker) 
        - toString(indent string, buffer *bytes.Buffer) 

        + CheckBytesLimit(val int64) bool
        + SetBytesLimit(bytesLimit int64) 
        + GetBytesLimit() int64
        + CheckExceed() bool
        + SetActionOnExceed(a ActionOnExceed) 
        + FallbackOldAndSetNewAction(a ActionOnExceed) 
        + SetLabel(label fmt.Stringer) 
        + Label() fmt.Stringer
        + AttachTo(parent *Tracker) 
        + Detach() 
        + ReplaceChild(oldChild *Tracker, newChild *Tracker) 
        + Consume(bytes int64) 
        + BytesConsumed() int64
        + MaxConsumed() int64
        + SearchTracker(label string) *Tracker
        + String() string
        + BytesToString(numBytes int64) string
        + AttachToGlobalTracker(globalTracker *Tracker) 
        + DetachFromGlobalTracker() 

    }
}

"memory.ActionOnExceed" <|-- "memory.LogOnExceed"
"memory.ActionOnExceed" <|-- "memory.PanicOnExceed"

namespace meta {
    class LastJobIterator << (S,Aquamarine) >> {
        - iter *structure.ReverseHashIterator

        + GetLastJobs(num int, jobs []*model.Job) ([]*model.Job, error)

    }
    class Meta << (S,Aquamarine) >> {
        - txn *structure.TxStructure
        - jobListKey JobListKeyType

        + StartTS uint64

        - dbKey(dbID int64) []byte
        - autoTableIDKey(tableID int64) []byte
        - autoRandomTableIDKey(tableID int64) []byte
        - tableKey(tableID int64) []byte
        - sequenceKey(sequenceID int64) []byte
        - sequenceCycleKey(sequenceID int64) []byte
        - checkDBExists(dbKey []byte) error
        - checkDBNotExists(dbKey []byte) error
        - checkTableExists(dbKey []byte, tableKey []byte) error
        - checkTableNotExists(dbKey []byte, tableKey []byte) error
        - enQueueDDLJob(key []byte, job *model.Job) error
        - deQueueDDLJob(key []byte) (*model.Job, error)
        - getDDLJob(key []byte, index int64) (*model.Job, error)
        - updateDDLJob(index int64, job *model.Job, key []byte, updateRawArgs bool) error
        - jobIDKey(id int64) []byte
        - reorgJobStartHandle(id int64) []byte
        - reorgJobEndHandle(id int64) []byte
        - reorgJobPhysicalTableID(id int64) []byte
        - addHistoryDDLJob(key []byte, job *model.Job, updateRawArgs bool) error
        - getHistoryDDLJob(key []byte, id int64) (*model.Job, error)
        - schemaDiffKey(schemaVersion int64) []byte

        + GenGlobalID() (int64, error)
        + GenGlobalIDs(n int) ([]int64, error)
        + GetGlobalID() (int64, error)
        + GenAutoTableIDKeyValue(dbID int64, tableID int64, autoID int64) []byte
        + GenAutoTableID(dbID int64, tableID int64, step int64) (int64, error)
        + GenAutoRandomID(dbID int64, tableID int64, step int64) (int64, error)
        + GetAutoTableID(dbID int64, tableID int64) (int64, error)
        + GetAutoRandomID(dbID int64, tableID int64) (int64, error)
        + GenSequenceValue(dbID int64, sequenceID int64, step int64) (int64, error)
        + GetSequenceValue(dbID int64, sequenceID int64) (int64, error)
        + SetSequenceValue(dbID int64, sequenceID int64, start int64) error
        + GetSequenceCycle(dbID int64, sequenceID int64) (int64, error)
        + SetSequenceCycle(dbID int64, sequenceID int64, round int64) error
        + GetSchemaVersion() (int64, error)
        + GenSchemaVersion() (int64, error)
        + CreateDatabase(dbInfo *model.DBInfo) error
        + UpdateDatabase(dbInfo *model.DBInfo) error
        + CreateTableOrView(dbID int64, tableInfo *model.TableInfo) error
        + CreateTableAndSetAutoID(dbID int64, tableInfo *model.TableInfo, autoIncID int64, autoRandID int64) error
        + CreateSequenceAndSetSeqValue(dbID int64, tableInfo *model.TableInfo, seqValue int64) error
        + DropDatabase(dbID int64) error
        + DropSequence(dbID int64, tblID int64, delAutoID bool) error
        + DropTableOrView(dbID int64, tblID int64, delAutoID bool) error
        + UpdateTable(dbID int64, tableInfo *model.TableInfo) error
        + ListTables(dbID int64) ([]*model.TableInfo, error)
        + ListDatabases() ([]*model.DBInfo, error)
        + GetDatabase(dbID int64) (*model.DBInfo, error)
        + GetTable(dbID int64, tableID int64) (*model.TableInfo, error)
        + EnQueueDDLJob(job *model.Job, jobListKeys ...JobListKeyType) error
        + DeQueueDDLJob() (*model.Job, error)
        + GetDDLJobByIdx(index int64, jobListKeys ...JobListKeyType) (*model.Job, error)
        + UpdateDDLJob(index int64, job *model.Job, updateRawArgs bool, jobListKeys ...JobListKeyType) error
        + DDLJobQueueLen(jobListKeys ...JobListKeyType) (int64, error)
        + GetAllDDLJobsInQueue(jobListKeys ...JobListKeyType) ([]*model.Job, error)
        + AddHistoryDDLJob(job *model.Job, updateRawArgs bool) error
        + GetHistoryDDLJob(id int64) (*model.Job, error)
        + GetAllHistoryDDLJobs() ([]*model.Job, error)
        + GetLastNHistoryDDLJobs(num int) ([]*model.Job, error)
        + GetLastHistoryDDLJobsIterator() (*LastJobIterator, error)
        + GetBootstrapVersion() (int64, error)
        + FinishBootstrap(version int64) error
        + UpdateDDLReorgStartHandle(job *model.Job, startHandle int64) error
        + UpdateDDLReorgHandle(job *model.Job, startHandle int64, endHandle int64, physicalTableID int64) error
        + RemoveDDLReorgHandle(job *model.Job) error
        + GetDDLReorgHandle(job *model.Job) (int64, error)
        + GetSchemaDiff(schemaVersion int64) (*model.SchemaDiff, error)
        + SetSchemaDiff(diff *model.SchemaDiff) error

    }
    class jobsSorter << (S,Aquamarine) >> {
        - jobs []*model.Job

        + Swap(i int, j int) 
        + Len() int
        + Less(i int, j int) bool

    }
    class meta.JobListKeyType << (T, #FF7700) >>  {
    }
}


namespace mock {
    class Client << (S,Aquamarine) >> {
        + MockResponse kv.Response

        + Send(ctx context.Context, req *kv.Request, kv *kv.Variables) kv.Response

    }
    class Context << (S,Aquamarine) >> {
        - values <font color=blue>map</font>[fmt.Stringer]<font color=blue>interface</font>{}
        - txn wrapTxn
        - sessionVars *variable.SessionVars
        - ctx context.Context
        - cancel context.CancelFunc
        - sm util.SessionManager
        - pcache *kvcache.SimpleLRUCache

        + Store kv.Storage

        + Execute(ctx context.Context, sql string) ([]sqlexec.RecordSet, error)
        + ExecuteInternal(ctx context.Context, sql string) ([]sqlexec.RecordSet, error)
        + DDLOwnerChecker() owner.DDLOwnerChecker
        + SetValue(key fmt.Stringer, value <font color=blue>interface</font>{}) 
        + Value(key fmt.Stringer) <font color=blue>interface</font>{}
        + ClearValue(key fmt.Stringer) 
        + HasDirtyContent(tid int64) bool
        + GetSessionVars() *variable.SessionVars
        + Txn( bool) (kv.Transaction, error)
        + GetClient() kv.Client
        + GetGlobalSysVar(ctx sessionctx.Context, name string) (string, error)
        + SetGlobalSysVar(ctx sessionctx.Context, name string, value string) error
        + PreparedPlanCache() *kvcache.SimpleLRUCache
        + NewTxn( context.Context) error
        + RefreshTxnCtx(ctx context.Context) error
        + InitTxnWithStartTS(startTS uint64) error
        + GetStore() kv.Storage
        + GetSessionManager() util.SessionManager
        + SetSessionManager(sm util.SessionManager) 
        + Cancel() 
        + GoCtx() context.Context
        + StoreQueryFeedback(_ <font color=blue>interface</font>{}) 
        + StmtCommit(tracker *memory.Tracker) error
        + StmtRollback() 
        + StmtGetMutation(tableID int64) *binlog.TableMutation
        + StmtAddDirtyTableOP(op int, tid int64, handle int64) 
        + AddTableLock(_ []model.TableLockTpInfo) 
        + ReleaseTableLocks(locks []model.TableLockTpInfo) 
        + ReleaseTableLockByTableIDs(tableIDs []int64) 
        + CheckTableLocked(_ int64) (bool, model.TableLockType)
        + GetAllTableLocks() []model.TableLockTpInfo
        + ReleaseAllTableLocks() 
        + HasLockedTables() bool
        + PrepareTSFuture(ctx context.Context) 
        + Close() 

    }
    class Store << (S,Aquamarine) >> {
        + Client kv.Client

        + GetClient() kv.Client
        + GetOracle() oracle.Oracle
        + Begin() (kv.Transaction, error)
        + BeginWithStartTS(startTS uint64) (kv.Transaction, error)
        + GetSnapshot(ver kv.Version) (kv.Snapshot, error)
        + Close() error
        + UUID() string
        + CurrentVersion() (kv.Version, error)
        + SupportDeleteRange() bool
        + Name() string
        + Describe() string
        + ShowStatus(ctx context.Context, key string) (<font color=blue>interface</font>{}, error)

    }
    class mock.HookKeyForTest << (T, #FF7700) >>  {
    }
    class mockDDLOwnerChecker << (S,Aquamarine) >> {
        + IsOwner() bool

    }
    class wrapTxn << (S,Aquamarine) >> {
        + Valid() bool

    }
}
"kv.RequestTypeSupportedChecker" *-- "mock.Client"
"kv.Transaction" *-- "mock.wrapTxn"

"sessionctx.Context" <|-- "mock.Context"
"sqlexec.SQLExecutor" <|-- "mock.Context"
"executor.Closeable" <|-- "mock.Store"
"kv.Storage" <|-- "mock.Store"
"kv.VersionProvider" <|-- "mock.Store"
"owner.DDLOwnerChecker" <|-- "mock.mockDDLOwnerChecker"
"util.ownerChecker" <|-- "mock.mockDDLOwnerChecker"

namespace mockoracle {
    class MockOracle << (S,Aquamarine) >> {
        - stop bool
        - offset time.Duration
        - lastTS uint64

        + Enable() 
        + Disable() 
        + AddOffset(d time.Duration) 
        + GetTimestamp( context.Context) (uint64, error)
        + GetTimestampAsync(ctx context.Context) oracle.Future
        + GetLowResolutionTimestamp(ctx context.Context) (uint64, error)
        + GetLowResolutionTimestampAsync(ctx context.Context) oracle.Future
        + IsExpired(lockTimestamp uint64, TTL uint64) bool
        + UntilExpired(lockTimeStamp uint64, TTL uint64) int64
        + Close() 

    }
    class mockOracleFuture << (S,Aquamarine) >> {
        - o *MockOracle
        - ctx context.Context

        + Wait() (uint64, error)

    }
}
"sync.RWMutex" *-- "mockoracle.MockOracle"

"oracle.Oracle" <|-- "mockoracle.MockOracle"
"oracle.Future" <|-- "mockoracle.mockOracleFuture"

namespace mockstore {
    class MockDriver << (S,Aquamarine) >> {
        + Open(path string) (kv.Storage, error)

    }
    class mockOptions << (S,Aquamarine) >> {
        - cluster *mocktikv.Cluster
        - mvccStore mocktikv.MVCCStore
        - clientHijack <font color=blue>func</font>(tikv.Client) tikv.Client
        - pdClientHijack <font color=blue>func</font>(client.Client) client.Client
        - path string
        - txnLocalLatches uint

    }
    class mockstore.MockTiKVStoreOption << (T, #FF7700) >>  {
    }
}

"kv.Driver" <|-- "mockstore.MockDriver"

namespace mocktikv {
    interface Client  {
        + Close() error
        + SendRequest(ctx context.Context, addr string, req *tikvrpc.Request, timeout time.Duration) (*tikvrpc.Response, error)

    }
    class Cluster << (S,Aquamarine) >> {
        - id uint64
        - stores <font color=blue>map</font>[uint64]*Store
        - regions <font color=blue>map</font>[uint64]*Region
        - delayEvents <font color=blue>map</font>[delayKey]time.Duration
        - delayMu sync.Mutex

        - allocID() uint64
        - handleDelay(startTS uint64, regionID uint64) 
        - splitRange(mvccStore MVCCStore, start MvccKey, end MvccKey, count int) 
        - getEntriesGroupByRegions(mvccStore MVCCStore, start MvccKey, end MvccKey, count int) [][]Pair
        - createNewRegions(regionPairs [][]Pair, start MvccKey, end MvccKey) 
        - evacuateOldRegionRanges(start MvccKey, end MvccKey) 
        - firstStoreID() uint64
        - getRegionsCoverRange(start MvccKey, end MvccKey) []*Region

        + AllocID() uint64
        + AllocIDs(n int) []uint64
        + GetAllRegions() []*Region
        + GetStore(storeID uint64) *metapb.Store
        + GetAllStores() []*metapb.Store
        + StopStore(storeID uint64) 
        + StartStore(storeID uint64) 
        + CancelStore(storeID uint64) 
        + UnCancelStore(storeID uint64) 
        + GetStoreByAddr(addr string) *metapb.Store
        + GetAndCheckStoreByAddr(addr string) (*metapb.Store, error)
        + AddStore(storeID uint64, addr string) 
        + RemoveStore(storeID uint64) 
        + UpdateStoreAddr(storeID uint64, addr string, labels ...*metapb.StoreLabel) 
        + GetRegion(regionID uint64) (*metapb.Region, uint64)
        + GetRegionByKey(key []byte) (*metapb.Region, *metapb.Peer)
        + GetPrevRegionByKey(key []byte) (*metapb.Region, *metapb.Peer)
        + GetRegionByID(regionID uint64) (*metapb.Region, *metapb.Peer)
        + ScanRegions(startKey []byte, endKey []byte, limit int) ([]*metapb.Region, []*metapb.Peer)
        + Bootstrap(regionID uint64, storeIDs []uint64, peerIDs []uint64, leaderPeerID uint64) 
        + AddPeer(regionID uint64, storeID uint64, peerID uint64) 
        + RemovePeer(regionID uint64, storeID uint64) 
        + ChangeLeader(regionID uint64, leaderPeerID uint64) 
        + GiveUpLeader(regionID uint64) 
        + Split(regionID uint64, newRegionID uint64, key []byte, peerIDs []uint64, leaderPeerID uint64) 
        + SplitRaw(regionID uint64, newRegionID uint64, rawKey []byte, peerIDs []uint64, leaderPeerID uint64) *metapb.Region
        + Merge(regionID1 uint64, regionID2 uint64) 
        + SplitTable(mvccStore MVCCStore, tableID int64, count int) 
        + SplitIndex(mvccStore MVCCStore, tableID int64, indexID int64, count int) 
        + SplitKeys(mvccStore MVCCStore, start kv.Key, end kv.Key, count int) 
        + ScheduleDelay(startTS uint64, regionID uint64, dur time.Duration) 

    }
    class ErrAbort << (S,Aquamarine) >> {
        + Error() string

    }
    class ErrAlreadyCommitted << (S,Aquamarine) >> {
        + Error() string

    }
    class ErrAlreadyRollbacked << (S,Aquamarine) >> {
        - startTS uint64
        - key []byte

        + Error() string

    }
    class ErrCommitTSExpired << (S,Aquamarine) >> {
        + Error() string

    }
    class ErrConflict << (S,Aquamarine) >> {
        + StartTS uint64
        + ConflictTS uint64
        + ConflictCommitTS uint64
        + Key []byte

        + Error() string

    }
    class ErrDeadlock << (S,Aquamarine) >> {
        + LockTS uint64
        + LockKey []byte
        + DealockKeyHash uint64

        + Error() string

    }
    class ErrKeyAlreadyExist << (S,Aquamarine) >> {
        + Key []byte

        + Error() string

    }
    class ErrLocked << (S,Aquamarine) >> {
        + Key MvccKey
        + Primary []byte
        + StartTS uint64
        + ForUpdateTS uint64
        + TTL uint64
        + TxnSize uint64
        + LockType kvrpcpb.Op

        + Error() string

    }
    class ErrRetryable << (S,Aquamarine) >> {
        + Error() string

    }
    class ErrTxnNotFound << (S,Aquamarine) >> {
        + Error() string

    }
    class Iterator << (S,Aquamarine) >> {
        - valid bool

        + Next() 
        + Valid() bool

    }
    interface MVCCDebugger  {
        + MvccGetByStartTS(starTS uint64) (*kvrpcpb.MvccInfo, []byte)
        + MvccGetByKey(key []byte) *kvrpcpb.MvccInfo

    }
    class MVCCLevelDB << (S,Aquamarine) >> {
        - db *leveldb.DB
        - mu sync.RWMutex
        - deadlockDetector *deadlock.Detector

        - getValue(key []byte, startTS uint64, isoLevel kvrpcpb.IsolationLevel, resolvedLocks []uint64) ([]byte, error)
        - pessimisticLockMutation(batch *leveldb.Batch, mutation *kvrpcpb.Mutation, lctx *lockCtx) error
        - doRawDeleteRange(startKey []byte, endKey []byte) error

        + Get(key []byte, startTS uint64, isoLevel kvrpcpb.IsolationLevel, resolvedLocks []uint64) ([]byte, error)
        + BatchGet(ks [][]byte, startTS uint64, isoLevel kvrpcpb.IsolationLevel, resolvedLocks []uint64) []Pair
        + Scan(startKey []byte, endKey []byte, limit int, startTS uint64, isoLevel kvrpcpb.IsolationLevel, resolvedLock []uint64) []Pair
        + ReverseScan(startKey []byte, endKey []byte, limit int, startTS uint64, isoLevel kvrpcpb.IsolationLevel, resolvedLocks []uint64) []Pair
        + PessimisticLock(req *kvrpcpb.PessimisticLockRequest) *kvrpcpb.PessimisticLockResponse
        + PessimisticRollback(keys [][]byte, startTS uint64, forUpdateTS uint64) []error
        + Prewrite(req *kvrpcpb.PrewriteRequest) []error
        + Commit(keys [][]byte, startTS uint64, commitTS uint64) error
        + Rollback(keys [][]byte, startTS uint64) error
        + Cleanup(key []byte, startTS uint64, currentTS uint64) error
        + CheckTxnStatus(primaryKey []byte, lockTS uint64, callerStartTS uint64, currentTS uint64, rollbackIfNotExist bool) (uint64, uint64, kvrpcpb.Action, error)
        + TxnHeartBeat(key []byte, startTS uint64, adviseTTL uint64) (uint64, error)
        + ScanLock(startKey []byte, endKey []byte, maxTS uint64) ([]*kvrpcpb.LockInfo, error)
        + ResolveLock(startKey []byte, endKey []byte, startTS uint64, commitTS uint64) error
        + BatchResolveLock(startKey []byte, endKey []byte, txnInfos <font color=blue>map</font>[uint64]uint64) error
        + GC(startKey []byte, endKey []byte, safePoint uint64) error
        + DeleteRange(startKey []byte, endKey []byte) error
        + Close() error
        + RawPut(key []byte, value []byte) 
        + RawBatchPut(keys [][]byte, values [][]byte) 
        + RawGet(key []byte) []byte
        + RawBatchGet(keys [][]byte) [][]byte
        + RawDelete(key []byte) 
        + RawBatchDelete(keys [][]byte) 
        + RawScan(startKey []byte, endKey []byte, limit int) []Pair
        + RawReverseScan(startKey []byte, endKey []byte, limit int) []Pair
        + RawDeleteRange(startKey []byte, endKey []byte) 
        + MvccGetByStartTS(starTS uint64) (*kvrpcpb.MvccInfo, []byte)
        + MvccGetByKey(key []byte) *kvrpcpb.MvccInfo

    }
    interface MVCCStore  {
        + Get(key []byte, startTS uint64, isoLevel kvrpcpb.IsolationLevel, resolvedLocks []uint64) ([]byte, error)
        + Scan(startKey []byte, endKey []byte, limit int, startTS uint64, isoLevel kvrpcpb.IsolationLevel, resolvedLocks []uint64) []Pair
        + ReverseScan(startKey []byte, endKey []byte, limit int, startTS uint64, isoLevel kvrpcpb.IsolationLevel, resolvedLocks []uint64) []Pair
        + BatchGet(ks [][]byte, startTS uint64, isoLevel kvrpcpb.IsolationLevel, resolvedLocks []uint64) []Pair
        + PessimisticLock(req *kvrpcpb.PessimisticLockRequest) *kvrpcpb.PessimisticLockResponse
        + PessimisticRollback(keys [][]byte, startTS uint64, forUpdateTS uint64) []error
        + Prewrite(req *kvrpcpb.PrewriteRequest) []error
        + Commit(keys [][]byte, startTS uint64, commitTS uint64) error
        + Rollback(keys [][]byte, startTS uint64) error
        + Cleanup(key []byte, startTS uint64, currentTS uint64) error
        + ScanLock(startKey []byte, endKey []byte, maxTS uint64) ([]*kvrpcpb.LockInfo, error)
        + TxnHeartBeat(primaryKey []byte, startTS uint64, adviseTTL uint64) (uint64, error)
        + ResolveLock(startKey []byte, endKey []byte, startTS uint64, commitTS uint64) error
        + BatchResolveLock(startKey []byte, endKey []byte, txnInfos <font color=blue>map</font>[uint64]uint64) error
        + GC(startKey []byte, endKey []byte, safePoint uint64) error
        + DeleteRange(startKey []byte, endKey []byte) error
        + CheckTxnStatus(primaryKey []byte, lockTS uint64, startTS uint64, currentTS uint64, rollbackIfNotFound bool) (uint64, uint64, kvrpcpb.Action, error)
        + Close() error

    }
    class MvccKey << (S,Aquamarine) >> {
        + Raw() []byte

    }
    class Pair << (S,Aquamarine) >> {
        + Key []byte
        + Value []byte
        + Err error

    }
    class RPCClient << (S,Aquamarine) >> {
        - streamTimeout <font color=blue>chan</font> *tikvrpc.Lease
        - done <font color=blue>chan</font> <font color=blue>struct</font>{}
        - rpcCli Client

        + Cluster *Cluster
        + MvccStore MVCCStore

        - getAndCheckStoreByAddr(addr string) (*metapb.Store, error)
        - checkArgs(ctx context.Context, addr string) (*rpcHandler, error)
        - redirectRequestToRPCServer(ctx context.Context, addr string, req *tikvrpc.Request, timeout time.Duration) (*tikvrpc.Response, error)

        + SendRequest(ctx context.Context, addr string, req *tikvrpc.Request, timeout time.Duration) (*tikvrpc.Response, error)
        + Close() error

    }
    interface RawKV  {
        + RawGet(key []byte) []byte
        + RawBatchGet(keys [][]byte) [][]byte
        + RawScan(startKey []byte, endKey []byte, limit int) []Pair
        + RawReverseScan(startKey []byte, endKey []byte, limit int) []Pair
        + RawPut(key []byte, value []byte) 
        + RawBatchPut(keys [][]byte, values [][]byte) 
        + RawDelete(key []byte) 
        + RawBatchDelete(keys [][]byte) 
        + RawDeleteRange(startKey []byte, endKey []byte) 

    }
    class Region << (S,Aquamarine) >> {
        - leader uint64

        + Meta *metapb.Region

        - addPeer(peerID uint64, storeID uint64) 
        - removePeer(peerID uint64) 
        - changeLeader(leaderID uint64) 
        - leaderPeer() *metapb.Peer
        - split(newRegionID uint64, key MvccKey, peerIDs []uint64, leaderPeerID uint64) *Region
        - merge(endKey MvccKey) 
        - updateKeyRange(start MvccKey, end MvccKey) 
        - incConfVer() 
        - incVersion() 

    }
    class Store << (S,Aquamarine) >> {
        - meta *metapb.Store
        - cancel bool
        - tokenCount atomic.Int64

    }
    class analyzeColumnsExec << (S,Aquamarine) >> {
        - tblExec *tableScanExec
        - fields []*ast.ResultField

        - getNext(ctx context.Context) ([]types.Datum, error)

        + Fields() []*ast.ResultField
        + Next(ctx context.Context, req *chunk.Chunk) error
        + NewChunk() *chunk.Chunk
        + Close() error

    }
    class dagContext << (S,Aquamarine) >> {
        - dagReq *tipb.DAGRequest
        - keyRanges []*coprocessor.KeyRange
        - startTS uint64
        - evalCtx *evalContext

    }
    class delayKey << (S,Aquamarine) >> {
        - startTS uint64
        - regionID uint64

    }
    class evalContext << (S,Aquamarine) >> {
        - colIDs <font color=blue>map</font>[int64]int
        - columnInfos []*tipb.ColumnInfo
        - fieldTps []*types.FieldType
        - sc *stmtctx.StatementContext

        - setColumnInfo(cols []*tipb.ColumnInfo) 
        - decodeRelatedColumnVals(relatedColOffsets []int, value [][]byte, row []types.Datum) error

    }
    class execDetail << (S,Aquamarine) >> {
        - timeProcessed time.Duration
        - numProducedRows int
        - numIterations int

        - update(begin time.Time, row [][]byte) 

    }
    interface executor  {
        + SetSrcExec( executor) 
        + GetSrcExec() executor
        + ResetCounts() 
        + Counts() []int64
        + Next(ctx context.Context) ([][]byte, error)
        + Cursor() ([]byte, bool)
        + ExecDetails() []*execDetail

    }
    class hashAggExec << (S,Aquamarine) >> {
        - evalCtx *evalContext
        - aggExprs []aggregation.Aggregation
        - aggCtxsMap aggCtxsMapper
        - groupByExprs []expression.Expression
        - relatedColOffsets []int
        - row []types.Datum
        - groups <font color=blue>map</font>[string]<font color=blue>struct</font>{}
        - groupKeys [][]byte
        - groupKeyRows [][][]byte
        - executed bool
        - currGroupIdx int
        - count int64
        - execDetail *execDetail
        - src executor

        - innerNext(ctx context.Context) (bool, error)
        - getGroupKey() ([]byte, [][]byte, error)
        - aggregate(value [][]byte) error
        - getContexts(groupKey []byte) []*aggregation.AggEvaluateContext

        + ExecDetails() []*execDetail
        + SetSrcExec(exec executor) 
        + GetSrcExec() executor
        + ResetCounts() 
        + Counts() []int64
        + Cursor() ([]byte, bool)
        + Next(ctx context.Context) ([][]byte, error)

    }
    class indexScanExec << (S,Aquamarine) >> {
        - colsLen int
        - kvRanges []kv.KeyRange
        - startTS uint64
        - isolationLevel kvrpcpb.IsolationLevel
        - resolvedLocks []uint64
        - mvccStore MVCCStore
        - cursor int
        - seekKey []byte
        - hdStatus tablecodec.HandleStatus
        - start int
        - counts []int64
        - execDetail *execDetail
        - colInfos []rowcodec.ColInfo
        - src executor

        - isUnique() bool
        - getRowFromPoint(ran kv.KeyRange) ([][]byte, error)
        - getRowFromRange(ran kv.KeyRange) ([][]byte, error)

        + ExecDetails() []*execDetail
        + SetSrcExec(exec executor) 
        + GetSrcExec() executor
        + ResetCounts() 
        + Counts() []int64
        + Cursor() ([]byte, bool)
        + Next(ctx context.Context) ([][]byte, error)

    }
    class limitExec << (S,Aquamarine) >> {
        - limit uint64
        - cursor uint64
        - src executor
        - execDetail *execDetail

        + ExecDetails() []*execDetail
        + SetSrcExec(src executor) 
        + GetSrcExec() executor
        + ResetCounts() 
        + Counts() []int64
        + Cursor() ([]byte, bool)
        + Next(ctx context.Context) ([][]byte, error)

    }
    class lockCtx << (S,Aquamarine) >> {
        - startTS uint64
        - forUpdateTS uint64
        - primary []byte
        - ttl uint64
        - minCommitTs uint64
        - returnValues bool
        - values [][]byte

    }
    class lockDecoder << (S,Aquamarine) >> {
        - lock mvccLock
        - expectKey []byte

        + Decode(iter *Iterator) (bool, error)

    }
    class marshalHelper << (S,Aquamarine) >> {
        - err error

        + WriteSlice(buf io.Writer, slice []byte) 
        + WriteNumber(buf io.Writer, n <font color=blue>interface</font>{}) 
        + ReadNumber(r io.Reader, n <font color=blue>interface</font>{}) 
        + ReadSlice(r *bytes.Buffer, slice *[]byte) 

    }
    class mockClientStream << (S,Aquamarine) >> {
        + Header() (metadata.MD, error)
        + Trailer() metadata.MD
        + CloseSend() error
        + Context() context.Context
        + SendMsg(m <font color=blue>interface</font>{}) error
        + RecvMsg(m <font color=blue>interface</font>{}) error

    }
    class mockCopStreamClient << (S,Aquamarine) >> {
        - req *tipb.DAGRequest
        - exec executor
        - ctx context.Context
        - dagCtx *dagContext
        - finished bool

        - readBlockFromExecutor() (tipb.Chunk, bool, *coprocessor.KeyRange, []int64, []stmtctx.SQLWarn, error)

        + Recv() (*coprocessor.Response, error)

    }
    class mockCopStreamErrClient << (S,Aquamarine) >> {
        + Recv() (*coprocessor.Response, error)

    }
    class mockTSFuture << (S,Aquamarine) >> {
        - pdc *pdClient
        - ctx context.Context
        - used bool

        + Wait() (int64, int64, error)

    }
    class mocktikv.ErrAbort << (T, #FF7700) >>  {
    }
    class mocktikv.ErrAlreadyCommitted << (T, #FF7700) >>  {
    }
    class mocktikv.ErrRetryable << (T, #FF7700) >>  {
    }
    class mocktikv.MvccKey << (T, #FF7700) >>  {
    }
    class mocktikv.aggCtxsMapper << (T, #FF7700) >>  {
    }
    class mocktikv.mvccValueType << (T, #FF7700) >>  {
    }
    class mvccEntry << (S,Aquamarine) >> {
        - key MvccKey
        - values []mvccValue
        - lock *mvccLock

        + Less(than btree.Item) bool
        + Get(ts uint64, isoLevel kvrpcpb.IsolationLevel, resolvedLocks []uint64) ([]byte, error)

    }
    class mvccLock << (S,Aquamarine) >> {
        - startTS uint64
        - primary []byte
        - value []byte
        - op kvrpcpb.Op
        - ttl uint64
        - forUpdateTS uint64
        - txnSize uint64
        - minCommitTS uint64

        - lockErr(key []byte) error
        - check(ts uint64, key []byte, resolvedLocks []uint64) (uint64, error)

        + MarshalBinary() ([]byte, error)
        + UnmarshalBinary(data []byte) error

    }
    class mvccValue << (S,Aquamarine) >> {
        - valueType mvccValueType
        - startTS uint64
        - commitTS uint64
        - value []byte

        + MarshalBinary() ([]byte, error)
        + UnmarshalBinary(data []byte) error

    }
    class pdClient << (S,Aquamarine) >> {
        - cluster *Cluster
        - gcSafePoint uint64
        - serviceSafePoints <font color=blue>map</font>[string]uint64
        - gcSafePointMu sync.Mutex

        + ConfigClient() client.ConfigClient
        + GetClusterID(ctx context.Context) uint64
        + GetTS( context.Context) (int64, int64, error)
        + GetTSAsync(ctx context.Context) client.TSFuture
        + GetRegion(ctx context.Context, key []byte) (*client.Region, error)
        + GetPrevRegion(ctx context.Context, key []byte) (*client.Region, error)
        + GetRegionByID(ctx context.Context, regionID uint64) (*client.Region, error)
        + ScanRegions(ctx context.Context, startKey []byte, endKey []byte, limit int) ([]*metapb.Region, []*metapb.Peer, error)
        + GetStore(ctx context.Context, storeID uint64) (*metapb.Store, error)
        + GetAllStores(ctx context.Context, opts ...client.GetStoreOption) ([]*metapb.Store, error)
        + UpdateGCSafePoint(ctx context.Context, safePoint uint64) (uint64, error)
        + UpdateServiceGCSafePoint(ctx context.Context, serviceID string, ttl int64, safePoint uint64) (uint64, error)
        + Close() 
        + ScatterRegion(ctx context.Context, regionID uint64) error
        + GetOperator(ctx context.Context, regionID uint64) (*pdpb.GetOperatorResponse, error)
        + GetLeaderAddr() string

    }
    class rawEntry << (S,Aquamarine) >> {
        - key []byte
        - value []byte

        + Less(than btree.Item) bool

    }
    class reverseScanHelper << (S,Aquamarine) >> {
        - startTS uint64
        - isoLevel kvrpcpb.IsolationLevel
        - resolvedLocks []uint64
        - currKey []byte
        - entry mvccEntry
        - pairs []Pair

        - finishEntry() 

    }
    class rpcHandler << (S,Aquamarine) >> {
        - cluster *Cluster
        - mvccStore MVCCStore
        - storeID uint64
        - startKey []byte
        - endKey []byte
        - rawStartKey []byte
        - rawEndKey []byte
        - isolationLevel kvrpcpb.IsolationLevel
        - resolvedLocks []uint64

        - handleCopDAGRequest(req *coprocessor.Request) *coprocessor.Response
        - buildDAGExecutor(req *coprocessor.Request) (*dagContext, executor, *tipb.DAGRequest, error)
        - handleCopStream(ctx context.Context, req *coprocessor.Request) (tikvpb.Tikv_CoprocessorStreamClient, error)
        - buildExec(ctx *dagContext, curr *tipb.Executor) (executor, error)
        - buildDAG(ctx *dagContext, executors []*tipb.Executor) (executor, error)
        - buildTableScan(ctx *dagContext, executor *tipb.Executor) (*tableScanExec, error)
        - buildIndexScan(ctx *dagContext, executor *tipb.Executor) (*indexScanExec, error)
        - buildSelection(ctx *dagContext, executor *tipb.Executor) (*selectionExec, error)
        - getAggInfo(ctx *dagContext, executor *tipb.Executor) ([]aggregation.Aggregation, []expression.Expression, []int, error)
        - buildHashAgg(ctx *dagContext, executor *tipb.Executor) (*hashAggExec, error)
        - buildStreamAgg(ctx *dagContext, executor *tipb.Executor) (*streamAggExec, error)
        - buildTopN(ctx *dagContext, executor *tipb.Executor) (*topNExec, error)
        - initSelectResponse(err error, warnings []stmtctx.SQLWarn, counts []int64) *tipb.SelectResponse
        - fillUpData4SelectResponse(selResp *tipb.SelectResponse, dagReq *tipb.DAGRequest, dagCtx *dagContext, rows [][][]byte) error
        - constructRespSchema(dagCtx *dagContext) []*types.FieldType
        - encodeDefault(selResp *tipb.SelectResponse, rows [][][]byte, colOrdinal []uint32) 
        - encodeChunk(selResp *tipb.SelectResponse, rows [][][]byte, colTypes []*types.FieldType, colOrdinal []uint32, loc *time.Location) error
        - extractKVRanges(keyRanges []*coprocessor.KeyRange, descScan bool) ([]kv.KeyRange, error)
        - handleCopAnalyzeRequest(req *coprocessor.Request) *coprocessor.Response
        - handleAnalyzeIndexReq(req *coprocessor.Request, analyzeReq *tipb.AnalyzeReq) (*coprocessor.Response, error)
        - handleAnalyzeColumnsReq(req *coprocessor.Request, analyzeReq *tipb.AnalyzeReq) (*coprocessor.Response, error)
        - checkRequestContext(ctx *kvrpcpb.Context) *errorpb.Error
        - checkRequestSize(size int) *errorpb.Error
        - checkRequest(ctx *kvrpcpb.Context, size int) *errorpb.Error
        - checkKeyInRegion(key []byte) bool
        - handleKvGet(req *kvrpcpb.GetRequest) *kvrpcpb.GetResponse
        - handleKvScan(req *kvrpcpb.ScanRequest) *kvrpcpb.ScanResponse
        - handleKvPrewrite(req *kvrpcpb.PrewriteRequest) *kvrpcpb.PrewriteResponse
        - handleKvPessimisticLock(req *kvrpcpb.PessimisticLockRequest) *kvrpcpb.PessimisticLockResponse
        - handleKvPessimisticRollback(req *kvrpcpb.PessimisticRollbackRequest) *kvrpcpb.PessimisticRollbackResponse
        - handleKvCommit(req *kvrpcpb.CommitRequest) *kvrpcpb.CommitResponse
        - handleKvCleanup(req *kvrpcpb.CleanupRequest) *kvrpcpb.CleanupResponse
        - handleKvCheckTxnStatus(req *kvrpcpb.CheckTxnStatusRequest) *kvrpcpb.CheckTxnStatusResponse
        - handleTxnHeartBeat(req *kvrpcpb.TxnHeartBeatRequest) *kvrpcpb.TxnHeartBeatResponse
        - handleKvBatchGet(req *kvrpcpb.BatchGetRequest) *kvrpcpb.BatchGetResponse
        - handleMvccGetByKey(req *kvrpcpb.MvccGetByKeyRequest) *kvrpcpb.MvccGetByKeyResponse
        - handleMvccGetByStartTS(req *kvrpcpb.MvccGetByStartTsRequest) *kvrpcpb.MvccGetByStartTsResponse
        - handleKvBatchRollback(req *kvrpcpb.BatchRollbackRequest) *kvrpcpb.BatchRollbackResponse
        - handleKvScanLock(req *kvrpcpb.ScanLockRequest) *kvrpcpb.ScanLockResponse
        - handleKvResolveLock(req *kvrpcpb.ResolveLockRequest) *kvrpcpb.ResolveLockResponse
        - handleKvGC(req *kvrpcpb.GCRequest) *kvrpcpb.GCResponse
        - handleKvDeleteRange(req *kvrpcpb.DeleteRangeRequest) *kvrpcpb.DeleteRangeResponse
        - handleKvRawGet(req *kvrpcpb.RawGetRequest) *kvrpcpb.RawGetResponse
        - handleKvRawBatchGet(req *kvrpcpb.RawBatchGetRequest) *kvrpcpb.RawBatchGetResponse
        - handleKvRawPut(req *kvrpcpb.RawPutRequest) *kvrpcpb.RawPutResponse
        - handleKvRawBatchPut(req *kvrpcpb.RawBatchPutRequest) *kvrpcpb.RawBatchPutResponse
        - handleKvRawDelete(req *kvrpcpb.RawDeleteRequest) *kvrpcpb.RawDeleteResponse
        - handleKvRawBatchDelete(req *kvrpcpb.RawBatchDeleteRequest) *kvrpcpb.RawBatchDeleteResponse
        - handleKvRawDeleteRange(req *kvrpcpb.RawDeleteRangeRequest) *kvrpcpb.RawDeleteRangeResponse
        - handleKvRawScan(req *kvrpcpb.RawScanRequest) *kvrpcpb.RawScanResponse
        - handleSplitRegion(req *kvrpcpb.SplitRegionRequest) *kvrpcpb.SplitRegionResponse
        - handleCopChecksumRequest(req *coprocessor.Request) *coprocessor.Response

    }
    class selectionExec << (S,Aquamarine) >> {
        - conditions []expression.Expression
        - relatedColOffsets []int
        - row []types.Datum
        - evalCtx *evalContext
        - src executor
        - execDetail *execDetail

        + ExecDetails() []*execDetail
        + SetSrcExec(exec executor) 
        + GetSrcExec() executor
        + ResetCounts() 
        + Counts() []int64
        + Cursor() ([]byte, bool)
        + Next(ctx context.Context) ([][]byte, error)

    }
    class skipDecoder << (S,Aquamarine) >> {
        - currKey []byte

        + Decode(iter *Iterator) (bool, error)

    }
    class sortRow << (S,Aquamarine) >> {
        - key []types.Datum
        - data [][]byte

    }
    class streamAggExec << (S,Aquamarine) >> {
        - evalCtx *evalContext
        - aggExprs []aggregation.Aggregation
        - aggCtxs []*aggregation.AggEvaluateContext
        - groupByExprs []expression.Expression
        - relatedColOffsets []int
        - row []types.Datum
        - tmpGroupByRow []types.Datum
        - currGroupByRow []types.Datum
        - nextGroupByRow []types.Datum
        - currGroupByValues [][]byte
        - executed bool
        - hasData bool
        - count int64
        - execDetail *execDetail
        - src executor

        - getPartialResult() ([][]byte, error)
        - meetNewGroup(row [][]byte) (bool, error)

        + ExecDetails() []*execDetail
        + SetSrcExec(exec executor) 
        + GetSrcExec() executor
        + ResetCounts() 
        + Counts() []int64
        + Cursor() ([]byte, bool)
        + Next(ctx context.Context) ([][]byte, error)

    }
    class tableScanExec << (S,Aquamarine) >> {
        - colIDs <font color=blue>map</font>[int64]int
        - kvRanges []kv.KeyRange
        - startTS uint64
        - isolationLevel kvrpcpb.IsolationLevel
        - resolvedLocks []uint64
        - mvccStore MVCCStore
        - cursor int
        - seekKey []byte
        - start int
        - counts []int64
        - execDetail *execDetail
        - rd *rowcodec.BytesDecoder
        - src executor

        - getRowFromPoint(ran kv.KeyRange) ([][]byte, error)
        - getRowFromRange(ran kv.KeyRange) ([][]byte, error)

        + ExecDetails() []*execDetail
        + SetSrcExec(exec executor) 
        + GetSrcExec() executor
        + ResetCounts() 
        + Counts() []int64
        + Cursor() ([]byte, bool)
        + Next(ctx context.Context) ([][]byte, error)

    }
    class topNExec << (S,Aquamarine) >> {
        - heap *topNHeap
        - evalCtx *evalContext
        - relatedColOffsets []int
        - orderByExprs []expression.Expression
        - row []types.Datum
        - cursor int
        - executed bool
        - execDetail *execDetail
        - src executor

        - innerNext(ctx context.Context) (bool, error)
        - evalTopN(value [][]byte) error

        + ExecDetails() []*execDetail
        + SetSrcExec(src executor) 
        + GetSrcExec() executor
        + ResetCounts() 
        + Counts() []int64
        + Cursor() ([]byte, bool)
        + Next(ctx context.Context) ([][]byte, error)

    }
    class topNHeap << (S,Aquamarine) >> {
        - totalCount int
        - heapSize int

        - tryToAddRow(row *sortRow) bool

        + Len() int
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}
        + Less(i int, j int) bool

    }
    class topNSorter << (S,Aquamarine) >> {
        - orderByItems []*tipb.ByItem
        - rows []*sortRow
        - err error
        - sc *stmtctx.StatementContext

        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool

    }
    class valueDecoder << (S,Aquamarine) >> {
        - value mvccValue
        - expectKey []byte

        + Decode(iter *Iterator) (bool, error)

    }
    class "<font color=blue>map</font>[string][]*aggregation.AggEvaluateContext" as fontcolorbluemapfontstringaggregationAggEvaluateContext {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"sync.RWMutex" *-- "mocktikv.Cluster"
"kvrpcpb.CommitTsExpired" *-- "mocktikv.ErrCommitTSExpired"
"kvrpcpb.TxnNotFound" *-- "mocktikv.ErrTxnNotFound"
"iterator.Iterator" *-- "mocktikv.Iterator"
"sync.Once" *-- "mocktikv.RPCClient"
"tipb.IndexScan" *-- "mocktikv.indexScanExec"
"mocktikv.mockClientStream" *-- "mocktikv.mockCopStreamClient"
"errorpb.Error" *-- "mocktikv.mockCopStreamErrClient"
"mocktikv.mockClientStream" *-- "mocktikv.mockCopStreamErrClient"
"tipb.TableScan" *-- "mocktikv.tableScanExec"
"mocktikv.topNSorter" *-- "mocktikv.topNHeap"

"executor.Closeable" <|-- "mocktikv.MVCCLevelDB"
"mocktikv.MVCCDebugger" <|-- "mocktikv.MVCCLevelDB"
"mocktikv.MVCCStore" <|-- "mocktikv.MVCCLevelDB"
"mocktikv.RawKV" <|-- "mocktikv.MVCCLevelDB"
"executor.Closeable" <|-- "mocktikv.RPCClient"
"mocktikv.Client" <|-- "mocktikv.RPCClient"
"tikv.Client" <|-- "mocktikv.RPCClient"
"executor.Closeable" <|-- "mocktikv.analyzeColumnsExec"
"mocktikv.executor" <|-- "mocktikv.hashAggExec"
"mocktikv.executor" <|-- "mocktikv.indexScanExec"
"mocktikv.executor" <|-- "mocktikv.limitExec"
"mocktikv.executor" <|-- "mocktikv.selectionExec"
"mocktikv.executor" <|-- "mocktikv.streamAggExec"
"mocktikv.executor" <|-- "mocktikv.tableScanExec"
"mocktikv.executor" <|-- "mocktikv.topNExec"

namespace mvmap {
    class Iterator << (S,Aquamarine) >> {
        - m *MVMap
        - sliceCur int
        - entryCur int

        + Next() []byte

    }
    class MVMap << (S,Aquamarine) >> {
        - entryStore entryStore
        - dataStore dataStore
        - hashTable <font color=blue>map</font>[uint64]entryAddr
        - length int

        + Put(key []byte, value []byte) 
        + Get(key []byte, values [][]byte) [][]byte
        + Len() int
        + NewIterator() *Iterator

    }
    class dataAddr << (S,Aquamarine) >> {
        - sliceIdx uint32
        - offset uint32

    }
    class dataStore << (S,Aquamarine) >> {
        - slices [][]byte
        - sliceIdx uint32
        - sliceLen uint32

        - put(key []byte, value []byte) dataAddr
        - get(e entry, key []byte) []byte
        - getEntryData(e entry) []byte

    }
    class entry << (S,Aquamarine) >> {
        - addr dataAddr
        - keyLen uint32
        - valLen uint32
        - next entryAddr

    }
    class entryAddr << (S,Aquamarine) >> {
        - sliceIdx uint32
        - offset uint32

    }
    class entryStore << (S,Aquamarine) >> {
        - slices [][]entry
        - sliceIdx uint32
        - sliceLen uint32

        - put(e entry) entryAddr
        - get(addr entryAddr) entry

    }
}


namespace oracle {
    interface Future  {
        + Wait() (uint64, error)

    }
    interface Oracle  {
        + GetTimestamp(ctx context.Context) (uint64, error)
        + GetTimestampAsync(ctx context.Context) Future
        + GetLowResolutionTimestamp(ctx context.Context) (uint64, error)
        + GetLowResolutionTimestampAsync(ctx context.Context) Future
        + IsExpired(lockTimestamp uint64, TTL uint64) bool
        + UntilExpired(lockTimeStamp uint64, TTL uint64) int64
        + Close() 

    }
}


namespace oracles {
    class future << (S,Aquamarine) >> {
        - ctx context.Context
        - l *localOracle

        + Wait() (uint64, error)

    }
    class localOracle << (S,Aquamarine) >> {
        - lastTimeStampTS uint64
        - n uint64
        - hook *<font color=blue>struct</font>{time.Time}

        + IsExpired(lockTS uint64, TTL uint64) bool
        + GetTimestamp( context.Context) (uint64, error)
        + GetTimestampAsync(ctx context.Context) oracle.Future
        + GetLowResolutionTimestamp(ctx context.Context) (uint64, error)
        + GetLowResolutionTimestampAsync(ctx context.Context) oracle.Future
        + UntilExpired(lockTimeStamp uint64, TTL uint64) int64
        + Close() 

    }
    class lowResolutionTsFuture << (S,Aquamarine) >> {
        + Wait() (uint64, error)

    }
    class oracles.lowResolutionTsFuture << (T, #FF7700) >>  {
    }
    class pdOracle << (S,Aquamarine) >> {
        - c client.Client
        - lastTS uint64
        - quit <font color=blue>chan</font> <font color=blue>struct</font>{}

        - getTimestamp(ctx context.Context) (uint64, error)
        - setLastTS(ts uint64) 
        - updateTS(ctx context.Context, interval time.Duration) 

        + IsExpired(lockTS uint64, TTL uint64) bool
        + GetTimestamp(ctx context.Context) (uint64, error)
        + GetTimestampAsync(ctx context.Context) oracle.Future
        + UntilExpired(lockTS uint64, TTL uint64) int64
        + Close() 
        + GetLowResolutionTimestamp(ctx context.Context) (uint64, error)
        + GetLowResolutionTimestampAsync(ctx context.Context) oracle.Future

    }
    class tsFuture << (S,Aquamarine) >> {
        - o *pdOracle

        + Wait() (uint64, error)

    }
}
"sync.Mutex" *-- "oracles.localOracle"
"client.TSFuture" *-- "oracles.tsFuture"

"oracle.Future" <|-- "oracles.future"
"oracle.Oracle" <|-- "oracles.localOracle"
"oracle.Future" <|-- "oracles.lowResolutionTsFuture"
"oracle.Oracle" <|-- "oracles.pdOracle"
"oracle.Future" <|-- "oracles.tsFuture"

namespace owner {
    interface DDLOwnerChecker  {
        + IsOwner() bool

    }
    interface Manager  {
        + ID() string
        + IsOwner() bool
        + RetireOwner() 
        + GetOwnerID(ctx context.Context) (string, error)
        + CampaignOwner() error
        + ResignOwner(ctx context.Context) error
        + Cancel() 

    }
    class mockManager << (S,Aquamarine) >> {
        - owner int32
        - id string
        - cancel context.CancelFunc

        - toBeOwner() 

        + ID() string
        + IsOwner() bool
        + RetireOwner() 
        + Cancel() 
        + GetOwnerID(ctx context.Context) (string, error)
        + CampaignOwner() error
        + ResignOwner(ctx context.Context) error

    }
    class ownerManager << (S,Aquamarine) >> {
        - id string
        - key string
        - ctx context.Context
        - prompt string
        - logPrefix string
        - logCtx context.Context
        - etcdCli *clientv3.Client
        - cancel context.CancelFunc
        - elec unsafe.Pointer

        - toBeOwner(elec *concurrency.Election) 
        - campaignLoop(etcdSession *concurrency.Session) 
        - revokeSession(logPrefix string, leaseID clientv3.LeaseID) 
        - watchOwner(ctx context.Context, etcdSession *concurrency.Session, key string) 

        + ID() string
        + IsOwner() bool
        + Cancel() 
        + CampaignOwner() error
        + ResignOwner(ctx context.Context) error
        + RetireOwner() 
        + GetOwnerID(ctx context.Context) (string, error)

    }
}

"owner.DDLOwnerChecker" <|-- "owner.mockManager"
"owner.Manager" <|-- "owner.mockManager"
"util.ownerChecker" <|-- "owner.mockManager"
"owner.DDLOwnerChecker" <|-- "owner.ownerManager"
"owner.Manager" <|-- "owner.ownerManager"
"util.ownerChecker" <|-- "owner.ownerManager"

namespace parser {
    class implicitDatabase << (S,Aquamarine) >> {
        - hasImplicit bool

        + Enter(in types.Node) (types.Node, bool)
        + Leave(in types.Node) (types.Node, bool)

    }
}


namespace perfschema {
    class perfSchemaTable << (S,Aquamarine) >> {
        - meta *model.TableInfo
        - cols []*table.Column
        - tp table.Type

        - getRows(ctx sessionctx.Context, cols []*table.Column) ([][]types.Datum, error)

        + Cols() []*table.Column
        + VisibleCols() []*table.Column
        + HiddenCols() []*table.Column
        + WritableCols() []*table.Column
        + DeletableCols() []*table.Column
        + GetPhysicalID() int64
        + Meta() *model.TableInfo
        + Type() table.Type
        + IterRecords(ctx sessionctx.Context, startKey kv.Key, cols []*table.Column, fn table.RecordIterFunc) error

    }
}
"infoschema.VirtualTable" *-- "perfschema.perfSchemaTable"

"table.PhysicalTable" <|-- "perfschema.perfSchemaTable"

namespace plancodec {
    class planDecoder << (S,Aquamarine) >> {
        - buf bytes.Buffer
        - depths []int
        - indents [][]rune
        - planInfos []*planInfo

        - decode(planString string) (string, error)
        - buildPlanTree(planString string) (string, error)
        - initPlanTreeIndents() 
        - findParentIndex(childIndex int) int
        - fillIndent(parentIndex int, childIndex int) 
        - alignFields(planInfos []*planInfo) 
        - getMaxFieldLength(idx int, planInfos []*planInfo) int
        - getPlanFieldLen(rowIdx int, colIdx int, p *planInfo) int

    }
    class planInfo << (S,Aquamarine) >> {
        - depth int
        - fields []string

    }
}


namespace plugin {
    class AuditManifest << (S,Aquamarine) >> {
        + OnConnectionEvent <font color=blue>func</font>(context.Context, ConnectionEvent, *variable.ConnectionInfo) error
        + OnGeneralEvent <font color=blue>func</font>(context.Context, *variable.SessionVars, GeneralEvent, string) 
        + OnGlobalVariableEvent <font color=blue>func</font>(context.Context, *variable.SessionVars, string, string) 
        + OnParseEvent <font color=blue>func</font>(context.Context, *variable.SessionVars, ParseEvent) error

    }
    class AuthenticationManifest << (S,Aquamarine) >> {
        + AuthenticateUser <font color=blue>func</font>() 
        + GenerateAuthenticationString <font color=blue>func</font>() 
        + ValidateAuthenticationString <font color=blue>func</font>() 
        + SetSalt <font color=blue>func</font>() 

    }
    class Config << (S,Aquamarine) >> {
        + Plugins []string
        + PluginDir string
        + GlobalSysVar *<font color=blue>map</font>[string]*variable.SysVar
        + PluginVarNames *[]string
        + SkipWhenFail bool
        + EnvVersion <font color=blue>map</font>[string]uint16
        + EtcdClient *clientv3.Client

    }
    class ConnectionEvent << (S,Aquamarine) >> {
        + String() string

    }
    class DaemonManifest << (S,Aquamarine) >> {
    }
    class ID << (S,Aquamarine) >> {
        + Decode() (string, string, error)

    }
    class Kind << (S,Aquamarine) >> {
        + String() string

    }
    class Manifest << (S,Aquamarine) >> {
        - flushWatcher *flushWatcher

        + Name string
        + Description string
        + RequireVersion <font color=blue>map</font>[string]uint16
        + License string
        + BuildTime string
        + SysVars <font color=blue>map</font>[string]*variable.SysVar
        + Validate <font color=blue>func</font>(context.Context, *Manifest) error
        + OnInit <font color=blue>func</font>(context.Context, *Manifest) error
        + OnShutdown <font color=blue>func</font>(context.Context, *Manifest) error
        + OnFlush <font color=blue>func</font>(context.Context, *Manifest) error
        + Version uint16
        + Kind Kind

    }
    class Plugin << (S,Aquamarine) >> {
        - library *"plugin.Plugin

        + Path string
        + Disabled uint32
        + State State

        - validate(ctx context.Context, tiPlugins *plugins) error

        + StateValue() string
        + DisableFlag(disable bool) 

    }
    class RejectReasonCtxValue << (S,Aquamarine) >> {
    }
    class SchemaManifest << (S,Aquamarine) >> {
    }
    class State << (S,Aquamarine) >> {
        + String() string

    }
    class copyOnWriteContext << (S,Aquamarine) >> {
        - tiPlugins unsafe.Pointer

        - plugins() *plugins

    }
    class execStartTimeCtxKeyType << (S,Aquamarine) >> {
    }
    class flushWatcher << (S,Aquamarine) >> {
        - ctx context.Context
        - cancel context.CancelFunc
        - path string
        - etcd *clientv3.Client
        - manifest *Manifest
        - plugin *Plugin

        - watchLoop() 
        - getPluginDisabledFlag() (bool, error)

    }
    class plugin.ConnectionEvent << (T, #FF7700) >>  {
    }
    class plugin.GeneralEvent << (T, #FF7700) >>  {
    }
    class plugin.ID << (T, #FF7700) >>  {
    }
    class plugin.Kind << (T, #FF7700) >>  {
    }
    class plugin.ParseEvent << (T, #FF7700) >>  {
    }
    class plugin.State << (T, #FF7700) >>  {
    }
    class plugin.loadFn << (T, #FF7700) >>  {
    }
    class plugins << (S,Aquamarine) >> {
        - plugins <font color=blue>map</font>[Kind][]Plugin
        - versions <font color=blue>map</font>[string]uint16
        - dyingPlugins []Plugin

        - clone() *plugins
        - add(plugin *Plugin) 

    }
}
"plugin.Manifest" *-- "plugin.AuditManifest"
"plugin.Manifest" *-- "plugin.AuthenticationManifest"
"plugin.Manifest" *-- "plugin.DaemonManifest"
"plugin.Manifest" *-- "plugin.Plugin"
"plugin.Manifest" *-- "plugin.SchemaManifest"


namespace privilege {
    interface Manager  {
        + ShowGrants(ctx sessionctx.Context, user *auth.UserIdentity, roles []*auth.RoleIdentity) ([]string, error)
        + GetEncodedPassword(user string, host string) string
        + RequestVerification(activeRole []*auth.RoleIdentity, db string, table string, column string, priv errno.PrivilegeType) bool
        + RequestVerificationWithUser(db string, table string, column string, priv errno.PrivilegeType, user *auth.UserIdentity) bool
        + ConnectionVerification(user string, host string, auth []byte, salt []byte, tlsState *tls.ConnectionState) (string, string, bool)
        + GetAuthWithoutVerification(user string, host string) (string, string, bool)
        + DBIsVisible(activeRole []*auth.RoleIdentity, db string) bool
        + UserPrivilegesTable() [][]types.Datum
        + ActiveRoles(ctx sessionctx.Context, roleList []*auth.RoleIdentity) (bool, string)
        + FindEdge(ctx sessionctx.Context, role *auth.RoleIdentity, user *auth.UserIdentity) bool
        + GetDefaultRoles(user string, host string) []*auth.RoleIdentity
        + GetAllRoles(user string, host string) []*auth.RoleIdentity

    }
    class keyType << (S,Aquamarine) >> {
        + String() string

    }
    class privilege.keyType << (T, #FF7700) >>  {
    }
}


namespace privileges {
    class GlobalPrivValue << (S,Aquamarine) >> {
        + SSLType SSLType
        + SSLCipher string
        + X509Issuer string
        + X509Subject string
        + SAN string
        + SANs <font color=blue>map</font>[util.SANType][]string

        + RequireStr() string

    }
    class Handle << (S,Aquamarine) >> {
        - priv atomic.Value

        + Get() *MySQLPrivilege
        + Update(ctx sessionctx.Context) error

    }
    class MySQLPrivilege << (S,Aquamarine) >> {
        + User []UserRecord
        + UserMap <font color=blue>map</font>[string][]UserRecord
        + Global <font color=blue>map</font>[string][]globalPrivRecord
        + DB []dbRecord
        + DBMap <font color=blue>map</font>[string][]dbRecord
        + TablesPriv []tablesPrivRecord
        + TablesPrivMap <font color=blue>map</font>[string][]tablesPrivRecord
        + ColumnsPriv []columnsPrivRecord
        + DefaultRoles []defaultRoleRecord
        + RoleGraph <font color=blue>map</font>[string]roleGraphEdgesTable

        - buildUserMap() 
        - buildDBMap() 
        - buildTablesPrivMap() 
        - loadTable(sctx sessionctx.Context, sql string, decodeTableRow <font color=blue>func</font>(chunk.Row, []*ast.ResultField) error) error
        - decodeUserTableRow(row chunk.Row, fs []*ast.ResultField) error
        - decodeGlobalPrivTableRow(row chunk.Row, fs []*ast.ResultField) error
        - decodeDBTableRow(row chunk.Row, fs []*ast.ResultField) error
        - decodeTablesPrivTableRow(row chunk.Row, fs []*ast.ResultField) error
        - decodeRoleEdgesTable(row chunk.Row, fs []*ast.ResultField) error
        - decodeDefaultRoleTableRow(row chunk.Row, fs []*ast.ResultField) error
        - decodeColumnsPrivTableRow(row chunk.Row, fs []*ast.ResultField) error
        - connectionVerification(user string, host string) *UserRecord
        - matchGlobalPriv(user string, host string) *globalPrivRecord
        - matchUser(user string, host string) *UserRecord
        - matchDB(user string, host string, db string) *dbRecord
        - matchTables(user string, host string, db string, table string) *tablesPrivRecord
        - matchColumns(user string, host string, db string, table string, column string) *columnsPrivRecord
        - showGrants(user string, host string, roles []*auth.RoleIdentity) []string
        - getDefaultRoles(user string, host string) []*auth.RoleIdentity
        - getAllRoles(user string, host string) []*auth.RoleIdentity

        + FindAllRole(activeRoles []*auth.RoleIdentity) []*auth.RoleIdentity
        + FindRole(user string, host string, role *auth.RoleIdentity) bool
        + LoadAll(ctx sessionctx.Context) error
        + LoadRoleGraph(ctx sessionctx.Context) error
        + LoadUserTable(ctx sessionctx.Context) error
        + SortUserTable() 
        + LoadGlobalPrivTable(ctx sessionctx.Context) error
        + LoadDBTable(ctx sessionctx.Context) error
        + LoadTablesPrivTable(ctx sessionctx.Context) error
        + LoadColumnsPrivTable(ctx sessionctx.Context) error
        + LoadDefaultRoles(ctx sessionctx.Context) error
        + RequestVerification(activeRoles []*auth.RoleIdentity, user string, host string, db string, table string, column string, priv errno.PrivilegeType) bool
        + DBIsVisible(user string, host string, db string) bool
        + UserPrivilegesTable() [][]types.Datum

    }
    class UserPrivileges << (S,Aquamarine) >> {
        - user string
        - host string

        - checkSSL(priv *globalPrivRecord, tlsState *tls.ConnectionState) bool

        + RequestVerification(activeRoles []*auth.RoleIdentity, db string, table string, column string, priv errno.PrivilegeType) bool
        + RequestVerificationWithUser(db string, table string, column string, priv errno.PrivilegeType, user *auth.UserIdentity) bool
        + GetEncodedPassword(user string, host string) string
        + GetAuthWithoutVerification(user string, host string) (string, string, bool)
        + ConnectionVerification(user string, host string, authentication []byte, salt []byte, tlsState *tls.ConnectionState) (string, string, bool)
        + DBIsVisible(activeRoles []*auth.RoleIdentity, db string) bool
        + UserPrivilegesTable() [][]types.Datum
        + ShowGrants(ctx sessionctx.Context, user *auth.UserIdentity, roles []*auth.RoleIdentity) ([]string, error)
        + ActiveRoles(ctx sessionctx.Context, roleList []*auth.RoleIdentity) (bool, string)
        + FindEdge(ctx sessionctx.Context, role *auth.RoleIdentity, user *auth.UserIdentity) bool
        + GetDefaultRoles(user string, host string) []*auth.RoleIdentity
        + GetAllRoles(user string, host string) []*auth.RoleIdentity

    }
    class UserRecord << (S,Aquamarine) >> {
        + AuthenticationString string
        + Privileges errno.PrivilegeType
        + AccountLocked bool

    }
    class baseRecord << (S,Aquamarine) >> {
        - patChars []byte
        - patTypes []byte
        - hostIPNet *net.IPNet

        + Host string
        + User string

        - assignUserOrHost(row chunk.Row, i int, f *ast.ResultField) 
        - hostMatch(s string) bool
        - match(user string, host string) bool

    }
    class columnsPrivRecord << (S,Aquamarine) >> {
        + DB string
        + TableName string
        + ColumnName string
        + Timestamp time.Time
        + ColumnPriv errno.PrivilegeType

        - match(user string, host string, db string, table string, col string) bool

    }
    class dbRecord << (S,Aquamarine) >> {
        - dbPatChars []byte
        - dbPatTypes []byte

        + DB string
        + Privileges errno.PrivilegeType

        - match(user string, host string, db string) bool

    }
    class defaultRoleRecord << (S,Aquamarine) >> {
        + DefaultRoleUser string
        + DefaultRoleHost string

    }
    class globalPrivRecord << (S,Aquamarine) >> {
        + Priv GlobalPrivValue
        + Broken bool

    }
    class privileges.SSLType << (T, #FF7700) >>  {
    }
    class privileges.checkResult << (T, #FF7700) >>  {
    }
    class privileges.sortedUserRecord << (T, #FF7700) >>  {
    }
    class roleGraphEdgesTable << (S,Aquamarine) >> {
        - roleList <font color=blue>map</font>[string]*auth.RoleIdentity

        + Find(user string, host string) bool

    }
    class sortedUserRecord << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class tablesPrivRecord << (S,Aquamarine) >> {
        + DB string
        + TableName string
        + Grantor string
        + Timestamp time.Time
        + TablePriv errno.PrivilegeType
        + ColumnPriv errno.PrivilegeType

        - match(user string, host string, db string, table string) bool

    }
}
"privileges.Handle" *-- "privileges.UserPrivileges"
"privileges.baseRecord" *-- "privileges.UserRecord"
"privileges.baseRecord" *-- "privileges.columnsPrivRecord"
"privileges.baseRecord" *-- "privileges.dbRecord"
"privileges.baseRecord" *-- "privileges.defaultRoleRecord"
"privileges.baseRecord" *-- "privileges.globalPrivRecord"
"privileges.baseRecord" *-- "privileges.tablesPrivRecord"

"privilege.Manager" <|-- "privileges.UserPrivileges"

namespace profile {
    class Collector << (S,Aquamarine) >> {
        - profileToDatums(p *profile.Profile) ([][]types.Datum, error)
        - cpuProfileGraph() ([][]types.Datum, error)

        + ProfileReaderToDatums(f io.Reader) ([][]types.Datum, error)
        + ProfileGraph(name string) ([][]types.Datum, error)
        + ParseGoroutines(reader io.Reader) ([][]types.Datum, error)

    }
    class flamegraphCollector << (S,Aquamarine) >> {
        - rows [][]types.Datum
        - locations <font color=blue>map</font>[uint64]*profile.Location
        - total int64
        - rootChild int

        - locationName(locID uint64) string
        - collectChild(node flamegraphNodeWithLocation, depth int64, indent string, parentCumValue int64, isLastChild bool) 
        - collect(root *flamegraphNode) 

    }
    class flamegraphNode << (S,Aquamarine) >> {
        - cumValue int64
        - children <font color=blue>map</font>[uint64]*flamegraphNode

        - add(sample *profile.Sample) 
        - sortedChildren() []flamegraphNodeWithLocation

    }
    class flamegraphNodeWithLocation << (S,Aquamarine) >> {
        - locID uint64

    }
}
"profile.flamegraphNode" *-- "profile.flamegraphNodeWithLocation"


namespace property {
    class Item << (S,Aquamarine) >> {
        + Col *expression.Column
        + Desc bool

    }
    class LogicalProperty << (S,Aquamarine) >> {
        + Stats *StatsInfo
        + Schema *expression.Schema
        + MaxOneRow bool

    }
    class PhysicalProperty << (S,Aquamarine) >> {
        - hashcode []byte

        + Items []Item
        + TaskTp TaskType
        + ExpectedCnt float64
        + Enforced bool

        + AllColsFromSchema(schema *expression.Schema) bool
        + IsPrefix(prop *PhysicalProperty) bool
        + IsEmpty() bool
        + HashCode() []byte
        + String() string
        + Clone() *PhysicalProperty
        + AllSameOrder() (bool, bool)

    }
    class StatsInfo << (S,Aquamarine) >> {
        + RowCount float64
        + Cardinality <font color=blue>map</font>[int64]float64
        + HistColl *statistics.HistColl
        + StatsVersion uint64

        + String() string
        + Count() int64
        + Scale(factor float64) *StatsInfo
        + ScaleByExpectCnt(expectCnt float64) *StatsInfo

    }
    class TaskType << (S,Aquamarine) >> {
        + String() string

    }
    class property.TaskType << (T, #FF7700) >>  {
    }
}


namespace ranger {
    class DetachRangeResult << (S,Aquamarine) >> {
        + Ranges []*Range
        + AccessConds []expression.Expression
        + RemainedConds []expression.Expression
        + EqCondCount int
        + EqOrInCount int
        + IsDNFCond bool

    }
    class Range << (S,Aquamarine) >> {
        + LowVal []types.Datum
        + HighVal []types.Datum
        + LowExclude bool
        + HighExclude bool

        + Clone() *Range
        + IsPoint(sc *stmtctx.StatementContext) bool
        + IsFullRange() bool
        + String() string
        + Encode(sc *stmtctx.StatementContext, lowBuffer []byte, highBuffer []byte) ([]byte, []byte, error)
        + PrefixEqualLen(sc *stmtctx.StatementContext) (int, error)

    }
    class builder << (S,Aquamarine) >> {
        - err error
        - sc *stmtctx.StatementContext
        - ctx *sessionctx.Context

        - build(expr expression.Expression) []point
        - buildFromConstant(expr *expression.Constant) []point
        - buildFromColumn(expr *expression.Column) []point
        - buildFormBinOp(expr *expression.ScalarFunction) []point
        - buildFromIsTrue(expr *expression.ScalarFunction, isNot int) []point
        - buildFromIsFalse(expr *expression.ScalarFunction, isNot int) []point
        - buildFromIn(expr *expression.ScalarFunction) ([]point, bool)
        - newBuildFromPatternLike(expr *expression.ScalarFunction) []point
        - buildFromNot(expr *expression.ScalarFunction) []point
        - buildFromScalarFunc(expr *expression.ScalarFunction) []point
        - intersection(a []point, b []point) []point
        - union(a []point, b []point) []point
        - mergeSorted(a []point, b []point) []point
        - merge(a []point, b []point, union bool) []point

    }
    class conditionChecker << (S,Aquamarine) >> {
        - colUniqueID int64
        - shouldReserve bool
        - length int

        - check(condition expression.Expression) bool
        - checkScalarFunction(scalar *expression.ScalarFunction) bool
        - checkLikeFunc(scalar *expression.ScalarFunction) bool
        - checkColumn(expr expression.Expression) bool

    }
    class point << (S,Aquamarine) >> {
        - value types.Datum
        - excl bool
        - start bool

        + String() string

    }
    class pointSorter << (S,Aquamarine) >> {
        - points []point
        - err error
        - sc *stmtctx.StatementContext

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class ranger.RangeType << (T, #FF7700) >>  {
    }
    class sortRange << (S,Aquamarine) >> {
        - originalValue *Range
        - encodedStart []byte
        - encodedEnd []byte

    }
}


namespace rowcodec {
    class BytesDecoder << (S,Aquamarine) >> {
        - defBytes <font color=blue>func</font>(int) ([]byte, error)

        - decodeToBytesInternal(outputOffset <font color=blue>map</font>[int64]int, handle int64, value []byte, cacheBytes []byte, useHandle bool) ([][]byte, error)
        - encodeOldDatum(tp byte, val []byte) []byte

        + DecodeToBytesNoHandle(outputOffset <font color=blue>map</font>[int64]int, value []byte) ([][]byte, error)
        + DecodeToBytes(outputOffset <font color=blue>map</font>[int64]int, handle int64, value []byte, cacheBytes []byte) ([][]byte, error)

    }
    class ChunkDecoder << (S,Aquamarine) >> {
        - defDatum <font color=blue>func</font>(int, *chunk.Chunk) error

        - decodeColToChunk(colIdx int, col *ColInfo, colData []byte, chk *chunk.Chunk) error

        + DecodeToChunk(rowData []byte, handle int64, chk *chunk.Chunk) error

    }
    class ColInfo << (S,Aquamarine) >> {
        + ID int64
        + Tp int32
        + Flag int32
        + IsPKHandle bool
        + Flen int
        + Decimal int
        + Elems []string
        + Collate string
        + VirtualGenCol bool

    }
    class DatumMapDecoder << (S,Aquamarine) >> {
        - decodeColDatum(col *ColInfo, colData []byte) (types.Datum, error)

        + DecodeToDatumMap(rowData []byte, handle int64, row <font color=blue>map</font>[int64]types.Datum) (<font color=blue>map</font>[int64]types.Datum, error)

    }
    class Encoder << (S,Aquamarine) >> {
        - tempColIDs []int64
        - values []types.Datum

        + Enable bool

        - reset() 
        - appendColVals(colIDs []int64, values []types.Datum) 
        - appendColVal(colID int64, d types.Datum) 
        - reformatCols() int
        - encodeRowCols(sc *stmtctx.StatementContext, numCols int, notNullIdx int) error

        + Encode(sc *stmtctx.StatementContext, colIDs []int64, values []types.Datum, buf []byte) ([]byte, error)

    }
    class decoder << (S,Aquamarine) >> {
        - columns []ColInfo
        - handleColID int64
        - loc *time.Location

    }
    class largeNotNullSorter << (S,Aquamarine) >> {
        + Less(i int, j int) bool
        + Len() int
        + Swap(i int, j int) 

    }
    class largeNullSorter << (S,Aquamarine) >> {
        + Less(i int, j int) bool
        + Len() int
        + Swap(i int, j int) 

    }
    class row << (S,Aquamarine) >> {
        - large bool
        - numNotNullCols uint16
        - numNullCols uint16
        - colIDs []byte
        - offsets []uint16
        - data []byte
        - colIDs32 []uint32
        - offsets32 []uint32

        - getData(i int) []byte
        - fromBytes(rowData []byte) error
        - toBytes(buf []byte) []byte
        - findColID(colID int64) (int, bool)
        - initColIDs() 
        - initColIDs32() 
        - initOffsets() 
        - initOffsets32() 

        + ColumnIsNull(rowData []byte, colID int64, defaultVal []byte) (bool, error)

    }
    class rowcodec.largeNotNullSorter << (T, #FF7700) >>  {
    }
    class rowcodec.largeNullSorter << (T, #FF7700) >>  {
    }
    class rowcodec.smallNotNullSorter << (T, #FF7700) >>  {
    }
    class rowcodec.smallNullSorter << (T, #FF7700) >>  {
    }
    class smallNotNullSorter << (S,Aquamarine) >> {
        + Less(i int, j int) bool
        + Len() int
        + Swap(i int, j int) 

    }
    class smallNullSorter << (S,Aquamarine) >> {
        + Less(i int, j int) bool
        + Len() int
        + Swap(i int, j int) 

    }
}
"rowcodec.decoder" *-- "rowcodec.BytesDecoder"
"rowcodec.decoder" *-- "rowcodec.ChunkDecoder"
"rowcodec.decoder" *-- "rowcodec.DatumMapDecoder"
"rowcodec.row" *-- "rowcodec.Encoder"
"rowcodec.row" *-- "rowcodec.decoder"


namespace server {
    class ColumnInfo << (S,Aquamarine) >> {
        + Schema string
        + Table string
        + OrgTable string
        + Name string
        + OrgName string
        + ColumnLength uint32
        + Charset uint16
        + Flag uint16
        + Decimal uint8
        + Type uint8
        + DefaultValueLength uint64
        + DefaultValue []byte

        + Dump(buffer []byte) []byte

    }
    class CorsHandler << (S,Aquamarine) >> {
        - handler http.Handler
        - cfg *config.Config

        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class FrameItem << (S,Aquamarine) >> {
        + DBName string
        + TableName string
        + TableID int64
        + IsRecord bool
        + RecordID int64
        + IndexName string
        + IndexID int64
        + IndexValues []string

    }
    interface IDriver  {
        + OpenCtx(connID uint64, capability uint32, collation uint8, dbname string, tlsState *tls.ConnectionState) (QueryCtx, error)

    }
    class IndexRegions << (S,Aquamarine) >> {
        + Name string
        + ID int64
        + Regions []RegionMeta

    }
    interface PreparedStatement  {
        + ID() int
        + Execute( context.Context,  []types.Datum) (ResultSet, error)
        + AppendParam(paramID int, data []byte) error
        + NumParams() int
        + BoundParams() [][]byte
        + SetParamsType( []byte) 
        + GetParamsType() []byte
        + StoreResultSet(rs ResultSet) 
        + GetResultSet() ResultSet
        + Reset() 
        + Close() error

    }
    interface QueryCtx  {
        + Status() uint16
        + LastInsertID() uint64
        + LastMessage() string
        + AffectedRows() uint64
        + Value(key fmt.Stringer) <font color=blue>interface</font>{}
        + SetValue(key fmt.Stringer, value <font color=blue>interface</font>{}) 
        + SetProcessInfo(sql string, t time.Time, command byte, maxExecutionTime uint64) 
        + CommitTxn(ctx context.Context) error
        + RollbackTxn() 
        + WarningCount() uint16
        + CurrentDB() string
        + Execute(ctx context.Context, sql string) ([]ResultSet, error)
        + ExecuteInternal(ctx context.Context, sql string) ([]ResultSet, error)
        + SetClientCapability( uint32) 
        + Prepare(sql string) (PreparedStatement, []*ColumnInfo, error)
        + GetStatement(stmtID int) PreparedStatement
        + FieldList(tableName string) ([]*ColumnInfo, error)
        + Close() error
        + Auth(user *auth.UserIdentity, auth []byte, salt []byte) bool
        + ShowProcess() *util.ProcessInfo
        + GetSessionVars() *variable.SessionVars
        + SetCommandValue(command byte) 
        + SetSessionManager( util.SessionManager) 

    }
    class RegionDetail << (S,Aquamarine) >> {
        + RegionID uint64
        + StartKey []byte
        + EndKey []byte
        + Frames []*helper.FrameItem

        - addTableInRange(dbName string, curTable *model.TableInfo, r *helper.RegionFrameRange) 

    }
    class RegionFrameRange << (S,Aquamarine) >> {
        - first *FrameItem
        - last *FrameItem
        - region *tikv.KeyLocation

    }
    class RegionMeta << (S,Aquamarine) >> {
        + ID uint64
        + Leader *metapb.Peer
        + Peers []*metapb.Peer
        + RegionEpoch *metapb.RegionEpoch

    }
    interface ResultSet  {
        + Columns() []*ColumnInfo
        + NewChunk() *chunk.Chunk
        + Next( context.Context,  *chunk.Chunk) error
        + StoreFetchedRows(rows []chunk.Row) 
        + GetFetchedRows() []chunk.Row
        + Close() error

    }
    class Server << (S,Aquamarine) >> {
        - cfg *config.Config
        - tlsConfig unsafe.Pointer
        - driver IDriver
        - listener net.Listener
        - socket net.Listener
        - rwlock sync.RWMutex
        - concurrentLimiter *TokenLimiter
        - clients <font color=blue>map</font>[uint32]*clientConn
        - capability uint32
        - dom *domain.Domain
        - statusAddr string
        - statusListener net.Listener
        - statusServer *http.Server
        - grpcServer *grpc.Server

        - newStatsHandler() *StatsHandler
        - newStatsHistoryHandler() *StatsHistoryHandler
        - startStatusHTTP() 
        - listenStatusHTTPServer() error
        - startHTTPServer() 
        - startStatusServerAndRPCServer(serverMux *http.ServeMux) 
        - setCNChecker(tlsConfig *tls.Config) *tls.Config
        - handleStatus(w http.ResponseWriter, req *http.Request) 
        - newTikvHandlerTool() *tikvHandlerTool
        - getToken() *Token
        - releaseToken(token *Token) 
        - newConn(conn net.Conn) *clientConn
        - isUnixSocket() bool
        - forwardUnixSocketToTCP() 
        - handleForwardedConnection(uconn net.Conn, addr string) 
        - onConn(conn *clientConn) 
        - checkConnectionCount() error
        - getTLSConfig() *tls.Config
        - kickIdleConnection() 

        + ConnectionCount() int
        + SetDomain(dom *domain.Domain) 
        + Run() error
        + Close() 
        + ShowProcessList() <font color=blue>map</font>[uint64]*util.ProcessInfo
        + GetProcessInfo(id uint64) (*util.ProcessInfo, bool)
        + Kill(connectionID uint64, query bool) 
        + UpdateTLSConfig(cfg *tls.Config) 
        + KillAllConnections() 
        + TryGracefulDown() 
        + GracefulDown(ctx context.Context, done <font color=blue>chan</font> <font color=blue>struct</font>{}) 

    }
    class StatsHandler << (S,Aquamarine) >> {
        - do *domain.Domain

        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class StatsHistoryHandler << (S,Aquamarine) >> {
        - do *domain.Domain

        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class TableRegions << (S,Aquamarine) >> {
        + TableName string
        + TableID int64
        + RecordRegions []RegionMeta
        + Indices []IndexRegions

    }
    class TiDBContext << (S,Aquamarine) >> {
        - session session.Session
        - currentDB string
        - stmts <font color=blue>map</font>[int]*TiDBStatement

        + Status() uint16
        + LastInsertID() uint64
        + Value(key fmt.Stringer) <font color=blue>interface</font>{}
        + SetValue(key fmt.Stringer, value <font color=blue>interface</font>{}) 
        + CommitTxn(ctx context.Context) error
        + SetProcessInfo(sql string, t time.Time, command byte, maxExecutionTime uint64) 
        + RollbackTxn() 
        + AffectedRows() uint64
        + LastMessage() string
        + CurrentDB() string
        + WarningCount() uint16
        + Execute(ctx context.Context, sql string) ([]ResultSet, error)
        + ExecuteInternal(ctx context.Context, sql string) ([]ResultSet, error)
        + SetSessionManager(sm util.SessionManager) 
        + SetClientCapability(flags uint32) 
        + Close() error
        + Auth(user *auth.UserIdentity, auth []byte, salt []byte) bool
        + FieldList(table string) ([]*ColumnInfo, error)
        + GetStatement(stmtID int) PreparedStatement
        + Prepare(sql string) (PreparedStatement, []*ColumnInfo, error)
        + ShowProcess() *util.ProcessInfo
        + SetCommandValue(command byte) 
        + GetSessionVars() *variable.SessionVars

    }
    class TiDBDriver << (S,Aquamarine) >> {
        - store kv.Storage

        + OpenCtx(connID uint64, capability uint32, collation uint8, dbname string, tlsState *tls.ConnectionState) (QueryCtx, error)

    }
    class TiDBStatement << (S,Aquamarine) >> {
        - id uint32
        - numParams int
        - boundParams [][]byte
        - paramsType []byte
        - ctx *TiDBContext
        - rs ResultSet
        - sql string

        + ID() int
        + Execute(ctx context.Context, args []types.Datum) (ResultSet, error)
        + AppendParam(paramID int, data []byte) error
        + NumParams() int
        + BoundParams() [][]byte
        + SetParamsType(paramsType []byte) 
        + GetParamsType() []byte
        + StoreResultSet(rs ResultSet) 
        + GetResultSet() ResultSet
        + Reset() 
        + Close() error

    }
    class Token << (S,Aquamarine) >> {
    }
    class TokenLimiter << (S,Aquamarine) >> {
        - count uint
        - ch <font color=blue>chan</font> *Token

        + Put(tk *Token) 
        + Get() *Token

    }
    class allServerInfoHandler << (S,Aquamarine) >> {
        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class binlogRecover << (S,Aquamarine) >> {
        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class bufferedReadConn << (S,Aquamarine) >> {
        - rb *bufio.Reader

        + Read(b []byte) (int, error)

    }
    class clientConn << (S,Aquamarine) >> {
        - pkt *packetIO
        - bufReadConn *bufferedReadConn
        - tlsConn *tls.Conn
        - server *Server
        - capability uint32
        - connectionID uint32
        - user string
        - dbname string
        - salt []byte
        - alloc arena.Allocator
        - lastPacket []byte
        - ctx QueryCtx
        - attrs <font color=blue>map</font>[string]string
        - peerHost string
        - peerPort string
        - status int32
        - lastCode uint16
        - collation uint8

        - handshake(ctx context.Context) error
        - closeWithoutLock() error
        - writeInitialHandshake() error
        - readPacket() ([]byte, error)
        - writePacket(data []byte) error
        - getSessionVarsWaitTimeout(ctx context.Context) uint64
        - readOptionalSSLRequestAndHandshakeResponse(ctx context.Context) error
        - openSessionAndDoAuth(authData []byte) error
        - addMetrics(cmd byte, startTime time.Time, err error) 
        - dispatch(ctx context.Context, data []byte) error
        - useDB(ctx context.Context, db string) error
        - flush() error
        - writeOK() error
        - writeOkWith(msg string, affectedRows uint64, lastInsertID uint64, status uint16, warnCnt uint16) error
        - writeError(e error) error
        - writeEOF(serverStatus uint16) error
        - writeReq(filePath string) error
        - handleLoadData(ctx context.Context, loadDataInfo *executor.LoadDataInfo) error
        - getDataFromPath(path string) ([]byte, error)
        - handleLoadStats(ctx context.Context, loadStatsInfo *executor.LoadStatsInfo) error
        - handleIndexAdvise(ctx context.Context, indexAdviseInfo *executor.IndexAdviseInfo) error
        - handleQuery(ctx context.Context, sql string) error
        - handleFieldList(sql string) error
        - writeResultset(ctx context.Context, rs ResultSet, binary bool, serverStatus uint16, fetchSize int) error
        - writeColumnInfo(columns []*ColumnInfo, serverStatus uint16) error
        - writeChunks(ctx context.Context, rs ResultSet, binary bool, serverStatus uint16) error
        - writeChunksWithFetchSize(ctx context.Context, rs ResultSet, serverStatus uint16, fetchSize int) error
        - writeMultiResultset(ctx context.Context, rss []ResultSet, binary bool) error
        - setConn(conn net.Conn) 
        - upgradeToTLS(tlsConfig *tls.Config) error
        - handleChangeUser(ctx context.Context, data []byte) error
        - handleStmtPrepare(sql string) error
        - handleStmtExecute(ctx context.Context, data []byte) error
        - handleStmtFetch(ctx context.Context, data []byte) error
        - handleStmtClose(data []byte) error
        - handleStmtSendLongData(data []byte) error
        - handleStmtReset(data []byte) error
        - handleSetOption(data []byte) error
        - preparedStmt2String(stmtID uint32) string
        - preparedStmt2StringNoArgs(stmtID uint32) string
        - connectInfo() *variable.ConnectionInfo

        + String() string
        + Close() error
        + SessionStatusToString() string
        + PeerHost(hasPassword string) (string, error)
        + Run(ctx context.Context) 
        + ShutdownOrNotify() bool

    }
    class clusterServerInfo << (S,Aquamarine) >> {
        + ServersNum int
        + OwnerID string
        + IsAllServerVersionConsistent bool
        + AllServersDiffVersions []infosync.ServerVersionInfo
        + AllServersInfo <font color=blue>map</font>[string]*infosync.ServerInfo

    }
    class dbTableHandler << (S,Aquamarine) >> {
        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class dbTableInfo << (S,Aquamarine) >> {
        + DBInfo *model.DBInfo
        + TableInfo *model.TableInfo
        + SchemaVersion int64

    }
    class ddlHistoryJobHandler << (S,Aquamarine) >> {
        - getAllHistoryDDL() ([]*model.Job, error)

        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class ddlResignOwnerHandler << (S,Aquamarine) >> {
        - store kv.Storage

        - resignDDLOwner() error

        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class explainAnalyzeResult << (S,Aquamarine) >> {
        - rows [][]string
        - err error

    }
    interface fetchNotifier  {
        + OnFetchReturned() 

    }
    class flashReplicaHandler << (S,Aquamarine) >> {
        - getTiFlashReplicaInfo(tblInfo *model.TableInfo, replicaInfos []*tableFlashReplicaInfo) []*tableFlashReplicaInfo
        - getDropOrTruncateTableTiflash(currentSchema infoschema.InfoSchema) ([]*tableFlashReplicaInfo, error)
        - handleStatusReport(w http.ResponseWriter, req *http.Request) 

        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class getLastStmtInConn << (S,Aquamarine) >> {
        + String() string
        + PProfLabel() string

    }
    class handshakeResponse41 << (S,Aquamarine) >> {
        + Capability uint32
        + Collation uint8
        + User string
        + DBName string
        + Auth []byte
        + Attrs <font color=blue>map</font>[string]string

    }
    class hotRegion << (S,Aquamarine) >> {
    }
    class hotRegions << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class mvccKV << (S,Aquamarine) >> {
        + Key string
        + RegionID uint64
        + Value *kvrpcpb.MvccGetByKeyResponse

    }
    class mvccTxnHandler << (S,Aquamarine) >> {
        - op string

        - handleMvccGetByIdx(params <font color=blue>map</font>[string]string, values url.Values) (<font color=blue>interface</font>{}, error)
        - handleMvccGetByKey(params <font color=blue>map</font>[string]string, decodeData bool) (<font color=blue>interface</font>{}, error)
        - decodeMvccData(bs []byte, colMap <font color=blue>map</font>[int64]*types.FieldType, tb *model.TableInfo) ([]<font color=blue>map</font>[string]string, error)
        - handleMvccGetByTxn(params <font color=blue>map</font>[string]string) (<font color=blue>interface</font>{}, error)

        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class packetIO << (S,Aquamarine) >> {
        - bufReadConn *bufferedReadConn
        - bufWriter *bufio.Writer
        - sequence uint8
        - readTimeout time.Duration

        - setBufferedReadConn(bufReadConn *bufferedReadConn) 
        - setReadTimeout(timeout time.Duration) 
        - readOnePacket() ([]byte, error)
        - readPacket() ([]byte, error)
        - writePacket(data []byte) error
        - flush() error

    }
    class pdRegionStats << (S,Aquamarine) >> {
        + Count int
        + EmptyCount int
        + StorageSize int64
        + StoreLeaderCount <font color=blue>map</font>[uint64]int
        + StorePeerCount <font color=blue>map</font>[uint64]int
        + StoreLeaderSize <font color=blue>map</font>[uint64]int64
        + StorePeerSize <font color=blue>map</font>[uint64]int64

    }
    class regionHandler << (S,Aquamarine) >> {
        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class rpcServer << (S,Aquamarine) >> {
        - dom *domain.Domain
        - sm util.SessionManager

        - handleCopRequest(ctx context.Context, req *coprocessor.Request) *coprocessor.Response
        - createSession() (session.Session, error)

        + Coprocessor(ctx context.Context, in *coprocessor.Request) (*coprocessor.Response, error)
        + CoprocessorStream(in *coprocessor.Request, stream tikvpb.Tikv_CoprocessorStreamServer) error
        + BatchCommands(ss tikvpb.Tikv_BatchCommandsServer) error

    }
    class schemaHandler << (S,Aquamarine) >> {
        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class server.hotRegions << (T, #FF7700) >>  {
    }
    class serverInfo << (S,Aquamarine) >> {
        + IsOwner bool

    }
    class serverInfoHandler << (S,Aquamarine) >> {
        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class settingsHandler << (S,Aquamarine) >> {
        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class sqlInfoFetcher << (S,Aquamarine) >> {
        - store tikv.Storage
        - do *domain.Domain
        - s session.Session

        - zipInfoForSQL(w http.ResponseWriter, r *http.Request) 
        - writeErrFile(zw *zip.Writer, name string, err error) error
        - getExplainAnalyze(ctx context.Context, sql string, resultChan <font color=blue>chan</font> *explainAnalyzeResult) 
        - catchCPUProfile(ctx context.Context, sec int, buf *bytes.Buffer, errChan <font color=blue>chan</font> error) 
        - getStatsForTable(pair tableNamePair) (*handle.JSONTable, error)
        - getShowCreateTable(pair tableNamePair, zw *zip.Writer) error
        - extractTableNames(sql string, curDB string) (<font color=blue>map</font>[tableNamePair]<font color=blue>struct</font>{}, error)

    }
    class status << (S,Aquamarine) >> {
        + Connections int
        + Version string
        + GitHash string

    }
    class tableFlashReplicaInfo << (S,Aquamarine) >> {
        + ID int64
        + ReplicaCount uint64
        + LocationLabels []string
        + Available bool

    }
    class tableFlashReplicaStatus << (S,Aquamarine) >> {
        + ID int64
        + RegionCount uint64
        + FlashRegionCount uint64

        - checkTableFlashReplicaAvailable() bool

    }
    class tableHandler << (S,Aquamarine) >> {
        - op string

        - getPDAddr() ([]string, error)
        - addScatterSchedule(startKey []byte, endKey []byte, name string) error
        - deleteScatterSchedule(name string) error
        - handleScatterTableRequest(schema infoschema.InfoSchema, tbl table.Table, w http.ResponseWriter, req *http.Request) 
        - handleStopScatterTableRequest(schema infoschema.InfoSchema, tbl table.Table, w http.ResponseWriter, req *http.Request) 
        - handleRegionRequest(schema infoschema.InfoSchema, tbl table.Table, w http.ResponseWriter, req *http.Request) 
        - getRegionsByID(tbl table.Table, id int64, name string) (*TableRegions, error)
        - handleDiskUsageRequest(schema infoschema.InfoSchema, tbl table.Table, w http.ResponseWriter, req *http.Request) 

        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class tableNameExtractor << (S,Aquamarine) >> {
        - curDB string
        - names <font color=blue>map</font>[tableNamePair]<font color=blue>struct</font>{}

        + Enter(in ast.Node) (ast.Node, bool)
        + Leave(in ast.Node) (ast.Node, bool)

    }
    class tableNamePair << (S,Aquamarine) >> {
        + DBName string
        + TableName string

    }
    class testHandler << (S,Aquamarine) >> {
        - gcIsRunning uint32

        - handleGC(op string, w http.ResponseWriter, req *http.Request) 
        - handleGCResolveLocks(w http.ResponseWriter, req *http.Request) 

        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
    class tidbResultSet << (S,Aquamarine) >> {
        - recordSet sqlexec.RecordSet
        - columns []*ColumnInfo
        - rows []chunk.Row
        - closed int32
        - preparedStmt *core.CachedPrepareStmt

        + NewChunk() *chunk.Chunk
        + Next(ctx context.Context, req *chunk.Chunk) error
        + StoreFetchedRows(rows []chunk.Row) 
        + GetFetchedRows() []chunk.Row
        + Close() error
        + OnFetchReturned() 
        + Columns() []*ColumnInfo

    }
    class tikvHandlerTool << (S,Aquamarine) >> {
        - getRegionIDByKey(encodedKey []byte) (uint64, error)
        - getMvccByHandle(tableID int64, handle int64) (*mvccKV, error)
        - getMvccByStartTs(startTS uint64, startKey kv.Key, endKey kv.Key) (*mvccKV, error)
        - getMvccByIdxValue(idx table.Index, values url.Values, idxCols []*model.ColumnInfo, handleStr string) (*mvccKV, error)
        - formValue2DatumRow(sc *stmtctx.StatementContext, values url.Values, idxCols []*model.ColumnInfo) ([]types.Datum, error)
        - getTableID(dbName string, tableName string) (int64, error)
        - getTable(dbName string, tableName string) (table.PhysicalTable, error)
        - schema() (infoschema.InfoSchema, error)
        - handleMvccGetByHex(params <font color=blue>map</font>[string]string) (*mvccKV, error)
        - getRegionsMeta(regionIDs []uint64) ([]RegionMeta, error)

    }
    class valueHandler << (S,Aquamarine) >> {
        + ServeHTTP(w http.ResponseWriter, req *http.Request) 

    }
}
"server.tikvHandlerTool" *-- "server.allServerInfoHandler"
"net.Conn" *-- "server.bufferedReadConn"
"server.tikvHandlerTool" *-- "server.dbTableHandler"
"server.tikvHandlerTool" *-- "server.ddlHistoryJobHandler"
"server.tikvHandlerTool" *-- "server.flashReplicaHandler"
"server.clientConn" *-- "server.getLastStmtInConn"
"helper.RegionMetric" *-- "server.hotRegion"
"helper.TblIndex" *-- "server.hotRegion"
"server.tikvHandlerTool" *-- "server.mvccTxnHandler"
"server.tikvHandlerTool" *-- "server.regionHandler"
"sysutil.DiagnosticsServer" *-- "server.rpcServer"
"tikvpb.TikvServer" *-- "server.rpcServer"
"server.tikvHandlerTool" *-- "server.schemaHandler"
"infosync.ServerInfo" *-- "server.serverInfo"
"server.tikvHandlerTool" *-- "server.serverInfoHandler"
"server.tikvHandlerTool" *-- "server.tableHandler"
"server.tikvHandlerTool" *-- "server.testHandler"
"helper.Helper" *-- "server.tikvHandlerTool"

"util.SessionManager" <|-- "server.Server"
"executor.Closeable" <|-- "server.TiDBContext"
"executor.processinfoSetter" <|-- "server.TiDBContext"
"server.QueryCtx" <|-- "server.TiDBContext"
"server.IDriver" <|-- "server.TiDBDriver"
"executor.Closeable" <|-- "server.TiDBStatement"
"server.PreparedStatement" <|-- "server.TiDBStatement"
"executor.Closeable" <|-- "server.clientConn"
"executor.Closeable" <|-- "server.tidbResultSet"
"server.ResultSet" <|-- "server.tidbResultSet"
"server.fetchNotifier" <|-- "server.tidbResultSet"

namespace session {
    class Opt << (S,Aquamarine) >> {
        + PreparedPlanCache *kvcache.SimpleLRUCache

    }
    interface Session  {
        + Status() uint16
        + LastInsertID() uint64
        + LastMessage() string
        + AffectedRows() uint64
        + Execute( context.Context,  string) ([]sqlexec.RecordSet, error)
        + ExecuteInternal( context.Context,  string) ([]sqlexec.RecordSet, error)
        + String() string
        + CommitTxn( context.Context) error
        + RollbackTxn( context.Context) 
        + PrepareStmt(sql string) (uint32, int, []*ast.ResultField, error)
        + ExecutePreparedStmt(ctx context.Context, stmtID uint32, param []types.Datum) (sqlexec.RecordSet, error)
        + DropPreparedStmt(stmtID uint32) error
        + SetClientCapability( uint32) 
        + SetConnectionID( uint64) 
        + SetCommandValue( byte) 
        + SetProcessInfo( string,  time.Time,  byte,  uint64) 
        + SetTLSState( *tls.ConnectionState) 
        + SetCollation(coID int) error
        + SetSessionManager( util.SessionManager) 
        + Close() 
        + Auth(user *auth.UserIdentity, auth []byte, salt []byte) bool
        + ShowProcess() *util.ProcessInfo
        + PrepareTxnCtx( context.Context) 
        + FieldList(tableName string) ([]*ast.ResultField, error)

    }
    class StmtHistory << (S,Aquamarine) >> {
        - history []*stmtRecord

        + Add(st sqlexec.Statement, stmtCtx *stmtctx.StatementContext) 
        + Count() int

    }
    class TxnState << (S,Aquamarine) >> {
        - txnFuture *txnFuture
        - stmtBuf kv.MemBuffer
        - mutations <font color=blue>map</font>[int64]*binlog.TableMutation
        - dirtyTableOP []dirtyTableOperation
        - doNotCommit error

        - init() 
        - initStmtBuf() 
        - stmtBufLen() int
        - stmtBufSize() int
        - stmtBufGet(ctx context.Context, k kv.Key) ([]byte, error)
        - pending() bool
        - validOrPending() bool
        - changeInvalidToValid(txn kv.Transaction) 
        - changeInvalidToPending(future *txnFuture) 
        - changePendingToValid() error
        - changeToInvalid() 
        - reset() 
        - cleanup() 

        + Size() int
        + NewStagingBuffer() kv.MemBuffer
        + Flush() (int, error)
        + Discard() 
        + Valid() bool
        + String() string
        + GoString() string
        + Commit(ctx context.Context) error
        + Rollback() error
        + Get(ctx context.Context, k kv.Key) ([]byte, error)
        + GetMemBuffer() kv.MemBuffer
        + BatchGet(ctx context.Context, keys []kv.Key) (<font color=blue>map</font>[string][]byte, error)
        + Set(k kv.Key, v []byte) error
        + Delete(k kv.Key) error
        + Iter(k kv.Key, upperBound kv.Key) (kv.Iterator, error)
        + IterReverse(k kv.Key) (kv.Iterator, error)
        + KeysNeedToLock() ([]kv.Key, error)

    }
    class dirtyTableOperation << (S,Aquamarine) >> {
        - kind int
        - tid int64
        - handle int64

    }
    class domainMap << (S,Aquamarine) >> {
        - domains <font color=blue>map</font>[string]*domain.Domain
        - mu sync.Mutex

        + Get(store kv.Storage) (*domain.Domain, error)
        + Delete(store kv.Storage) 

    }
    class inCloseSession << (S,Aquamarine) >> {
    }
    class multiQueryNoDelayRecordSet << (S,Aquamarine) >> {
        - affectedRows uint64
        - lastMessage string
        - status uint16
        - warnCount uint16
        - lastInsertID uint64

        + Close() error
        + AffectedRows() uint64
        + LastMessage() string
        + WarnCount() uint16
        + Status() uint16
        + LastInsertID() uint64

    }
    class session << (S,Aquamarine) >> {
        - processInfo atomic.Value
        - txn TxnState
        - mu <font color=blue>struct</font>{sync.RWMutex, <font color=blue>map</font>[fmt.Stringer]<font color=blue>interface</font>{}}
        - currentPlan core.Plan
        - store kv.Storage
        - parser *parser.Parser
        - preparedPlanCache *kvcache.SimpleLRUCache
        - sessionVars *variable.SessionVars
        - sessionManager util.SessionManager
        - statsCollector *handle.SessionStatsCollector
        - ddlOwnerChecker owner.DDLOwnerChecker
        - lockedTables <font color=blue>map</font>[int64]model.TableLockTpInfo
        - client kv.Client

        - cleanRetryInfo() 
        - doCommit(ctx context.Context) error
        - doCommitWithRetry(ctx context.Context) error
        - getSQLLabel() string
        - isInternal() bool
        - isTxnRetryableError(err error) bool
        - checkTxnAborted(stmt sqlexec.Statement) error
        - retry(ctx context.Context, maxCnt uint) error
        - sysSessionPool() sessionPool
        - getExecRet(ctx sessionctx.Context, sql string) (string, error)
        - executeStatement(ctx context.Context, connID uint64, stmtNode ast.StmtNode, stmt sqlexec.Statement, recordSets []sqlexec.RecordSet, inMulitQuery bool) ([]sqlexec.RecordSet, error)
        - execute(ctx context.Context, sql string) ([]sqlexec.RecordSet, error)
        - rollbackOnError(ctx context.Context) 
        - isTxnRetryable() bool
        - loadCommonGlobalVariablesIfNeeded() error
        - recordOnTransactionExecution(err error, counter int, duration float64) 
        - getTxnFuture(ctx context.Context) *txnFuture

        + AddTableLock(locks []model.TableLockTpInfo) 
        + ReleaseTableLocks(locks []model.TableLockTpInfo) 
        + ReleaseTableLockByTableIDs(tableIDs []int64) 
        + CheckTableLocked(tblID int64) (bool, model.TableLockType)
        + GetAllTableLocks() []model.TableLockTpInfo
        + HasLockedTables() bool
        + ReleaseAllTableLocks() 
        + DDLOwnerChecker() owner.DDLOwnerChecker
        + Status() uint16
        + LastInsertID() uint64
        + LastMessage() string
        + AffectedRows() uint64
        + SetClientCapability(capability uint32) 
        + SetConnectionID(connectionID uint64) 
        + SetTLSState(tlsState *tls.ConnectionState) 
        + SetCommandValue(command byte) 
        + SetCollation(coID int) error
        + PreparedPlanCache() *kvcache.SimpleLRUCache
        + SetSessionManager(sm util.SessionManager) 
        + GetSessionManager() util.SessionManager
        + StoreQueryFeedback(feedback <font color=blue>interface</font>{}) 
        + FieldList(tableName string) ([]*ast.ResultField, error)
        + CommitTxn(ctx context.Context) error
        + RollbackTxn(ctx context.Context) 
        + GetClient() kv.Client
        + String() string
        + ExecRestrictedSQL(sql string) ([]chunk.Row, []*ast.ResultField, error)
        + ExecRestrictedSQLWithContext(ctx context.Context, sql string) ([]chunk.Row, []*ast.ResultField, error)
        + ExecRestrictedSQLWithSnapshot(sql string) ([]chunk.Row, []*ast.ResultField, error)
        + GetAllSysVars() (<font color=blue>map</font>[string]string, error)
        + GetGlobalSysVar(name string) (string, error)
        + SetGlobalSysVar(name string, value string) error
        + ParseSQL(ctx context.Context, sql string, charset string, collation string) ([]ast.StmtNode, []error, error)
        + SetProcessInfo(sql string, t time.Time, command byte, maxExecutionTime uint64) 
        + ExecuteInternal(ctx context.Context, sql string) ([]sqlexec.RecordSet, error)
        + Execute(ctx context.Context, sql string) ([]sqlexec.RecordSet, error)
        + PrepareStmt(sql string) (uint32, int, []*ast.ResultField, error)
        + CommonExec(ctx context.Context, stmtID uint32, prepareStmt *core.CachedPrepareStmt, args []types.Datum) (sqlexec.RecordSet, error)
        + CachedPlanExec(ctx context.Context, stmtID uint32, prepareStmt *core.CachedPrepareStmt, args []types.Datum) (sqlexec.RecordSet, error)
        + IsCachedExecOk(ctx context.Context, preparedStmt *core.CachedPrepareStmt) (bool, error)
        + ExecutePreparedStmt(ctx context.Context, stmtID uint32, args []types.Datum) (sqlexec.RecordSet, error)
        + DropPreparedStmt(stmtID uint32) error
        + Txn(active bool) (kv.Transaction, error)
        + NewTxn(ctx context.Context) error
        + SetValue(key fmt.Stringer, value <font color=blue>interface</font>{}) 
        + Value(key fmt.Stringer) <font color=blue>interface</font>{}
        + ClearValue(key fmt.Stringer) 
        + Close() 
        + GetSessionVars() *variable.SessionVars
        + Auth(user *auth.UserIdentity, authentication []byte, salt []byte) bool
        + PrepareTxnCtx(ctx context.Context) 
        + PrepareTSFuture(ctx context.Context) 
        + RefreshTxnCtx(ctx context.Context) error
        + InitTxnWithStartTS(startTS uint64) error
        + GetStore() kv.Storage
        + ShowProcess() *util.ProcessInfo
        + HasDirtyContent(tid int64) bool
        + StmtCommit(memTracker *memory.Tracker) error
        + StmtRollback() 
        + StmtGetMutation(tableID int64) *binlog.TableMutation
        + StmtAddDirtyTableOP(op int, tid int64, handle int64) 

    }
    interface sessionPool  {
        + Get() (pools.Resource, error)
        + Put( pools.Resource) 

    }
    class stmtRecord << (S,Aquamarine) >> {
        - st sqlexec.Statement
        - stmtCtx *stmtctx.StatementContext

    }
    class txnFailFuture << (S,Aquamarine) >> {
        + Wait() (uint64, error)

    }
    class txnFuture << (S,Aquamarine) >> {
        - future oracle.Future
        - store kv.Storage

        - wait() (kv.Transaction, error)

    }
}
"kv.Transaction" *-- "session.TxnState"
"sqlexec.RecordSet" *-- "session.multiQueryNoDelayRecordSet"

"executor.pessimisticTxn" <|-- "session.TxnState"
"kv.BatchGetter" <|-- "session.TxnState"
"kv.Getter" <|-- "session.TxnState"
"kv.Mutator" <|-- "session.TxnState"
"kv.Retriever" <|-- "session.TxnState"
"executor.Closeable" <|-- "session.multiQueryNoDelayRecordSet"
"sqlexec.MultiQueryNoDelayResult" <|-- "session.multiQueryNoDelayRecordSet"
"executor.processinfoSetter" <|-- "session.session"
"session.Session" <|-- "session.session"
"sessionctx.Context" <|-- "session.session"
"sqlexec.SQLExecutor" <|-- "session.session"
"variable.GlobalVarAccessor" <|-- "session.session"
"oracle.Future" <|-- "session.txnFailFuture"

namespace sessionctx {
    interface Context  {
        + NewTxn( context.Context) error
        + Txn(active bool) (kv.Transaction, error)
        + GetClient() kv.Client
        + SetValue(key fmt.Stringer, value <font color=blue>interface</font>{}) 
        + Value(key fmt.Stringer) <font color=blue>interface</font>{}
        + ClearValue(key fmt.Stringer) 
        + GetSessionVars() *variable.SessionVars
        + GetSessionManager() util.SessionManager
        + RefreshTxnCtx( context.Context) error
        + InitTxnWithStartTS(startTS uint64) error
        + GetStore() kv.Storage
        + PreparedPlanCache() *kvcache.SimpleLRUCache
        + StoreQueryFeedback(feedback <font color=blue>interface</font>{}) 
        + HasDirtyContent(tid int64) bool
        + StmtCommit(tracker *memory.Tracker) error
        + StmtRollback() 
        + StmtGetMutation( int64) *binlog.TableMutation
        + StmtAddDirtyTableOP(op int, physicalID int64, handle int64) 
        + DDLOwnerChecker() owner.DDLOwnerChecker
        + AddTableLock( []model.TableLockTpInfo) 
        + ReleaseTableLocks(locks []model.TableLockTpInfo) 
        + ReleaseTableLockByTableIDs(tableIDs []int64) 
        + CheckTableLocked(tblID int64) (bool, model.TableLockType)
        + GetAllTableLocks() []model.TableLockTpInfo
        + ReleaseAllTableLocks() 
        + HasLockedTables() bool
        + PrepareTSFuture(ctx context.Context) 

    }
    class basicCtxType << (S,Aquamarine) >> {
        + String() string

    }
    class connIDCtxKeyType << (S,Aquamarine) >> {
    }
    class sessionctx.basicCtxType << (T, #FF7700) >>  {
    }
}


namespace set {
    class Float64Set << (S,Aquamarine) >> {
        + Exist(val float64) bool
        + Insert(val float64) 
        + Count() int

    }
    class Int64Set << (S,Aquamarine) >> {
        + Exist(val int64) bool
        + Insert(val int64) 
        + Count() int

    }
    class IntSet << (S,Aquamarine) >> {
        + Exist(val int) bool
        + Insert(val int) 
        + Count() int

    }
    class StringSet << (S,Aquamarine) >> {
        + Exist(val string) bool
        + Insert(val string) 
        + Intersection(rhs StringSet) StringSet
        + Count() int

    }
    class set.Float64Set << (T, #FF7700) >>  {
    }
    class set.Int64Set << (T, #FF7700) >>  {
    }
    class set.IntSet << (T, #FF7700) >>  {
    }
    class set.StringSet << (T, #FF7700) >>  {
    }
}


namespace sqlexec {
    interface MultiQueryNoDelayResult  {
        + AffectedRows() uint64
        + LastMessage() string
        + WarnCount() uint16
        + Status() uint16
        + LastInsertID() uint64

    }
    interface RecordSet  {
        + Fields() []*types.ResultField
        + Next(ctx context.Context, req *chunk.Chunk) error
        + NewChunk() *chunk.Chunk
        + Close() error

    }
    interface RestrictedSQLExecutor  {
        + ExecRestrictedSQL(sql string) ([]chunk.Row, []*types.ResultField, error)
        + ExecRestrictedSQLWithContext(ctx context.Context, sql string) ([]chunk.Row, []*types.ResultField, error)
        + ExecRestrictedSQLWithSnapshot(sql string) ([]chunk.Row, []*types.ResultField, error)

    }
    interface SQLExecutor  {
        + Execute(ctx context.Context, sql string) ([]RecordSet, error)
        + ExecuteInternal(ctx context.Context, sql string) ([]RecordSet, error)

    }
    interface SQLParser  {
        + ParseSQL(sql string, charset string, collation string) ([]types.StmtNode, error)

    }
    interface Statement  {
        + OriginText() string
        + Exec(ctx context.Context) (RecordSet, error)
        + IsPrepared() bool
        + IsReadOnly(vars *variable.SessionVars) bool
        + RebuildPlan(ctx context.Context) (int64, error)

    }
}


namespace statistics {
    class AnalyzeJob << (S,Aquamarine) >> {
        - updateTime time.Time

        + DBName string
        + TableName string
        + PartitionName string
        + JobInfo string
        + RowCount int64
        + StartTime time.Time
        + State string

        - getUpdateTime() time.Time

        + Start() 
        + Update(rowCount int64) 
        + Finish(meetError bool) 

    }
    class Bucket << (S,Aquamarine) >> {
        + Count int64
        + Repeat int64

    }
    class BucketFeedback << (S,Aquamarine) >> {
        - feedback []Feedback
        - lower *types.Datum
        - upper *types.Datum

        - getBoundaries(num int) []types.Datum
        - splitBucket(newNumBkts int, totalCount float64, originBucketCount float64) []bucket
        - mergeFullyContainedFeedback(sc *stmtctx.StatementContext, bkt bucket) (float64, float64, bool)
        - refineBucketCount(sc *stmtctx.StatementContext, bkt bucket, defaultCount float64) float64

    }
    class CMSketch << (S,Aquamarine) >> {
        - depth int32
        - width int32
        - count uint64
        - defaultValue uint64
        - table [][]uint32
        - topN <font color=blue>map</font>[uint64][]*TopNMeta

        - findTopNMeta(h1 uint64, h2 uint64, d []byte) *TopNMeta
        - updateTopNWithDelta(h1 uint64, h2 uint64, d []byte, delta uint64) bool
        - insertBytesByCount(bytes []byte, count uint64) 
        - considerDefVal(cnt uint64) bool
        - updateValueBytes(d []byte, count uint64) 
        - setValue(h1 uint64, h2 uint64, count uint64) 
        - subValue(h1 uint64, h2 uint64, count uint64) 
        - queryValue(sc *stmtctx.StatementContext, val types.Datum) (uint64, error)
        - queryHashValue(h1 uint64, h2 uint64) uint64
        - mergeTopN(lTopN <font color=blue>map</font>[uint64][]*TopNMeta, rTopN <font color=blue>map</font>[uint64][]*TopNMeta, numTop uint32, usingMax bool) 

        + QueryTopN(h1 uint64, h2 uint64, d []byte) (uint64, bool)
        + InsertBytes(bytes []byte) 
        + QueryBytes(d []byte) uint64
        + MergeCMSketch(rc *CMSketch, numTopN uint32) error
        + MergeCMSketch4IncrementalAnalyze(rc *CMSketch, numTopN uint32) error
        + TotalCount() uint64
        + Equal(rc *CMSketch) bool
        + Copy() *CMSketch
        + TopN() []*TopNMeta
        + TopNMap() <font color=blue>map</font>[uint64][]*TopNMeta
        + AppendTopN(data []byte, count uint64) 
        + GetWidthAndDepth() (int32, int32)

    }
    class Column << (S,Aquamarine) >> {
        + PhysicalID int64
        + Count int64
        + Info *model.ColumnInfo
        + IsHandle bool
        + Flag int64
        + LastAnalyzePos types.Datum

        - equalRowCount(sc *stmtctx.StatementContext, val types.Datum, modifyCount int64) (float64, error)

        + AvgColSize(count int64, isKey bool) float64
        + AvgColSizeChunkFormat(count int64) float64
        + AvgColSizeListInDisk(count int64) float64
        + String() string
        + IsInvalid(sc *stmtctx.StatementContext, collPseudo bool) bool
        + GetColumnRowCount(sc *stmtctx.StatementContext, ranges []*ranger.Range, modifyCount int64, pkIsHandle bool) (float64, error)

    }
    class ErrorRate << (S,Aquamarine) >> {
        + ErrorTotal float64
        + QueryTotal int64

        + NotAccurate() bool
        + Update(rate float64) 
        + Merge(rate *ErrorRate) 

    }
    class FMSketch << (S,Aquamarine) >> {
        - hashset <font color=blue>map</font>[uint64]bool
        - mask uint64
        - maxSize int
        - hashFunc hash.Hash64

        - insertHashValue(hashVal uint64) 
        - mergeFMSketch(rs *FMSketch) 

        + NDV() int64
        + InsertValue(sc *stmtctx.StatementContext, value types.Datum) error

    }
    class Feedback << (S,Aquamarine) >> {
        + Lower *types.Datum
        + Upper *types.Datum
        + Count int64
        + Repeat int64

        - adjustFeedbackBoundaries(sc *stmtctx.StatementContext, min *types.Datum, max *types.Datum) (bool, error)

    }
    class HistColl << (S,Aquamarine) >> {
        + PhysicalID int64
        + Columns <font color=blue>map</font>[int64]*Column
        + Indices <font color=blue>map</font>[int64]*Index
        + Idx2ColumnIDs <font color=blue>map</font>[int64][]int64
        + ColID2IdxID <font color=blue>map</font>[int64]int64
        + Count int64
        + ModifyCount int64
        + HavePhysicalID bool
        + Pseudo bool

        - getEqualCondSelectivity(idx *Index, bytes []byte, usedColsLen int) float64
        - getIndexRowCount(sc *stmtctx.StatementContext, idxID int64, indexRanges []*ranger.Range) (float64, error)

        + GetRowCountByIntColumnRanges(sc *stmtctx.StatementContext, colID int64, intRanges []*ranger.Range) (float64, error)
        + GetRowCountByColumnRanges(sc *stmtctx.StatementContext, colID int64, colRanges []*ranger.Range) (float64, error)
        + GetRowCountByIndexRanges(sc *stmtctx.StatementContext, idxID int64, indexRanges []*ranger.Range) (float64, error)
        + ID2UniqueID(columns []*expression.Column) *HistColl
        + GenerateHistCollFromColumnInfo(infos []*model.ColumnInfo, columns []*expression.Column) *HistColl
        + GetAvgRowSize(ctx sessionctx.Context, cols []*expression.Column, isEncodedKey bool, isForScan bool) float64
        + GetAvgRowSizeListInDisk(cols []*expression.Column) float64
        + GetTableAvgRowSize(ctx sessionctx.Context, cols []*expression.Column, storeType kv.StoreType, handleInCols bool) float64
        + GetIndexAvgRowSize(ctx sessionctx.Context, cols []*expression.Column, isUnique bool) float64
        + NewHistCollBySelectivity(sc *stmtctx.StatementContext, statsNodes []*StatsNode) *HistColl
        + Selectivity(ctx sessionctx.Context, exprs []expression.Expression, filledPaths []*util.AccessPath) (float64, []*StatsNode, error)

    }
    class Histogram << (S,Aquamarine) >> {
        - scalars []scalar

        + ID int64
        + NDV int64
        + NullCount int64
        + LastUpdateVersion uint64
        + Tp *types.FieldType
        + Bounds *chunk.Chunk
        + Buckets []Bucket
        + TotColSize int64
        + Correlation float64

        - calcFraction(index int, value *types.Datum) float64
        - updateLastBucket(upper *types.Datum, count int64, repeat int64) 
        - equalRowCount(value types.Datum) float64
        - greaterRowCount(value types.Datum) float64
        - lessRowCount(value types.Datum) float64
        - notNullCount() float64
        - mergeBuckets(bucketIdx int) 
        - typeMatch(ranges []*ranger.Range) bool
        - bucketCount(idx int) int64
        - popFirstBucket() 
        - outOfRange(val types.Datum) bool

        + PreCalculateScalar() 
        + GetLower(idx int) *types.Datum
        + GetUpper(idx int) *types.Datum
        + AppendBucket(lower *types.Datum, upper *types.Datum, count int64, repeat int64) 
        + DecodeTo(tp *types.FieldType, timeZone *time.Location) error
        + ConvertTo(sc *stmtctx.StatementContext, tp *types.FieldType) (*Histogram, error)
        + Len() int
        + BucketToString(bktID int, idxCols int) string
        + ToString(idxCols int) string
        + LessRowCountWithBktIdx(value types.Datum) (float64, int)
        + BetweenRowCount(a types.Datum, b types.Datum) float64
        + TotalRowCount() float64
        + GetIncreaseFactor(totalCount int64) float64
        + SplitRange(sc *stmtctx.StatementContext, oldRanges []*ranger.Range, encoded bool) ([]*ranger.Range, bool)
        + IsIndexHist() bool
        + AvgCountPerNotNullValue(totalCount int64) float64
        + Copy() *Histogram
        + RemoveUpperBound() *Histogram
        + TruncateHistogram(numBkt int) *Histogram
        + ExtractTopN(cms *CMSketch, numCols int, numTopN uint32) error

    }
    class Index << (S,Aquamarine) >> {
        + StatsVer int64
        + Info *model.IndexInfo
        + Flag int64
        + LastAnalyzePos types.Datum

        - equalRowCount(sc *stmtctx.StatementContext, b []byte, modifyCount int64) (float64, error)
        - newIndexBySelectivity(sc *stmtctx.StatementContext, statsNode *StatsNode) (*Index, error)
        - outOfRange(val types.Datum) bool

        + String() string
        + IsInvalid(collPseudo bool) bool
        + GetRowCount(sc *stmtctx.StatementContext, indexRanges []*ranger.Range, modifyCount int64) (float64, error)

    }
    class QueryFeedback << (S,Aquamarine) >> {
        - actual int64
        - desc bool

        + PhysicalID int64
        + Hist *Histogram
        + Tp int
        + Feedback []Feedback
        + Expected int64
        + Valid bool

        + CalcErrorRate() float64
        + DecodeToRanges(isIndex bool) ([]*ranger.Range, error)
        + DecodeIntValues() *QueryFeedback
        + StoreRanges(ranges []*ranger.Range) 
        + Invalidate() 
        + Actual() int64
        + Update(startKey kv.Key, counts []int64) 

    }
    class SampleBuilder << (S,Aquamarine) >> {
        + Sc *stmtctx.StatementContext
        + RecordSet sqlexec.RecordSet
        + ColLen int
        + PkBuilder *SortedBuilder
        + MaxBucketSize int64
        + MaxSampleSize int64
        + MaxFMSketchSize int64
        + CMSketchDepth int32
        + CMSketchWidth int32

        + CollectColumnStats() ([]*SampleCollector, *SortedBuilder, error)

    }
    class SampleCollector << (S,Aquamarine) >> {
        - seenValues int64

        + Samples []*SampleItem
        + IsMerger bool
        + NullCount int64
        + Count int64
        + MaxSampleSize int64
        + FMSketch *FMSketch
        + CMSketch *CMSketch
        + TotalSize int64

        - collect(sc *stmtctx.StatementContext, d types.Datum) error

        + MergeSampleCollector(sc *stmtctx.StatementContext, rc *SampleCollector) 
        + CalcTotalSize() 
        + ExtractTopN(numTop uint32, sc *stmtctx.StatementContext, tp *types.FieldType, timeZone *time.Location) error

    }
    class SampleItem << (S,Aquamarine) >> {
        + Value types.Datum
        + Ordinal int
        + RowID int64

    }
    class SortedBuilder << (S,Aquamarine) >> {
        - sc *stmtctx.StatementContext
        - numBuckets int64
        - valuesPerBucket int64
        - lastNumber int64
        - bucketIdx int64
        - hist *Histogram

        + Count int64

        + Hist() *Histogram
        + Iterate(data types.Datum) error

    }
    class StatsNode << (S,Aquamarine) >> {
        - mask int64
        - numCols int
        - partCover bool

        + Tp int
        + ID int64
        + Ranges []*ranger.Range
        + Selectivity float64

    }
    class Table << (S,Aquamarine) >> {
        + Version uint64
        + Name string

        + Copy() *Table
        + String() string
        + IndexStartWithColumn(colName string) *Index
        + ColumnByName(colName string) *Column
        + IsOutdated() bool
        + ColumnGreaterRowCount(sc *stmtctx.StatementContext, value types.Datum, colID int64) float64
        + ColumnLessRowCount(sc *stmtctx.StatementContext, value types.Datum, colID int64) float64
        + ColumnBetweenRowCount(sc *stmtctx.StatementContext, a types.Datum, b types.Datum, colID int64) float64
        + ColumnEqualRowCount(sc *stmtctx.StatementContext, value types.Datum, colID int64) (float64, error)
        + PseudoAvgCountPerValue() float64

    }
    class TopNMeta << (S,Aquamarine) >> {
        - h2 uint64

        + Data []byte
        + Count uint64

        + GetH2() uint64

    }
    class analyzeJobs << (S,Aquamarine) >> {
        - jobs <font color=blue>map</font>[*AnalyzeJob]<font color=blue>struct</font>{}
        - history []*AnalyzeJob

    }
    class bucketScore << (S,Aquamarine) >> {
        - id int
        - score float64

    }
    class bucketScores << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool

    }
    class dataCnt << (S,Aquamarine) >> {
        - data []byte
        - cnt uint64

    }
    class neededColumnMap << (S,Aquamarine) >> {
        - m sync.Mutex
        - cols <font color=blue>map</font>[tableColumnID]<font color=blue>struct</font>{}

        - insert(col tableColumnID) 

        + AllCols() []tableColumnID
        + Delete(col tableColumnID) 

    }
    class queryFeedback << (S,Aquamarine) >> {
        + IntRanges []int64
        + HashValues []uint64
        + IndexRanges [][]byte
        + IndexPoints [][]byte
        + Counts []int64
        + ColumnRanges [][]byte

    }
    class sampleItemSorter << (S,Aquamarine) >> {
        - items []*SampleItem
        - sc *stmtctx.StatementContext
        - err error

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class scalar << (S,Aquamarine) >> {
        - lower float64
        - upper float64
        - commonPfxLen int

    }
    class statistics.bucket << (T, #FF7700) >>  {
    }
    class statistics.bucketScores << (T, #FF7700) >>  {
    }
    class statistics.countByRangeFunc << (T, #FF7700) >>  {
    }
    class tableColumnID << (S,Aquamarine) >> {
        + TableID int64
        + ColumnID int64

    }
    class topNHelper << (S,Aquamarine) >> {
        - sampleSize uint64
        - sorted []dataCnt
        - onlyOnceItems uint64
        - sumTopN uint64
        - actualNumTop uint32

    }
    class "<font color=blue>func</font>(*stmtctx.StatementContext, int64, []*ranger.Range) (float64, error)" as fontcolorbluefuncfontstmtctxStatementContextint64rangerRangefloat64error {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"sync.Mutex" *-- "statistics.AnalyzeJob"
"statistics.CMSketch" *-- "statistics.Column"
"statistics.ErrorRate" *-- "statistics.Column"
"statistics.Histogram" *-- "statistics.Column"
"statistics.CMSketch" *-- "statistics.Index"
"statistics.ErrorRate" *-- "statistics.Index"
"statistics.Histogram" *-- "statistics.Index"
"statistics.HistColl" *-- "statistics.Table"
"sync.Mutex" *-- "statistics.analyzeJobs"


namespace stmtctx {
    class CopTasksDetails << (S,Aquamarine) >> {
        + NumCopTasks int
        + AvgProcessTime time.Duration
        + P90ProcessTime time.Duration
        + MaxProcessAddress string
        + MaxProcessTime time.Duration
        + AvgWaitTime time.Duration
        + P90WaitTime time.Duration
        + MaxWaitAddress string
        + MaxWaitTime time.Duration
        + MaxBackoffTime <font color=blue>map</font>[string]time.Duration
        + MaxBackoffAddress <font color=blue>map</font>[string]string
        + AvgBackoffTime <font color=blue>map</font>[string]time.Duration
        + P90BackoffTime <font color=blue>map</font>[string]time.Duration
        + TotBackoffTime <font color=blue>map</font>[string]time.Duration
        + TotBackoffTimes <font color=blue>map</font>[string]int

        + ToZapFields() []zap.Field

    }
    class SQLWarn << (S,Aquamarine) >> {
        + Level string
        + Err error

    }
    class StatementContext << (S,Aquamarine) >> {
        - mu <font color=blue>struct</font>{sync.Mutex, uint64, uint64, uint64, uint64, uint64, uint64, string, []SQLWarn, uint16, bool, execdetails.ExecDetails, []*execdetails.ExecDetails}
        - nowTs time.Time
        - stmtTimeCached bool
        - digestMemo <font color=blue>struct</font>{sync.Once, string, string}
        - planNormalized string
        - planDigest string
        - lockWaitStartTime *time.Time

        + IsDDLJobInQueue bool
        + InInsertStmt bool
        + InUpdateStmt bool
        + InDeleteStmt bool
        + InSelectStmt bool
        + InLoadDataStmt bool
        + InExplainStmt bool
        + IgnoreTruncate bool
        + IgnoreZeroInDate bool
        + DupKeyAsWarning bool
        + BadNullAsWarning bool
        + DividedByZeroAsWarning bool
        + TruncateAsWarning bool
        + OverflowAsWarning bool
        + InShowWarning bool
        + UseCache bool
        + BatchCheck bool
        + InNullRejectCheck bool
        + AllowInvalidDate bool
        + PrevAffectedRows int64
        + PrevLastInsertID uint64
        + LastInsertID uint64
        + InsertID uint64
        + BaseRowID int64
        + MaxRowID int64
        + TimeZone *time.Location
        + Priority errno.PriorityEnum
        + NotFillCache bool
        + MemTracker *memory.Tracker
        + DiskTracker *disk.Tracker
        + RuntimeStatsColl *execdetails.RuntimeStatsColl
        + TableIDs []int64
        + IndexNames []string
        + StmtType string
        + OriginalSQL string
        + Tables []TableEntry
        + PointExec bool
        + PessimisticLockWaited int32
        + LockKeysDuration time.Duration
        + LockKeysCount int32
        + TblInfo2UnionScan <font color=blue>map</font>[*model.TableInfo]bool
        + TaskID uint64

        + GetNowTsCached() time.Time
        + ResetNowTs() 
        + SQLDigest() string
        + InitSQLDigest(normalized string, digest string) 
        + GetPlanDigest() string
        + SetPlanDigest(normalized string, planDigest string) 
        + AddAffectedRows(rows uint64) 
        + AffectedRows() uint64
        + FoundRows() uint64
        + AddFoundRows(rows uint64) 
        + RecordRows() uint64
        + AddRecordRows(rows uint64) 
        + UpdatedRows() uint64
        + AddUpdatedRows(rows uint64) 
        + CopiedRows() uint64
        + AddCopiedRows(rows uint64) 
        + TouchedRows() uint64
        + AddTouchedRows(rows uint64) 
        + GetMessage() string
        + SetMessage(msg string) 
        + GetWarnings() []SQLWarn
        + WarningCount() uint16
        + NumErrorWarnings() (uint16, int)
        + SetWarnings(warns []SQLWarn) 
        + AppendWarning(warn error) 
        + AppendWarnings(warns []SQLWarn) 
        + AppendNote(warn error) 
        + AppendError(warn error) 
        + SetHistogramsNotLoad() 
        + HandleTruncate(err error) error
        + HandleOverflow(err error, warnErr error) error
        + ResetForRetry() 
        + MergeExecDetails(details *execdetails.ExecDetails, commitDetails *execdetails.CommitDetails) 
        + GetExecDetails() execdetails.ExecDetails
        + ShouldClipToZero() bool
        + ShouldIgnoreOverflowError() bool
        + PushDownFlags() uint64
        + CopTasksDetails() *CopTasksDetails
        + SetFlagsFromPBFlag(flags uint64) 
        + GetLockWaitStartTime() time.Time

    }
    class StmtHints << (S,Aquamarine) >> {
        + MemQuotaQuery int64
        + MaxExecutionTime uint64
        + ReplicaRead byte
        + AllowInSubqToJoinAndAgg bool
        + NoIndexMergeHint bool
        + EnableCascadesPlanner bool
        + HasAllowInSubqToJoinAndAggHint bool
        + HasMemQuotaHint bool
        + HasReplicaReadHint bool
        + HasMaxExecutionTime bool
        + HasEnableCascadesPlannerHint bool

    }
    class TableEntry << (S,Aquamarine) >> {
        + DB string
        + Table string

    }
}
"stmtctx.StmtHints" *-- "stmtctx.StatementContext"


namespace stmtsummary {
    class StmtExecInfo << (S,Aquamarine) >> {
        + SchemaName string
        + OriginalSQL string
        + NormalizedSQL string
        + Digest string
        + PrevSQL string
        + PrevSQLDigest string
        + PlanGenerator <font color=blue>func</font>() string
        + PlanDigest string
        + PlanDigestGen <font color=blue>func</font>() string
        + User string
        + TotalLatency time.Duration
        + ParseLatency time.Duration
        + CompileLatency time.Duration
        + StmtCtx *stmtctx.StatementContext
        + CopTasks *stmtctx.CopTasksDetails
        + ExecDetail *execdetails.ExecDetails
        + MemMax int64
        + DiskMax int64
        + StartTime time.Time
        + IsInternal bool
        + Succeed bool
        + PlanInCache bool

    }
    class stmtSummaryByDigest << (S,Aquamarine) >> {
        - initialized bool
        - history *list.List
        - schemaName string
        - digest string
        - planDigest string
        - stmtType string
        - normalizedSQL string
        - tableNames string
        - isInternal bool

        - init(sei *StmtExecInfo, beginTime int64, intervalSeconds int64, historySize int) 
        - add(sei *StmtExecInfo, beginTime int64, intervalSeconds int64, historySize int) 
        - toCurrentDatum(beginTimeForCurInterval int64, user *auth.UserIdentity, isSuper bool) []types.Datum
        - toHistoryDatum(historySize int, user *auth.UserIdentity, isSuper bool) [][]types.Datum
        - collectHistorySummaries(historySize int) []*stmtSummaryByDigestElement

    }
    class stmtSummaryByDigestElement << (S,Aquamarine) >> {
        - beginTime int64
        - endTime int64
        - sampleSQL string
        - prevSQL string
        - samplePlan string
        - indexNames []string
        - execCount int64
        - sumErrors int
        - sumWarnings int
        - sumLatency time.Duration
        - maxLatency time.Duration
        - minLatency time.Duration
        - sumParseLatency time.Duration
        - maxParseLatency time.Duration
        - sumCompileLatency time.Duration
        - maxCompileLatency time.Duration
        - sumNumCopTasks int64
        - maxCopProcessTime time.Duration
        - maxCopProcessAddress string
        - maxCopWaitTime time.Duration
        - maxCopWaitAddress string
        - sumProcessTime time.Duration
        - maxProcessTime time.Duration
        - sumWaitTime time.Duration
        - maxWaitTime time.Duration
        - sumBackoffTime time.Duration
        - maxBackoffTime time.Duration
        - sumTotalKeys int64
        - maxTotalKeys int64
        - sumProcessedKeys int64
        - maxProcessedKeys int64
        - commitCount int64
        - sumGetCommitTsTime time.Duration
        - maxGetCommitTsTime time.Duration
        - sumPrewriteTime time.Duration
        - maxPrewriteTime time.Duration
        - sumCommitTime time.Duration
        - maxCommitTime time.Duration
        - sumLocalLatchTime time.Duration
        - maxLocalLatchTime time.Duration
        - sumCommitBackoffTime int64
        - maxCommitBackoffTime int64
        - sumResolveLockTime int64
        - maxResolveLockTime int64
        - sumWriteKeys int64
        - maxWriteKeys int
        - sumWriteSize int64
        - maxWriteSize int
        - sumPrewriteRegionNum int64
        - maxPrewriteRegionNum int32
        - sumTxnRetry int64
        - maxTxnRetry int
        - sumBackoffTimes int64
        - backoffTypes <font color=blue>map</font>[fmt.Stringer]int
        - authUsers <font color=blue>map</font>[string]<font color=blue>struct</font>{}
        - sumMem int64
        - maxMem int64
        - sumDisk int64
        - maxDisk int64
        - sumAffectedRows uint64
        - firstSeen time.Time
        - lastSeen time.Time
        - planInCache bool
        - planCacheHits int64

        - onExpire(intervalSeconds int64) 
        - add(sei *StmtExecInfo, intervalSeconds int64) 
        - toDatum(ssbd *stmtSummaryByDigest) []types.Datum

    }
    class stmtSummaryByDigestKey << (S,Aquamarine) >> {
        - schemaName string
        - digest string
        - prevDigest string
        - planDigest string
        - hash []byte

        + Hash() []byte

    }
    class stmtSummaryByDigestMap << (S,Aquamarine) >> {
        - summaryMap *kvcache.SimpleLRUCache
        - beginTimeForCurInterval int64
        - sysVars *systemVars

        - clearInternal() 
        - refreshInterval() int64
        - historySize() int
        - maxStmtCount() int
        - maxSQLLength() int

        + AddStatement(sei *StmtExecInfo) 
        + Clear() 
        + ToCurrentDatum(user *auth.UserIdentity, isSuper bool) [][]types.Datum
        + ToHistoryDatum(user *auth.UserIdentity, isSuper bool) [][]types.Datum
        + GetMoreThanOnceSelect() ([]string, []string)
        + SetEnabled(value string, inSession bool) error
        + Enabled() bool
        + SetEnabledInternalQuery(value string, inSession bool) error
        + EnabledInternal() bool
        + SetRefreshInterval(value string, inSession bool) error
        + SetHistorySize(value string, inSession bool) error
        + SetMaxStmtCount(value string, inSession bool) error
        + SetMaxSQLLength(value string, inSession bool) error

    }
    class systemVars << (S,Aquamarine) >> {
        - variables []variable

        - getVariable(varType int) int64
        - setVariable(varType int, valueStr string, isSession bool) error

    }
    class variable << (S,Aquamarine) >> {
        - sessionValue string
        - globalValue string
        - finalValue int64

    }
}
"sync.Mutex" *-- "stmtsummary.stmtSummaryByDigest"
"sync.Mutex" *-- "stmtsummary.stmtSummaryByDigestElement"
"sync.Mutex" *-- "stmtsummary.stmtSummaryByDigestMap"
"sync.Mutex" *-- "stmtsummary.systemVars"

"kvcache.Key" <|-- "stmtsummary.stmtSummaryByDigestKey"

namespace stringutil {
    class StringerFunc << (S,Aquamarine) >> {
        + String() string

    }
    class StringerStr << (S,Aquamarine) >> {
        + String() string

    }
    class stringutil.StringerFunc << (T, #FF7700) >>  {
    }
    class stringutil.StringerStr << (T, #FF7700) >>  {
    }
}


namespace structure {
    class HashPair << (S,Aquamarine) >> {
        + Field []byte
        + Value []byte

    }
    class ReverseHashIterator << (S,Aquamarine) >> {
        - t *TxStructure
        - iter kv.Iterator
        - prefix []byte
        - done bool
        - field []byte

        + Next() error
        + Valid() bool
        + Key() []byte
        + Value() []byte
        + Close() 

    }
    class TxStructure << (S,Aquamarine) >> {
        - reader kv.Retriever
        - readWriter kv.RetrieverMutator
        - prefix []byte

        - listPush(key []byte, left bool, values ...[]byte) error
        - listPop(key []byte, left bool) ([]byte, error)
        - loadListMeta(metaKey []byte) (listMeta, error)
        - encodeStringDataKey(key []byte) kv.Key
        - encodeHashMetaKey(key []byte) kv.Key
        - encodeHashDataKey(key []byte, field []byte) kv.Key
        - decodeHashDataKey(ek kv.Key) ([]byte, []byte, error)
        - hashDataKeyPrefix(key []byte) kv.Key
        - encodeListMetaKey(key []byte) kv.Key
        - encodeListDataKey(key []byte, index int64) kv.Key
        - hashFieldIntegerVal(val int64) []byte
        - updateHash(key []byte, field []byte, fn <font color=blue>func</font>([]byte) ([]byte, error)) error
        - iterateHash(key []byte, fn <font color=blue>func</font>([]byte, []byte) error) error
        - iterReverseHash(key []byte, fn <font color=blue>func</font>([]byte, []byte) (bool, error)) error
        - loadHashMeta(metaKey []byte) (hashMeta, error)
        - loadHashValue(dataKey []byte) ([]byte, error)

        + Set(key []byte, value []byte) error
        + Get(key []byte) ([]byte, error)
        + GetInt64(key []byte) (int64, error)
        + Inc(key []byte, step int64) (int64, error)
        + Clear(key []byte) error
        + LPush(key []byte, values ...[]byte) error
        + RPush(key []byte, values ...[]byte) error
        + LPop(key []byte) ([]byte, error)
        + RPop(key []byte) ([]byte, error)
        + LLen(key []byte) (int64, error)
        + LGetAll(key []byte) ([][]byte, error)
        + LIndex(key []byte, index int64) ([]byte, error)
        + LSet(key []byte, index int64, value []byte) error
        + LClear(key []byte) error
        + EncodeHashDataKey(key []byte, field []byte) kv.Key
        + HSet(key []byte, field []byte, value []byte) error
        + HGet(key []byte, field []byte) ([]byte, error)
        + EncodeHashAutoIDKeyValue(key []byte, field []byte, val int64) []byte
        + HInc(key []byte, field []byte, step int64) (int64, error)
        + HGetInt64(key []byte, field []byte) (int64, error)
        + HLen(key []byte) (int64, error)
        + HDel(key []byte, fields ...[]byte) error
        + HKeys(key []byte) ([][]byte, error)
        + HGetAll(key []byte) ([]HashPair, error)
        + HGetLastN(key []byte, num int) ([]HashPair, error)
        + HClear(key []byte) error

    }
    class hashMeta << (S,Aquamarine) >> {
        + FieldCount int64

        + Value() []byte
        + IsEmpty() bool

    }
    class listMeta << (S,Aquamarine) >> {
        + LIndex int64
        + RIndex int64

        + Value() []byte
        + IsEmpty() bool

    }
    class structure.TypeFlag << (T, #FF7700) >>  {
    }
}


namespace table {
    class AddRecordOpt << (S,Aquamarine) >> {
        + IsUpdate bool
        + ReserveAutoID int

    }
    interface AddRecordOption  {
        + ApplyOn( *AddRecordOpt) 

    }
    class ColDesc << (S,Aquamarine) >> {
        + Field string
        + Type string
        + Charset <font color=blue>interface</font>{}
        + Collation <font color=blue>interface</font>{}
        + Null string
        + Key string
        + DefaultValue <font color=blue>interface</font>{}
        + Extra string
        + Privileges string
        + Comment string

    }
    class Column << (S,Aquamarine) >> {
        + GeneratedExpr ast.ExprNode
        + DefaultExpr ast.ExprNode

        + String() string
        + ToInfo() *model.ColumnInfo
        + CheckNotNull(data types.Datum) error
        + HandleBadNull(d types.Datum, sc *stmtctx.StatementContext) (types.Datum, error)
        + IsPKHandleColumn(tbInfo *model.TableInfo) bool

    }
    class CreateIdxOpt << (S,Aquamarine) >> {
        + Ctx context.Context
        + SkipHandleCheck bool
        + SkipCheck bool
        + Untouched bool

    }
    class CreateIdxOptFunc << (S,Aquamarine) >> {
        + ApplyOn(opt *AddRecordOpt) 

    }
    interface Index  {
        + Meta() *model.IndexInfo
        + Create(ctx sessionctx.Context, rm kv.RetrieverMutator, indexedValues []types.Datum, h int64, opts ...CreateIdxOptFunc) (int64, error)
        + Delete(sc *stmtctx.StatementContext, m kv.Mutator, indexedValues []types.Datum, h int64) error
        + Drop(rm kv.RetrieverMutator) error
        + Exist(sc *stmtctx.StatementContext, rm kv.RetrieverMutator, indexedValues []types.Datum, h int64) (bool, int64, error)
        + GenIndexKey(sc *stmtctx.StatementContext, indexedValues []types.Datum, h int64, buf []byte) ([]byte, bool, error)
        + Seek(sc *stmtctx.StatementContext, r kv.Retriever, indexedValues []types.Datum) (IndexIterator, bool, error)
        + SeekFirst(r kv.Retriever) (IndexIterator, error)
        + FetchValues(row []types.Datum, columns []types.Datum) ([]types.Datum, error)

    }
    interface IndexIterator  {
        + Next() ([]types.Datum, int64, error)
        + Close() 

    }
    interface PartitionedTable  {
        + GetPartition(physicalID int64) PhysicalTable
        + GetPartitionByRow( sessionctx.Context,  []types.Datum) (PhysicalTable, error)

    }
    interface PhysicalTable  {
        + GetPhysicalID() int64

    }
    class Slice << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    interface Table  {
        + IterRecords(ctx sessionctx.Context, startKey kv.Key, cols []*Column, fn RecordIterFunc) error
        + RowWithCols(ctx sessionctx.Context, h int64, cols []*Column) ([]types.Datum, error)
        + Row(ctx sessionctx.Context, h int64) ([]types.Datum, error)
        + Cols() []*Column
        + VisibleCols() []*Column
        + HiddenCols() []*Column
        + WritableCols() []*Column
        + DeletableCols() []*Column
        + Indices() []Index
        + WritableIndices() []Index
        + DeletableIndices() []Index
        + RecordPrefix() kv.Key
        + IndexPrefix() kv.Key
        + FirstKey() kv.Key
        + RecordKey(h int64) kv.Key
        + AddRecord(ctx sessionctx.Context, r []types.Datum, opts ...AddRecordOption) (int64, error)
        + UpdateRecord(ctx sessionctx.Context, h int64, currData []types.Datum, newData []types.Datum, touched []bool) error
        + RemoveRecord(ctx sessionctx.Context, h int64, r []types.Datum) error
        + Allocators(ctx sessionctx.Context) autoid.Allocators
        + RebaseAutoID(ctx sessionctx.Context, newBase int64, allocIDs bool, tp autoid.AllocatorType) error
        + Meta() *model.TableInfo
        + Seek(ctx sessionctx.Context, h int64) (int64, bool, error)
        + Type() Type

    }
    class Type << (S,Aquamarine) >> {
        + IsNormalTable() bool
        + IsVirtualTable() bool
        + IsClusterTable() bool

    }
    class WithReserveAutoIDHint << (S,Aquamarine) >> {
        + ApplyOn(opt *AddRecordOpt) 

    }
    class isUpdate << (S,Aquamarine) >> {
        + ApplyOn(opt *AddRecordOpt) 

    }
    class table.CreateIdxOptFunc << (T, #FF7700) >>  {
    }
    class table.RecordIterFunc << (T, #FF7700) >>  {
    }
    class table.Slice << (T, #FF7700) >>  {
    }
    class table.Type << (T, #FF7700) >>  {
    }
    class table.WithReserveAutoIDHint << (T, #FF7700) >>  {
    }
    class "<font color=blue>func</font>(int64, []types.Datum, []*Column) (bool, error)" as fontcolorbluefuncfontint64typesDatumColumnboolerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"table.CreateIdxOpt" *-- "table.AddRecordOpt"
"model.ColumnInfo" *-- "table.Column"
"table.Table" *-- "table.PartitionedTable"
"table.Table" *-- "table.PhysicalTable"

"table.AddRecordOption" <|-- "table.CreateIdxOptFunc"
"table.AddRecordOption" <|-- "table.WithReserveAutoIDHint"
"table.AddRecordOption" <|-- "table.isUpdate"

namespace tablecodec {
    class tablecodec.HandleStatus << (T, #FF7700) >>  {
    }
}


namespace tables {
    class ForRangeColumnsPruning << (S,Aquamarine) >> {
        + LessThan []expression.Expression
        + MaxValue bool

    }
    class ForRangePruning << (S,Aquamarine) >> {
        + LessThan []int64
        + MaxValue bool
        + Unsigned bool

    }
    class PartitionExpr << (S,Aquamarine) >> {
        + UpperBounds []expression.Expression
        + OrigExpr ast.ExprNode
        + Expr expression.Expression

    }
    class TableCommon << (S,Aquamarine) >> {
        - tableID int64
        - physicalTableID int64
        - writableIndices []table.Index
        - indices []table.Index
        - meta *model.TableInfo
        - allocs autoid.Allocators
        - sequence *sequenceCommon
        - recordPrefix kv.Key
        - indexPrefix kv.Key

        + Columns []*table.Column
        + PublicColumns []*table.Column
        + VisibleColumns []*table.Column
        + HiddenColumns []*table.Column
        + WritableColumns []*table.Column

        - getCols(mode getColsMode) []*table.Column
        - rebuildIndices(ctx sessionctx.Context, rm kv.RetrieverMutator, h int64, touched []bool, oldData []types.Datum, newData []types.Datum) error
        - genIndexKeyStr(colVals []types.Datum) (string, error)
        - addIndices(sctx sessionctx.Context, recordID int64, r []types.Datum, rm kv.RetrieverMutator, opts []table.CreateIdxOptFunc) (int64, error)
        - addInsertBinlog(ctx sessionctx.Context, h int64, row []types.Datum, colIDs []int64) error
        - addUpdateBinlog(ctx sessionctx.Context, oldRow []types.Datum, newRow []types.Datum, colIDs []int64) error
        - addDeleteBinlog(ctx sessionctx.Context, r []types.Datum, colIDs []int64) error
        - removeRowData(ctx sessionctx.Context, h int64) error
        - removeRowIndices(ctx sessionctx.Context, h int64, rec []types.Datum) error
        - removeRowIndex(sc *stmtctx.StatementContext, rm kv.RetrieverMutator, h int64, vals []types.Datum, idx table.Index, txn kv.Transaction) error
        - buildIndexForRow(ctx sessionctx.Context, rm kv.RetrieverMutator, h int64, vals []types.Datum, idx table.Index, txn kv.Transaction, untouched bool) error
        - getMutation(ctx sessionctx.Context) *binlog.TableMutation
        - canSkip(col *table.Column, value types.Datum) bool
        - canSkipUpdateBinlog(col *table.Column, value types.Datum) bool

        + Indices() []table.Index
        + WritableIndices() []table.Index
        + DeletableIndices() []table.Index
        + Meta() *model.TableInfo
        + GetPhysicalID() int64
        + Cols() []*table.Column
        + VisibleCols() []*table.Column
        + HiddenCols() []*table.Column
        + WritableCols() []*table.Column
        + DeletableCols() []*table.Column
        + RecordPrefix() kv.Key
        + IndexPrefix() kv.Key
        + RecordKey(h int64) kv.Key
        + FirstKey() kv.Key
        + UpdateRecord(ctx sessionctx.Context, h int64, oldData []types.Datum, newData []types.Datum, touched []bool) error
        + AddRecord(ctx sessionctx.Context, r []types.Datum, opts ...table.AddRecordOption) (int64, error)
        + RowWithCols(ctx sessionctx.Context, h int64, cols []*table.Column) ([]types.Datum, error)
        + Row(ctx sessionctx.Context, h int64) ([]types.Datum, error)
        + RemoveRecord(ctx sessionctx.Context, h int64, r []types.Datum) error
        + IterRecords(ctx sessionctx.Context, startKey kv.Key, cols []*table.Column, fn table.RecordIterFunc) error
        + Allocators(ctx sessionctx.Context) autoid.Allocators
        + RebaseAutoID(ctx sessionctx.Context, newBase int64, isSetStep bool, tp autoid.AllocatorType) error
        + Seek(ctx sessionctx.Context, h int64) (int64, bool, error)
        + Type() table.Type
        + GetSequenceNextVal(ctx <font color=blue>interface</font>{}, dbName string, seqName string) (int64, error)
        + SetSequenceVal(ctx <font color=blue>interface</font>{}, newVal int64, dbName string, seqName string) (int64, bool, error)
        + GetSequenceID() int64
        + GetSequenceCommon() *sequenceCommon

    }
    class index << (S,Aquamarine) >> {
        - idxInfo *model.IndexInfo
        - tblInfo *model.TableInfo
        - prefix kv.Key
        - containNonBinaryString bool

        - checkContainNonBinaryString() bool
        - getIndexKeyBuf(buf []byte, defaultCap int) []byte

        + Meta() *model.IndexInfo
        + GenIndexKey(sc *stmtctx.StatementContext, indexedValues []types.Datum, h int64, buf []byte) ([]byte, bool, error)
        + Create(sctx sessionctx.Context, rm kv.RetrieverMutator, indexedValues []types.Datum, h int64, opts ...table.CreateIdxOptFunc) (int64, error)
        + Delete(sc *stmtctx.StatementContext, m kv.Mutator, indexedValues []types.Datum, h int64) error
        + Drop(rm kv.RetrieverMutator) error
        + Seek(sc *stmtctx.StatementContext, r kv.Retriever, indexedValues []types.Datum) (table.IndexIterator, bool, error)
        + SeekFirst(r kv.Retriever) (table.IndexIterator, error)
        + Exist(sc *stmtctx.StatementContext, rm kv.RetrieverMutator, indexedValues []types.Datum, h int64) (bool, int64, error)
        + FetchValues(r []types.Datum, vals []types.Datum) ([]types.Datum, error)

    }
    class indexIter << (S,Aquamarine) >> {
        - it kv.Iterator
        - idx *index
        - prefix kv.Key

        + Close() 
        + Next() ([]types.Datum, int64, error)

    }
    class nameResolver << (S,Aquamarine) >> {
        - tableInfo *model.TableInfo
        - err error

        + Enter(inNode ast.Node) (ast.Node, bool)
        + Leave(inNode ast.Node) (ast.Node, bool)

    }
    class partition << (S,Aquamarine) >> {
        + GetPhysicalID() int64

    }
    class partitionTableWithGivenSets << (S,Aquamarine) >> {
        - partitions <font color=blue>map</font>[int64]<font color=blue>struct</font>{}

        + AddRecord(ctx sessionctx.Context, r []types.Datum, opts ...table.AddRecordOption) (int64, error)
        + UpdateRecord(ctx sessionctx.Context, h int64, currData []types.Datum, newData []types.Datum, touched []bool) error

    }
    class partitionedTable << (S,Aquamarine) >> {
        - partitionExpr *PartitionExpr
        - partitions <font color=blue>map</font>[int64]*partition

        - locatePartition(ctx sessionctx.Context, pi *model.PartitionInfo, r []types.Datum) (int64, error)
        - locateRangePartition(ctx sessionctx.Context, pi *model.PartitionInfo, r []types.Datum) (int, error)
        - locateHashPartition(ctx sessionctx.Context, pi *model.PartitionInfo, r []types.Datum) (int, error)

        + PartitionExpr() (*PartitionExpr, error)
        + GetPartition(pid int64) table.PhysicalTable
        + GetPartitionByRow(ctx sessionctx.Context, r []types.Datum) (table.PhysicalTable, error)
        + AddRecord(ctx sessionctx.Context, r []types.Datum, opts ...table.AddRecordOption) (int64, error)
        + RemoveRecord(ctx sessionctx.Context, h int64, r []types.Datum) error
        + UpdateRecord(ctx sessionctx.Context, h int64, currData []types.Datum, newData []types.Datum, touched []bool) error

    }
    class sequenceCommon << (S,Aquamarine) >> {
        - meta *model.SequenceInfo
        - end int64
        - base int64
        - round int64
        - mu sync.RWMutex

        - getOffset() int64

        + GetSequenceBaseEndRound() (int64, int64, int64)

    }
    class tables.getColsMode << (T, #FF7700) >>  {
    }
}
"tables.ForRangeColumnsPruning" *-- "tables.PartitionExpr"
"tables.ForRangePruning" *-- "tables.PartitionExpr"
"tables.TableCommon" *-- "tables.partition"
"tables.partitionedTable" *-- "tables.partitionTableWithGivenSets"
"tables.TableCommon" *-- "tables.partitionedTable"

"table.PhysicalTable" <|-- "tables.TableCommon"
"table.Table" <|-- "tables.TableCommon"
"util.SequenceTable" <|-- "tables.TableCommon"
"table.Index" <|-- "tables.index"
"table.IndexIterator" <|-- "tables.indexIter"
"table.PhysicalTable" <|-- "tables.partition"
"core.partitionTable" <|-- "tables.partitionedTable"
"table.PartitionedTable" <|-- "tables.partitionedTable"

namespace telemetry {
    class clusterHardwareItem << (S,Aquamarine) >> {
        + InstanceType string
        + ListenHostHash string
        + ListenPort string
        + CPU <font color=blue>map</font>[string]string
        + Memory <font color=blue>map</font>[string]string
        + Disk <font color=blue>map</font>[string]<font color=blue>map</font>[string]string

    }
    class clusterInfoItem << (S,Aquamarine) >> {
        + InstanceType string
        + ListenHostHash string
        + ListenPort string
        + StatusHostHash string
        + StatusPort string
        + Version string
        + GitHash string
        + StartTime string
        + UpTime string

    }
    class status << (S,Aquamarine) >> {
        + CheckAt string
        + IsError bool
        + ErrorMessage string
        + IsRequestSent bool

    }
    class telemetryData << (S,Aquamarine) >> {
        + Hardware []*clusterHardwareItem
        + Instances []*clusterInfoItem
        + TelemetryHostExtra *telemetryHostExtraInfo
        + ReportTimestamp int64
        + TrackingID string

    }
    class telemetryHostExtraInfo << (S,Aquamarine) >> {
        + CPUFlags []string
        + CPUModelName string
        + OS string
        + Platform string
        + PlatformFamily string
        + PlatformVersion string
        + KernelVersion string
        + KernelArch string
        + VirtualizationSystem string
        + VirtualizationRole string

    }
}


namespace testkit {
    class CTestKit << (S,Aquamarine) >> {
        - c *check.C
        - store kv.Storage

        - resultSetToResult(ctx context.Context, rs sqlexec.RecordSet, comment check.CommentInterface) *Result

        + OpenSession(ctx context.Context) context.Context
        + OpenSessionWithDB(ctx context.Context, db string) context.Context
        + CloseSession(ctx context.Context) 
        + Exec(ctx context.Context, sql string, args ...<font color=blue>interface</font>{}) (sqlexec.RecordSet, error)
        + CheckExecResult(ctx context.Context, affectedRows int64, insertID int64) 
        + MustExec(ctx context.Context, sql string, args ...<font color=blue>interface</font>{}) 
        + MustQuery(ctx context.Context, sql string, args ...<font color=blue>interface</font>{}) *Result
        + ConcurrentRun(c *check.C, concurrent int, loops int, prepareFunc <font color=blue>func</font>(context.Context, *CTestKit, int, int) [][][]<font color=blue>interface</font>{}, writeFunc <font color=blue>func</font>(context.Context, *CTestKit, [][]<font color=blue>interface</font>{}) , checkFunc <font color=blue>func</font>(context.Context, *CTestKit) ) 
        + PermInt(n int) []<font color=blue>interface</font>{}
        + IgnoreError(_ error) 

    }
    class Result << (S,Aquamarine) >> {
        - rows [][]string
        - comment check.CommentInterface
        - c *check.C

        + Check(expected [][]<font color=blue>interface</font>{}) 
        + CheckAt(cols []int, expected [][]<font color=blue>interface</font>{}) 
        + Rows() [][]<font color=blue>interface</font>{}
        + Sort() *Result

    }
    class TestKit << (S,Aquamarine) >> {
        - c *check.C
        - store kv.Storage

        + Se session.Session

        + GetConnectionID() 
        + Exec(sql string, args ...<font color=blue>interface</font>{}) (sqlexec.RecordSet, error)
        + CheckExecResult(affectedRows int64, insertID int64) 
        + CheckLastMessage(msg string) 
        + MustExec(sql string, args ...<font color=blue>interface</font>{}) 
        + HasPlan(sql string, plan string, args ...<font color=blue>interface</font>{}) bool
        + MustUseIndex(sql string, index string, args ...<font color=blue>interface</font>{}) bool
        + MustIndexLookup(sql string, args ...<font color=blue>interface</font>{}) *Result
        + MustTableDual(sql string, args ...<font color=blue>interface</font>{}) *Result
        + MustPointGet(sql string, args ...<font color=blue>interface</font>{}) *Result
        + MustQuery(sql string, args ...<font color=blue>interface</font>{}) *Result
        + QueryToErr(sql string, args ...<font color=blue>interface</font>{}) error
        + ExecToErr(sql string, args ...<font color=blue>interface</font>{}) error
        + MustGetErrMsg(sql string, errStr string) 
        + MustGetErrCode(sql string, errCode int) 
        + ResultSetToResult(rs sqlexec.RecordSet, comment check.CommentInterface) *Result
        + ResultSetToResultWithCtx(ctx context.Context, rs sqlexec.RecordSet, comment check.CommentInterface) *Result
        + GetTableID(tableName string) int64

    }
    class sessionCtxKeyType << (S,Aquamarine) >> {
    }
}


namespace testutil {
    class TestData << (S,Aquamarine) >> {
        - input []testCases
        - output []testCases
        - filePathPrefix string
        - funcMap <font color=blue>map</font>[string]int

        + GetTestCasesByName(caseName string, c *check.C, in <font color=blue>interface</font>{}, out <font color=blue>interface</font>{}) 
        + GetTestCases(c *check.C, in <font color=blue>interface</font>{}, out <font color=blue>interface</font>{}) 
        + OnRecord(updateFunc <font color=blue>func</font>() ) 
        + ConvertRowsToStrings(rows [][]<font color=blue>interface</font>{}) []string
        + ConvertSQLWarnToStrings(warns []stmtctx.SQLWarn) []string
        + GenerateOutputIfNeeded() error

    }
    class autoRandom << (S,Aquamarine) >> {
        - originAllowAutoRandom bool
        - originAlterPrimaryKey bool

        + SetupAutoRandomTestConfig() 
        + RestoreAutoRandomTestConfig() 
        + MaskSortHandles(handles []int64, shardBitsCount int, fieldType byte) []int64

    }
    class configTestUtils << (S,Aquamarine) >> {
    }
    class datumEqualsChecker << (S,Aquamarine) >> {
        + Check(params []<font color=blue>interface</font>{}, names []string) (bool, string)

    }
    class testCases << (S,Aquamarine) >> {
        - decodedOut <font color=blue>interface</font>{}

        + Name string
        + Cases *json.RawMessage

    }
}
"testutil.autoRandom" *-- "testutil.configTestUtils"
"check.CheckerInfo" *-- "testutil.datumEqualsChecker"


namespace tikv {
    class AccessMode << (S,Aquamarine) >> {
        + String() string

    }
    class Backoffer << (S,Aquamarine) >> {
        - ctx context.Context
        - fn <font color=blue>map</font>[backoffType]<font color=blue>func</font>(context.Context, int) int
        - maxSleep int
        - totalSleep int
        - errors []error
        - types []fmt.Stringer
        - vars *kv.Variables
        - noop bool
        - backoffSleepMS <font color=blue>map</font>[backoffType]int
        - backoffTimes <font color=blue>map</font>[backoffType]int

        - withVars(vars *kv.Variables) *Backoffer

        + Backoff(typ backoffType, err error) error
        + BackoffWithMaxSleep(typ backoffType, maxSleepMs int, err error) error
        + String() string
        + Clone() *Backoffer
        + Fork() (*Backoffer, context.CancelFunc)

    }
    interface Client  {
        + Close() error
        + SendRequest(ctx context.Context, addr string, req *tikvrpc.Request, timeout time.Duration) (*tikvrpc.Response, error)

    }
    class CopClient << (S,Aquamarine) >> {
        - store *tikvStore
        - replicaReadSeed uint32

        - sendBatch(ctx context.Context, req *kv.Request, vars *kv.Variables) kv.Response

        + Send(ctx context.Context, req *kv.Request, vars *kv.Variables) kv.Response

    }
    class DeleteRangeTask << (S,Aquamarine) >> {
        - completedRegions int
        - store Storage
        - startKey []byte
        - endKey []byte
        - notifyOnly bool
        - concurrency int

        - getRunnerName() string
        - sendReqOnRange(ctx context.Context, r kv.KeyRange) (RangeTaskStat, error)

        + Execute(ctx context.Context) error
        + CompletedRegions() int

    }
    class Driver << (S,Aquamarine) >> {
        + Open(path string) (kv.Storage, error)

    }
    class ErrDeadlock << (S,Aquamarine) >> {
        + IsRetryable bool

        + Error() string

    }
    interface EtcdBackend  {
        + EtcdAddrs() []string
        + TLSConfig() *tls.Config
        + StartGCWorker() error

    }
    class EtcdSafePointKV << (S,Aquamarine) >> {
        - cli *clientv3.Client

        + Put(k string, v string) error
        + Get(k string) (string, error)
        + GetWithPrefix(k string) ([]*mvccpb.KeyValue, error)

    }
    interface GCHandler  {
        + Start() 
        + Close() 

    }
    class KeyLocation << (S,Aquamarine) >> {
        + Region RegionVerID
        + StartKey kv.Key
        + EndKey kv.Key

        + Contains(key []byte) bool

    }
    class Lock << (S,Aquamarine) >> {
        + Key []byte
        + Primary []byte
        + TxnID uint64
        + TTL uint64
        + TxnSize uint64
        + LockType kvrpcpb.Op
        + LockForUpdateTS uint64

        + String() string

    }
    class LockResolver << (S,Aquamarine) >> {
        - store Storage
        - mu <font color=blue>struct</font>{sync.RWMutex, <font color=blue>map</font>[uint64]TxnStatus, *list.List}
        - testingKnobs <font color=blue>struct</font>{<font color=blue>func</font>([]*Lock) }

        - saveResolved(txnID uint64, status TxnStatus) 
        - getResolved(txnID uint64) (TxnStatus, bool)
        - resolveLocksLite(bo *Backoffer, callerStartTS uint64, locks []*Lock) (int64, []uint64, error)
        - resolveLocks(bo *Backoffer, callerStartTS uint64, locks []*Lock, forWrite bool, lite bool) (int64, []uint64, error)
        - resolveLocksForWrite(bo *Backoffer, callerStartTS uint64, locks []*Lock) (int64, error)
        - getTxnStatusFromLock(bo *Backoffer, l *Lock, callerStartTS uint64) (TxnStatus, error)
        - getTxnStatus(bo *Backoffer, txnID uint64, primary []byte, callerStartTS uint64, currentTS uint64, rollbackIfNotExist bool) (TxnStatus, error)
        - resolveLock(bo *Backoffer, l *Lock, status TxnStatus, lite bool, cleanRegions <font color=blue>map</font>[RegionVerID]<font color=blue>struct</font>{}) error
        - resolvePessimisticLock(bo *Backoffer, l *Lock, cleanRegions <font color=blue>map</font>[RegionVerID]<font color=blue>struct</font>{}) error

        + BatchResolveLocks(bo *Backoffer, locks []*Lock, loc RegionVerID) (bool, error)
        + ResolveLocks(bo *Backoffer, callerStartTS uint64, locks []*Lock) (int64, []uint64, error)
        + GetTxnStatus(txnID uint64, callerStartTS uint64, primary []byte) (TxnStatus, error)

    }
    class MockSafePointKV << (S,Aquamarine) >> {
        - store <font color=blue>map</font>[string]string
        - mockLock sync.RWMutex

        + Put(k string, v string) error
        + Get(k string) (string, error)
        + GetWithPrefix(prefix string) ([]*mvccpb.KeyValue, error)

    }
    class RPCContext << (S,Aquamarine) >> {
        + Region RegionVerID
        + Meta *metapb.Region
        + Peer *metapb.Peer
        + AccessIdx AccessIndex
        + Store *Store
        + Addr string
        + AccessMode AccessMode

        + GetStoreID() uint64
        + String() string

    }
    class RangeTaskRunner << (S,Aquamarine) >> {
        - name string
        - store Storage
        - concurrency int
        - handler RangeTaskHandler
        - statLogInterval time.Duration
        - regionsPerTask int
        - completedRegions int32
        - failedRegions int32

        - createWorker(taskCh <font color=blue>chan</font> *kv.KeyRange, wg *sync.WaitGroup) *rangeTaskWorker

        + SetRegionsPerTask(regionsPerTask int) 
        + SetStatLogInterval(interval time.Duration) 
        + RunOnRange(ctx context.Context, startKey kv.Key, endKey kv.Key) error
        + CompletedRegions() int
        + FailedRegions() int

    }
    class RangeTaskStat << (S,Aquamarine) >> {
        + CompletedRegions int
        + FailedRegions int

    }
    class RawKVClient << (S,Aquamarine) >> {
        - clusterID uint64
        - regionCache *RegionCache
        - pdClient client.Client
        - rpcClient Client

        - sendReq(key []byte, req *tikvrpc.Request, reverse bool) (*tikvrpc.Response, *KeyLocation, error)
        - sendBatchReq(bo *Backoffer, keys [][]byte, cmdType tikvrpc.CmdType) (*tikvrpc.Response, error)
        - doBatchReq(bo *Backoffer, batch batch, cmdType tikvrpc.CmdType) singleBatchResp
        - sendDeleteRangeReq(startKey []byte, endKey []byte) (*tikvrpc.Response, []byte, error)
        - sendBatchPut(bo *Backoffer, keys [][]byte, values [][]byte) error
        - doBatchPut(bo *Backoffer, batch batch) error

        + Close() error
        + ClusterID() uint64
        + Get(key []byte) ([]byte, error)
        + BatchGet(keys [][]byte) ([][]byte, error)
        + Put(key []byte, value []byte) error
        + BatchPut(keys [][]byte, values [][]byte) error
        + Delete(key []byte) error
        + BatchDelete(keys [][]byte) error
        + DeleteRange(startKey []byte, endKey []byte) error
        + Scan(startKey []byte, endKey []byte, limit int) ([][]byte, [][]byte, error)
        + ReverseScan(startKey []byte, endKey []byte, limit int) ([][]byte, [][]byte, error)

    }
    class Region << (S,Aquamarine) >> {
        - meta *metapb.Region
        - store unsafe.Pointer
        - syncFlag int32
        - lastAccess int64

        - init(c *RegionCache) error
        - getStore() *RegionStore
        - compareAndSwapStore(oldStore *RegionStore, newStore *RegionStore) bool
        - checkRegionCacheTTL(ts int64) bool
        - invalidate() 
        - scheduleReload() 
        - needReload() bool
        - getKvStorePeer(rs *RegionStore, aidx AccessIndex) (*Store, *metapb.Peer, AccessIndex, int)
        - findElectableStoreID() uint64

        + GetID() uint64
        + GetMeta() *metapb.Region
        + GetLeaderPeerID() uint64
        + GetLeaderStoreID() uint64
        + WorkStorePeer(rs *RegionStore) (*Store, *metapb.Peer, AccessIndex, int)
        + FollowerStorePeer(rs *RegionStore, followerStoreSeed uint32) (*Store, *metapb.Peer, AccessIndex, int)
        + AnyStorePeer(rs *RegionStore, followerStoreSeed uint32) (*Store, *metapb.Peer, AccessIndex, int)
        + VerID() RegionVerID
        + StartKey() []byte
        + EndKey() []byte
        + Contains(key []byte) bool
        + ContainsByEnd(key []byte) bool

    }
    class RegionBatchRequestSender << (S,Aquamarine) >> {
        - sendReqToAddr(bo *Backoffer, ctxs []copTaskAndRPCContext, req *tikvrpc.Request, timout time.Duration) (*tikvrpc.Response, bool, error)
        - onSendFail(bo *Backoffer, ctx *RPCContext, err error) error

    }
    class RegionCache << (S,Aquamarine) >> {
        - pdClient client.Client
        - mu <font color=blue>struct</font>{sync.RWMutex, <font color=blue>map</font>[RegionVerID]*Region, *btree.BTree}
        - storeMu <font color=blue>struct</font>{sync.RWMutex, <font color=blue>map</font>[uint64]*Store}
        - notifyCheckCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - closeCh <font color=blue>chan</font> <font color=blue>struct</font>{}

        - asyncCheckAndResolveLoop() 
        - checkAndResolve(needCheckStores []*Store) 
        - loadAndInsertRegion(bo *Backoffer, key []byte) (*Region, error)
        - findRegionByKey(bo *Backoffer, key []byte, isEndKey bool) (*Region, error)
        - insertRegionToCache(cachedRegion *Region) 
        - searchCachedRegion(key []byte, isEndKey bool) *Region
        - getRegionByIDFromCache(regionID uint64) *Region
        - loadRegion(bo *Backoffer, key []byte, isEndKey bool) (*Region, error)
        - loadRegionByID(bo *Backoffer, regionID uint64) (*Region, error)
        - scanRegions(bo *Backoffer, startKey []byte, endKey []byte, limit int) ([]*Region, error)
        - getCachedRegionWithRLock(regionID RegionVerID) *Region
        - getStoreAddr(bo *Backoffer, region *Region, store *Store, storeIdx int) (string, error)
        - changeToActiveStore(region *Region, store *Store, storeIdx int) string
        - getStoreByStoreID(storeID uint64) *Store
        - switchWorkLeaderToPeer(r *Region, targetStoreID uint64) bool
        - getPeerStoreIndex(r *Region, id uint64) (int, bool)

        + Close() 
        + GetTiKVRPCContext(bo *Backoffer, id RegionVerID, replicaRead kv.ReplicaReadType, followerStoreSeed uint32) (*RPCContext, error)
        + GetTiFlashRPCContext(bo *Backoffer, id RegionVerID) (*RPCContext, error)
        + LocateKey(bo *Backoffer, key []byte) (*KeyLocation, error)
        + LocateEndKey(bo *Backoffer, key []byte) (*KeyLocation, error)
        + OnSendFail(bo *Backoffer, ctx *RPCContext, scheduleReload bool, err error) 
        + LocateRegionByID(bo *Backoffer, regionID uint64) (*KeyLocation, error)
        + GroupKeysByRegion(bo *Backoffer, keys [][]byte, filter <font color=blue>func</font>([]byte, []byte) bool) (<font color=blue>map</font>[RegionVerID][][]byte, RegionVerID, error)
        + GroupSortedMutationsByRegion(bo *Backoffer, m committerMutations) ([]groupedMutations, error)
        + ListRegionIDsInKeyRange(bo *Backoffer, startKey []byte, endKey []byte) ([]uint64, error)
        + LoadRegionsInKeyRange(bo *Backoffer, startKey []byte, endKey []byte) ([]*Region, error)
        + BatchLoadRegionsWithKeyRange(bo *Backoffer, startKey []byte, endKey []byte, count int) ([]*Region, error)
        + BatchLoadRegionsFromKey(bo *Backoffer, startKey []byte, count int) ([]byte, error)
        + InvalidateCachedRegion(id RegionVerID) 
        + UpdateLeader(regionID RegionVerID, leaderStoreID uint64, currentPeerIdx AccessIndex) 
        + OnRegionEpochNotMatch(bo *Backoffer, ctx *RPCContext, currentRegions []*metapb.Region) error
        + PDClient() client.Client

    }
    class RegionRequestSender << (S,Aquamarine) >> {
        - regionCache *RegionCache
        - client Client
        - storeAddr string
        - rpcError error
        - failStoreIDs <font color=blue>map</font>[uint64]<font color=blue>struct</font>{}

        - sendReqToRegion(bo *Backoffer, ctx *RPCContext, req *tikvrpc.Request, timeout time.Duration) (*tikvrpc.Response, bool, error)
        - getStoreToken(st *Store, limit int64) error
        - releaseStoreToken(st *Store) 
        - onSendFail(bo *Backoffer, ctx *RPCContext, err error) error
        - needReloadRegion(ctx *RPCContext) bool
        - onRegionError(bo *Backoffer, ctx *RPCContext, seed *uint32, regionErr *errorpb.Error) (bool, error)

        + SendReq(bo *Backoffer, req *tikvrpc.Request, regionID RegionVerID, timeout time.Duration) (*tikvrpc.Response, error)
        + SendReqCtx(bo *Backoffer, req *tikvrpc.Request, regionID RegionVerID, timeout time.Duration, sType kv.StoreType) (*tikvrpc.Response, *RPCContext, error)

    }
    class RegionStore << (S,Aquamarine) >> {
        - workTiKVIdx AccessIndex
        - workTiFlashIdx int32
        - stores []*Store
        - storeEpochs []uint32
        - accessIndex [][]int

        - accessStore(mode AccessMode, idx AccessIndex) (int, *Store)
        - accessStoreNum(mode AccessMode) int
        - clone() *RegionStore
        - follower(seed uint32) AccessIndex
        - kvPeer(seed uint32) AccessIndex
        - switchNextFlashPeer(rr *Region, currentPeerIdx AccessIndex) 
        - switchNextTiKVPeer(rr *Region, currentPeerIdx AccessIndex) 

    }
    class RegionVerID << (S,Aquamarine) >> {
        - id uint64
        - confVer uint64
        - ver uint64

        + GetID() uint64
        + GetVer() uint64
        + GetConfVer() uint64

    }
    interface SafePointKV  {
        + Put(k string, v string) error
        + Get(k string) (string, error)
        + GetWithPrefix(k string) ([]*mvccpb.KeyValue, error)

    }
    class Scanner << (S,Aquamarine) >> {
        - snapshot *tikvSnapshot
        - batchSize int
        - cache []*kvrpcpb.KvPair
        - idx int
        - nextStartKey kv.Key
        - endKey kv.Key
        - nextEndKey kv.Key
        - reverse bool
        - valid bool
        - eof bool

        - startTS() uint64
        - resolveCurrentLock(bo *Backoffer, current *kvrpcpb.KvPair) error
        - getData(bo *Backoffer) error

        + Valid() bool
        + Key() kv.Key
        + Value() []byte
        + Next() error
        + Close() 

    }
    interface Storage  {
        + GetRegionCache() *RegionCache
        + SendReq(bo *Backoffer, req *tikvrpc.Request, regionID RegionVerID, timeout time.Duration) (*tikvrpc.Response, error)
        + GetLockResolver() *LockResolver
        + GetSafePointKV() SafePointKV
        + UpdateSPCache(cachedSP uint64, cachedTime time.Time) 
        + GetGCHandler() GCHandler
        + SetOracle(oracle oracle.Oracle) 
        + SetTiKVClient(client Client) 
        + GetTiKVClient() Client
        + Closed() <font color=blue>chan</font> <font color=blue>struct</font>{}

    }
    class Store << (S,Aquamarine) >> {
        - addr string
        - saddr string
        - storeID uint64
        - state uint64
        - resolveMutex sync.Mutex
        - epoch uint32
        - storeType kv.StoreType
        - tokenCount atomic.Int64

        - initResolve(bo *Backoffer, c *RegionCache) (string, error)
        - reResolve(c *RegionCache) 
        - getResolveState() resolveState
        - compareAndSwapState(oldState resolveState, newState resolveState) bool
        - markNeedCheck(notifyCheckCh <font color=blue>chan</font> <font color=blue>struct</font>{}) 
        - requestLiveness(bo *Backoffer) livenessState

    }
    class TxnStatus << (S,Aquamarine) >> {
        - ttl uint64
        - commitTS uint64
        - action kvrpcpb.Action

        + IsCommitted() bool
        + CommitTS() uint64
        + TTL() uint64
        + Action() kvrpcpb.Action

    }
    class actionCleanup << (S,Aquamarine) >> {
        - tiKVTxnRegionsNumHistogram() prometheus.Observer
        - handleSingleBatch(c *twoPhaseCommitter, bo *Backoffer, batch batchMutations) error

        + String() string

    }
    class actionCommit << (S,Aquamarine) >> {
        - retry bool

        - tiKVTxnRegionsNumHistogram() prometheus.Observer
        - handleSingleBatch(c *twoPhaseCommitter, bo *Backoffer, batch batchMutations) error

        + String() string

    }
    class actionPessimisticLock << (S,Aquamarine) >> {
        - tiKVTxnRegionsNumHistogram() prometheus.Observer
        - handleSingleBatch(c *twoPhaseCommitter, bo *Backoffer, batch batchMutations) error

        + String() string

    }
    class actionPessimisticRollback << (S,Aquamarine) >> {
        - tiKVTxnRegionsNumHistogram() prometheus.Observer
        - handleSingleBatch(c *twoPhaseCommitter, bo *Backoffer, batch batchMutations) error

        + String() string

    }
    class actionPrewrite << (S,Aquamarine) >> {
        - tiKVTxnRegionsNumHistogram() prometheus.Observer
        - handleSingleBatch(c *twoPhaseCommitter, bo *Backoffer, batch batchMutations) error

        + String() string

    }
    class assertionPair << (S,Aquamarine) >> {
        - key kv.Key
        - assertion kv.AssertionType

        + String() string

    }
    class backoffType << (S,Aquamarine) >> {
        - metric() prometheus.Observer
        - createFn(vars *kv.Variables) <font color=blue>func</font>(context.Context, int) int

        + String() string
        + TError() error

    }
    class batch << (S,Aquamarine) >> {
        - regionID RegionVerID
        - keys [][]byte
        - values [][]byte

    }
    class batchCommandsClient << (S,Aquamarine) >> {
        - target string
        - conn *grpc.ClientConn
        - client tikvpb.Tikv_BatchCommandsClient
        - batched sync.Map
        - idAlloc uint64
        - tikvClientCfg config.TiKVClient
        - tikvLoad *uint64
        - closed int32

        - isStopped() bool
        - send(request *tikvpb.BatchCommandsRequest, entries []*batchCommandsEntry) 
        - recv() (*tikvpb.BatchCommandsResponse, error)
        - failPendingRequests(err error) 
        - waitConnReady() error
        - reCreateStreamingClientOnce(perr error) error
        - batchRecvLoop(cfg config.TiKVClient, tikvTransportLayerLoad *uint64) 
        - reCreateStreamingClient(err error) bool
        - initBatchClient() error

    }
    class batchCommandsEntry << (S,Aquamarine) >> {
        - ctx context.Context
        - req *tikvpb.BatchCommandsRequest_Request
        - res <font color=blue>chan</font> *tikvpb.BatchCommandsResponse_Response
        - canceled int32
        - err error

        - isCanceled() bool

    }
    class batchConn << (S,Aquamarine) >> {
        - idle uint32
        - batchCommandsCh <font color=blue>chan</font> *batchCommandsEntry
        - batchCommandsClients []*batchCommandsClient
        - tikvTransportLayerLoad uint64
        - closed <font color=blue>chan</font> <font color=blue>struct</font>{}
        - idleNotify *uint32
        - idleDetect *time.Timer
        - pendingRequests prometheus.Gauge
        - index uint32

        - isIdle() bool
        - fetchAllPendingRequests(maxBatchSize int, entries *[]*batchCommandsEntry, requests *[]*tikvpb.BatchCommandsRequest_Request) 
        - batchSendLoop(cfg config.TiKVClient) 
        - getClientAndSend(entries []*batchCommandsEntry, requests []*tikvpb.BatchCommandsRequest_Request, requestIDs []uint64) 

        + Close() 

    }
    class batchCopIterator << (S,Aquamarine) >> {
        - store *tikvStore
        - req *kv.Request
        - finishCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - tasks []*batchCopTask
        - respChan <font color=blue>chan</font> *batchCopResponse
        - vars *kv.Variables
        - memTracker *memory.Tracker
        - replicaReadSeed uint32
        - wg sync.WaitGroup
        - closed uint32

        - run(ctx context.Context) 
        - recvFromRespCh(ctx context.Context) (*batchCopResponse, bool, bool)
        - handleTask(ctx context.Context, bo *Backoffer, task *batchCopTask) 
        - retryBatchCopTask(ctx context.Context, bo *Backoffer, batchTask *batchCopTask) ([]*batchCopTask, error)
        - handleTaskOnce(ctx context.Context, bo *Backoffer, task *batchCopTask) ([]*batchCopTask, error)
        - handleStreamedBatchCopResponse(ctx context.Context, bo *Backoffer, response *tikvrpc.BatchCopStreamResponse, task *batchCopTask) error
        - handleBatchCopResponse(bo *Backoffer, response *coprocessor.BatchResponse, task *batchCopTask) error
        - sendToRespCh(resp *batchCopResponse) bool

        + Next(ctx context.Context) (kv.ResultSubset, error)
        + Close() error

    }
    class batchCopResponse << (S,Aquamarine) >> {
        - pbResp *coprocessor.BatchResponse
        - detail *execdetails.ExecDetails
        - startKey kv.Key
        - err error
        - respSize int64
        - respTime time.Duration

        + GetData() []byte
        + GetStartKey() kv.Key
        + GetExecDetails() *execdetails.ExecDetails
        + MemSize() int64
        + RespTime() time.Duration

    }
    class batchCopTask << (S,Aquamarine) >> {
        - storeAddr string
        - cmdType tikvrpc.CmdType
        - copTasks []copTaskAndRPCContext

    }
    class batchExecutor << (S,Aquamarine) >> {
        - rateLim int
        - rateLimiter *rateLimit
        - committer *twoPhaseCommitter
        - action twoPhaseCommitAction
        - backoffer *Backoffer
        - tokenWaitDuration time.Duration

        - initUtils() error
        - startWorker(exitCh <font color=blue>chan</font> <font color=blue>struct</font>{}, ch <font color=blue>chan</font> error, batches []batchMutations) 
        - process(batches []batchMutations) error

    }
    class batchKeys << (S,Aquamarine) >> {
        - region RegionVerID
        - keys [][]byte

    }
    class batchMutations << (S,Aquamarine) >> {
        - region RegionVerID
        - mutations committerMutations
        - isPrimary bool

    }
    class btreeItem << (S,Aquamarine) >> {
        - key []byte
        - cachedRegion *Region

        + Less(other btree.Item) bool

    }
    class clientHelper << (S,Aquamarine) >> {
        - resolveLite bool

        + ResolveLocks(bo *Backoffer, callerStartTS uint64, locks []*Lock) (int64, error)
        + SendReqCtx(bo *Backoffer, req *tikvrpc.Request, regionID RegionVerID, timeout time.Duration, sType kv.StoreType, directStoreAddr string) (*tikvrpc.Response, *RPCContext, string, error)

    }
    class codecPDClient << (S,Aquamarine) >> {
        + GetRegion(ctx context.Context, key []byte) (*client.Region, error)
        + GetPrevRegion(ctx context.Context, key []byte) (*client.Region, error)
        + GetRegionByID(ctx context.Context, regionID uint64) (*client.Region, error)
        + ScanRegions(ctx context.Context, startKey []byte, endKey []byte, limit int) ([]*metapb.Region, []*metapb.Peer, error)

    }
    class committerMutations << (S,Aquamarine) >> {
        - ops []kvrpcpb.Op
        - keys [][]byte
        - values [][]byte
        - isPessimisticLock []bool

        - subRange(from int, to int) committerMutations
        - push(op kvrpcpb.Op, key []byte, value []byte, isPessimisticLock bool) 
        - len() int

    }
    class connArray << (S,Aquamarine) >> {
        - target string
        - index uint32
        - v []*grpc.ClientConn
        - streamTimeout <font color=blue>chan</font> *tikvrpc.Lease
        - done <font color=blue>chan</font> <font color=blue>struct</font>{}

        + Init(addr string, security config.Security, idleNotify *uint32, enableBatch bool) error
        + Get() *grpc.ClientConn
        + Close() 

    }
    class copErrorResponse << (S,Aquamarine) >> {
        + Next(ctx context.Context) (kv.ResultSubset, error)
        + Close() error

    }
    class copIterator << (S,Aquamarine) >> {
        - store *tikvStore
        - req *kv.Request
        - concurrency int
        - finishCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - tasks []*copTask
        - curr int
        - sendRate *rateLimit
        - respChan <font color=blue>chan</font> *copResponse
        - vars *kv.Variables
        - memTracker *memory.Tracker
        - replicaReadSeed uint32
        - wg sync.WaitGroup
        - closed uint32

        - open(ctx context.Context) 
        - recvFromRespCh(ctx context.Context, respCh <font color=blue>chan</font> *copResponse) (*copResponse, bool, bool)

        + Next(ctx context.Context) (kv.ResultSubset, error)
        + Close() error

    }
    class copIteratorTaskSender << (S,Aquamarine) >> {
        - taskCh <font color=blue>chan</font> *copTask
        - wg *sync.WaitGroup
        - tasks []*copTask
        - finishCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - respChan <font color=blue>chan</font> *copResponse
        - sendRate *rateLimit

        - run() 
        - sendToTaskCh(t *copTask) bool

    }
    class copIteratorWorker << (S,Aquamarine) >> {
        - taskCh <font color=blue>chan</font> *copTask
        - wg *sync.WaitGroup
        - store *tikvStore
        - req *kv.Request
        - respChan <font color=blue>chan</font> *copResponse
        - finishCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - vars *kv.Variables
        - memTracker *memory.Tracker
        - replicaReadSeed uint32

        - run(ctx context.Context) 
        - sendToRespCh(resp *copResponse, respCh <font color=blue>chan</font> *copResponse, checkOOM bool) bool
        - handleTask(ctx context.Context, task *copTask, respCh <font color=blue>chan</font> *copResponse) 
        - handleTaskOnce(bo *Backoffer, task *copTask, ch <font color=blue>chan</font> *copResponse) ([]*copTask, error)
        - logTimeCopTask(costTime time.Duration, task *copTask, bo *Backoffer, resp *tikvrpc.Response) 
        - handleCopStreamResult(bo *Backoffer, rpcCtx *RPCContext, stream *tikvrpc.CopStreamResponse, task *copTask, ch <font color=blue>chan</font> *copResponse, costTime time.Duration) ([]*copTask, error)
        - handleCopResponse(bo *Backoffer, rpcCtx *RPCContext, resp *copResponse, cacheKey []byte, cacheValue *coprCacheValue, task *copTask, ch <font color=blue>chan</font> *copResponse, lastRange *coprocessor.KeyRange, costTime time.Duration) ([]*copTask, error)
        - handleTiDBSendReqErr(err error, task *copTask, ch <font color=blue>chan</font> *copResponse) error
        - buildCopTasksFromRemain(bo *Backoffer, lastRange *coprocessor.KeyRange, task *copTask) ([]*copTask, error)
        - calculateRemain(ranges *copRanges, split *coprocessor.KeyRange, desc bool) *copRanges

    }
    class copRanges << (S,Aquamarine) >> {
        - first *kv.KeyRange
        - mid []kv.KeyRange
        - last *kv.KeyRange

        - len() int
        - at(i int) kv.KeyRange
        - slice(from int, to int) *copRanges
        - do(f <font color=blue>func</font>(*kv.KeyRange) ) 
        - toPBRanges() []*coprocessor.KeyRange
        - split(key []byte) (*copRanges, *copRanges)

        + String() string

    }
    class copResponse << (S,Aquamarine) >> {
        - pbResp *coprocessor.Response
        - detail *execdetails.ExecDetails
        - startKey kv.Key
        - err error
        - respSize int64
        - respTime time.Duration

        + GetData() []byte
        + GetStartKey() kv.Key
        + GetExecDetails() *execdetails.ExecDetails
        + MemSize() int64
        + RespTime() time.Duration

    }
    class copTask << (S,Aquamarine) >> {
        - region RegionVerID
        - ranges *copRanges
        - respChan <font color=blue>chan</font> *copResponse
        - storeAddr string
        - cmdType tikvrpc.CmdType
        - storeType kv.StoreType

        + String() string

    }
    class copTaskAndRPCContext << (S,Aquamarine) >> {
        - task *copTask
        - ctx *RPCContext

    }
    class coprCache << (S,Aquamarine) >> {
        - cache *ristretto.Cache
        - admissionMaxSize int
        - admissionMinProcessTime time.Duration

        + Get(key []byte) *coprCacheValue
        + CheckAdmission(dataSize int, processTime time.Duration) bool
        + Set(key []byte, value *coprCacheValue) bool

    }
    class coprCacheValue << (S,Aquamarine) >> {
        + Key []byte
        + Data []byte
        + TimeStamp uint64
        + RegionID uint64
        + RegionDataVersion uint64

        + String() string
        + Len() int

    }
    class groupedMutations << (S,Aquamarine) >> {
        - region RegionVerID
        - mutations committerMutations

    }
    class minCommitTSPushed << (S,Aquamarine) >> {
        - data <font color=blue>map</font>[uint64]<font color=blue>struct</font>{}

        + Update(from []uint64) 
        + Get() []uint64

    }
    class rangeTaskWorker << (S,Aquamarine) >> {
        - name string
        - store Storage
        - handler RangeTaskHandler
        - taskCh <font color=blue>chan</font> *kv.KeyRange
        - wg *sync.WaitGroup
        - err error
        - completedRegions *int32
        - failedRegions *int32

        - run(ctx context.Context, cancel context.CancelFunc) 

    }
    class rateLimit << (S,Aquamarine) >> {
        - token <font color=blue>chan</font> <font color=blue>struct</font>{}

        - getToken(done <font color=blue>chan</font> <font color=blue>struct</font>{}) bool
        - putToken() 

    }
    class reqCollapse << (S,Aquamarine) >> {
        - tryCollapseRequest(ctx context.Context, addr string, req *tikvrpc.Request, timeout time.Duration) (bool, *tikvrpc.Response, error)
        - collapse(ctx context.Context, key string, sf *singleflight.Group, addr string, req *tikvrpc.Request, timeout time.Duration) (*tikvrpc.Response, error)

        + Close() error
        + SendRequest(ctx context.Context, addr string, req *tikvrpc.Request, timeout time.Duration) (*tikvrpc.Response, error)

    }
    class rpcClient << (S,Aquamarine) >> {
        - conns <font color=blue>map</font>[string]*connArray
        - security config.Security
        - idleNotify uint32
        - isClosed bool

        - getConnArray(addr string, enableBatch bool) (*connArray, error)
        - createConnArray(addr string, enableBatch bool) (*connArray, error)
        - closeConns() 
        - updateTiKVSendReqHistogram(req *tikvrpc.Request, start time.Time) 
        - getCopStreamResponse(ctx context.Context, client tikvpb.TikvClient, req *tikvrpc.Request, timeout time.Duration, connArray *connArray) (*tikvrpc.Response, error)
        - getBatchCopStreamResponse(ctx context.Context, client tikvpb.TikvClient, req *tikvrpc.Request, timeout time.Duration, connArray *connArray) (*tikvrpc.Response, error)
        - recycleIdleConnArray() 

        + SendRequest(ctx context.Context, addr string, req *tikvrpc.Request, timeout time.Duration) (*tikvrpc.Response, error)
        + Close() error

    }
    interface schemaLeaseChecker  {
        + Check(txnTS uint64) error

    }
    class sendReqHistCacheKey << (S,Aquamarine) >> {
        - tp tikvrpc.CmdType
        - id uint64

    }
    class server << (S,Aquamarine) >> {
        + BatchCommands(ss tikvpb.Tikv_BatchCommandsServer) error

    }
    class singleBatchResp << (S,Aquamarine) >> {
        - resp *tikvrpc.Response
        - err error

    }
    class storeCache << (S,Aquamarine) >> {
        - cache <font color=blue>map</font>[string]*tikvStore

    }
    class tikv.AccessIndex << (T, #FF7700) >>  {
    }
    class tikv.AccessMode << (T, #FF7700) >>  {
    }
    class tikv.RangeTaskHandler << (T, #FF7700) >>  {
    }
    class tikv.backoffType << (T, #FF7700) >>  {
    }
    class tikv.livenessState << (T, #FF7700) >>  {
    }
    class tikv.resolveState << (T, #FF7700) >>  {
    }
    class tikv.ttlManagerState << (T, #FF7700) >>  {
    }
    class tikvSnapshot << (S,Aquamarine) >> {
        - store *tikvStore
        - version kv.Version
        - priority kvrpcpb.CommandPri
        - notFillCache bool
        - syncLog bool
        - keyOnly bool
        - vars *kv.Variables
        - replicaRead kv.ReplicaReadType
        - replicaReadSeed uint32
        - taskID uint64
        - mu <font color=blue>struct</font>{sync.RWMutex, <font color=blue>map</font>[string][]byte}

        - setSnapshotTS(ts uint64) 
        - batchGetKeysByRegions(bo *Backoffer, keys [][]byte, collectF <font color=blue>func</font>([]byte, []byte) ) error
        - batchGetSingleRegion(bo *Backoffer, batch batchKeys, collectF <font color=blue>func</font>([]byte, []byte) ) error
        - get(bo *Backoffer, k kv.Key) ([]byte, error)

        + BatchGet(ctx context.Context, keys []kv.Key) (<font color=blue>map</font>[string][]byte, error)
        + Get(ctx context.Context, k kv.Key) ([]byte, error)
        + Iter(k kv.Key, upperBound kv.Key) (kv.Iterator, error)
        + IterReverse(k kv.Key) (kv.Iterator, error)
        + SetOption(opt kv.Option, val <font color=blue>interface</font>{}) 
        + DelOption(opt kv.Option) 

    }
    class tikvStore << (S,Aquamarine) >> {
        - clusterID uint64
        - uuid string
        - oracle oracle.Oracle
        - client Client
        - pdClient client.Client
        - regionCache *RegionCache
        - coprCache *coprCache
        - lockResolver *LockResolver
        - txnLatches *latch.LatchesScheduler
        - gcWorker GCHandler
        - etcdAddrs []string
        - tlsConfig *tls.Config
        - mock bool
        - enableGC bool
        - kv SafePointKV
        - safePoint uint64
        - spTime time.Time
        - spMutex sync.RWMutex
        - closed <font color=blue>chan</font> <font color=blue>struct</font>{}
        - replicaReadSeed uint32

        - splitBatchRegionsReq(bo *Backoffer, keys [][]byte, scatter bool) (*tikvrpc.Response, error)
        - batchSendSingleRegion(bo *Backoffer, batch batch, scatter bool) singleBatchResp
        - scatterRegion(ctx context.Context, regionID uint64) error
        - runSafePointChecker() 
        - getTimestampWithRetry(bo *Backoffer) (uint64, error)
        - nextReplicaReadSeed() uint32

        + SplitRegions(ctx context.Context, splitKeys [][]byte, scatter bool) ([]uint64, error)
        + WaitScatterRegionFinish(ctx context.Context, regionID uint64, backOff int) error
        + CheckRegionInScattering(regionID uint64) (bool, error)
        + UpdateSPCache(cachedSP uint64, cachedTime time.Time) 
        + CheckVisibility(startTime uint64) error
        + EnableTxnLocalLatches(size uint) 
        + IsLatchEnabled() bool
        + EtcdAddrs() []string
        + TLSConfig() *tls.Config
        + StartGCWorker() error
        + Begin() (kv.Transaction, error)
        + BeginWithStartTS(startTS uint64) (kv.Transaction, error)
        + GetSnapshot(ver kv.Version) (kv.Snapshot, error)
        + Close() error
        + UUID() string
        + CurrentVersion() (kv.Version, error)
        + GetClient() kv.Client
        + GetOracle() oracle.Oracle
        + Name() string
        + Describe() string
        + ShowStatus(ctx context.Context, key string) (<font color=blue>interface</font>{}, error)
        + SupportDeleteRange() bool
        + SendReq(bo *Backoffer, req *tikvrpc.Request, regionID RegionVerID, timeout time.Duration) (*tikvrpc.Response, error)
        + GetRegionCache() *RegionCache
        + GetLockResolver() *LockResolver
        + GetGCHandler() GCHandler
        + Closed() <font color=blue>chan</font> <font color=blue>struct</font>{}
        + GetSafePointKV() SafePointKV
        + SetOracle(oracle oracle.Oracle) 
        + SetTiKVClient(client Client) 
        + GetTiKVClient() Client

    }
    class tikvTxn << (S,Aquamarine) >> {
        - snapshot *tikvSnapshot
        - us kv.UnionStore
        - store *tikvStore
        - startTS uint64
        - startTime time.Time
        - commitTS uint64
        - lockKeys [][]byte
        - lockedMap <font color=blue>map</font>[string]<font color=blue>struct</font>{}
        - mu sync.Mutex
        - setCnt int64
        - vars *kv.Variables
        - committer *twoPhaseCommitter
        - assertions []assertionPair
        - confirmed int
        - valid bool
        - dirty bool

        - close() 
        - rollbackPessimisticLocks() error
        - asyncPessimisticRollback(ctx context.Context, keys [][]byte) *sync.WaitGroup

        + SetVars(vars *kv.Variables) 
        + GetVars() *kv.Variables
        + NewStagingBuffer() kv.MemBuffer
        + Flush() (int, error)
        + Discard() 
        + Get(ctx context.Context, k kv.Key) ([]byte, error)
        + BatchGet(ctx context.Context, keys []kv.Key) (<font color=blue>map</font>[string][]byte, error)
        + Set(k kv.Key, v []byte) error
        + String() string
        + Iter(k kv.Key, upperBound kv.Key) (kv.Iterator, error)
        + IterReverse(k kv.Key) (kv.Iterator, error)
        + Delete(k kv.Key) error
        + SetOption(opt kv.Option, val <font color=blue>interface</font>{}) 
        + DelOption(opt kv.Option) 
        + IsPessimistic() bool
        + Commit(ctx context.Context) error
        + Rollback() error
        + LockKeys(ctx context.Context, lockCtx *kv.LockCtx, keysInput ...kv.Key) error
        + IsReadOnly() bool
        + StartTS() uint64
        + Valid() bool
        + Len() int
        + Size() int
        + GetMemBuffer() kv.MemBuffer
        + GetSnapshot() kv.Snapshot

    }
    class tikvTxnStagingBuffer << (S,Aquamarine) >> {
        - txn *tikvTxn

        + Flush() (int, error)

    }
    class tryLock << (S,Aquamarine) >> {
        - reCreating bool

        - tryLockForSend() bool
        - unlockForSend() 
        - lockForRecreate() 
        - unlockForRecreate() 

    }
    class ttlManager << (S,Aquamarine) >> {
        - state ttlManagerState
        - ch <font color=blue>chan</font> <font color=blue>struct</font>{}
        - lockCtx *kv.LockCtx

        - run(c *twoPhaseCommitter, lockCtx *kv.LockCtx) 
        - close() 
        - keepAlive(c *twoPhaseCommitter) 

    }
    interface twoPhaseCommitAction  {
        - handleSingleBatch( *twoPhaseCommitter,  *Backoffer,  batchMutations) error
        - tiKVTxnRegionsNumHistogram() prometheus.Observer

        + String() string

    }
    class twoPhaseCommitter << (S,Aquamarine) >> {
        - store *tikvStore
        - txn *tikvTxn
        - startTS uint64
        - mutations committerMutations
        - lockTTL uint64
        - commitTS uint64
        - priority kvrpcpb.CommandPri
        - connID uint64
        - cleanWg sync.WaitGroup
        - detail unsafe.Pointer
        - txnSize int
        - noNeedCommitKeys <font color=blue>map</font>[string]<font color=blue>struct</font>{}
        - primaryKey []byte
        - forUpdateTS uint64
        - mu <font color=blue>struct</font>{sync.RWMutex, error, bool}
        - syncLog bool
        - isPessimistic bool
        - isFirstLock bool
        - regionTxnSize <font color=blue>map</font>[uint64]int
        - testingKnobs <font color=blue>struct</font>{<font color=blue>chan</font> <font color=blue>struct</font>{}, <font color=blue>chan</font> <font color=blue>struct</font>{}}

        - initKeysAndMutations() error
        - primary() []byte
        - doActionOnMutations(bo *Backoffer, action twoPhaseCommitAction, mutations committerMutations) error
        - doActionOnGroupMutations(bo *Backoffer, action twoPhaseCommitAction, groups []groupedMutations) error
        - doActionOnBatches(bo *Backoffer, action twoPhaseCommitAction, batches []batchMutations) error
        - keyValueSize(key []byte, value []byte) int
        - keySize(key []byte, value []byte) int
        - buildPrewriteRequest(batch batchMutations, txnSize uint64) *tikvrpc.Request
        - setDetail(d *execdetails.CommitDetails) 
        - getDetail() *execdetails.CommitDetails
        - setUndeterminedErr(err error) 
        - getUndeterminedErr() error
        - prewriteMutations(bo *Backoffer, mutations committerMutations) error
        - commitMutations(bo *Backoffer, mutations committerMutations) error
        - cleanupMutations(bo *Backoffer, mutations committerMutations) error
        - pessimisticLockMutations(bo *Backoffer, lockCtx *kv.LockCtx, mutations committerMutations) error
        - pessimisticRollbackMutations(bo *Backoffer, mutations committerMutations) error
        - execute(ctx context.Context) error
        - stripNoNeedCommitKeys() 
        - checkSchemaValid() error
        - prewriteBinlog(ctx context.Context) <font color=blue>chan</font> *binloginfo.WriteResult
        - writeFinishBinlog(ctx context.Context, tp binlog.BinlogType, commitTS int64) 
        - shouldWriteBinlog() bool
        - appendBatchMutationsBySize(b []batchMutations, region RegionVerID, mutations committerMutations, sizeFn <font color=blue>func</font>([]byte, []byte) int, limit int, primaryIdx *int) []batchMutations

    }
    class txnExpireTime << (S,Aquamarine) >> {
        - initialized bool
        - txnExpire int64

        - update(lockExpire int64) 
        - value() int64

    }
    class txnNotFoundErr << (S,Aquamarine) >> {
        + Error() string

    }
    class txnStartCtxKeyType << (S,Aquamarine) >> {
    }
    class "<font color=blue>func</font>(context.Context, kv.KeyRange) (RangeTaskStat, error)" as fontcolorbluefuncfontcontextContextkvKeyRangeRangeTaskStaterror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"kv.RequestTypeSupportedChecker" *-- "tikv.CopClient"
"kvrpcpb.Deadlock" *-- "tikv.ErrDeadlock"
"tikv.RegionRequestSender" *-- "tikv.RegionBatchRequestSender"
"kv.LockCtx" *-- "tikv.actionPessimisticLock"
"tikv.tryLock" *-- "tikv.batchCommandsClient"
"tikv.clientHelper" *-- "tikv.batchCopIterator"
"tikv.Client" *-- "tikv.clientHelper"
"tikv.LockResolver" *-- "tikv.clientHelper"
"tikv.RegionCache" *-- "tikv.clientHelper"
"tikv.minCommitTSPushed" *-- "tikv.clientHelper"
"client.Client" *-- "tikv.codecPDClient"
"tikv.batchConn" *-- "tikv.connArray"
"__builtin__.error" *-- "tikv.copErrorResponse"
"tikv.minCommitTSPushed" *-- "tikv.copIterator"
"tikv.clientHelper" *-- "tikv.copIteratorWorker"
"sync.RWMutex" *-- "tikv.minCommitTSPushed"
"tikv.Client" *-- "tikv.reqCollapse"
"sync.RWMutex" *-- "tikv.rpcClient"
"tikvpb.TikvServer" *-- "tikv.server"
"sync.Mutex" *-- "tikv.storeCache"
"tikv.minCommitTSPushed" *-- "tikv.tikvSnapshot"
"kv.MemBuffer" *-- "tikv.tikvTxnStagingBuffer"
"sync.RWMutex" *-- "tikv.tryLock"
"tikv.ttlManager" *-- "tikv.twoPhaseCommitter"
"kvrpcpb.TxnNotFound" *-- "tikv.txnNotFoundErr"

"kv.Driver" <|-- "tikv.Driver"
"tikv.SafePointKV" <|-- "tikv.EtcdSafePointKV"
"tikv.SafePointKV" <|-- "tikv.MockSafePointKV"
"executor.Closeable" <|-- "tikv.RawKVClient"
"kv.Iterator" <|-- "tikv.Scanner"
"tikv.twoPhaseCommitAction" <|-- "tikv.actionCleanup"
"tikv.twoPhaseCommitAction" <|-- "tikv.actionCommit"
"tikv.twoPhaseCommitAction" <|-- "tikv.actionPessimisticLock"
"tikv.twoPhaseCommitAction" <|-- "tikv.actionPessimisticRollback"
"tikv.twoPhaseCommitAction" <|-- "tikv.actionPrewrite"
"executor.Closeable" <|-- "tikv.batchCopIterator"
"kv.Response" <|-- "tikv.batchCopIterator"
"kv.ResultSubset" <|-- "tikv.batchCopResponse"
"executor.Closeable" <|-- "tikv.copErrorResponse"
"kv.Response" <|-- "tikv.copErrorResponse"
"executor.Closeable" <|-- "tikv.copIterator"
"kv.Response" <|-- "tikv.copIterator"
"kv.ResultSubset" <|-- "tikv.copResponse"
"executor.Closeable" <|-- "tikv.reqCollapse"
"mocktikv.Client" <|-- "tikv.reqCollapse"
"tikv.Client" <|-- "tikv.reqCollapse"
"executor.Closeable" <|-- "tikv.rpcClient"
"mocktikv.Client" <|-- "tikv.rpcClient"
"tikv.Client" <|-- "tikv.rpcClient"
"kv.BatchGetter" <|-- "tikv.tikvSnapshot"
"kv.Getter" <|-- "tikv.tikvSnapshot"
"kv.Retriever" <|-- "tikv.tikvSnapshot"
"kv.Snapshot" <|-- "tikv.tikvSnapshot"
"executor.Closeable" <|-- "tikv.tikvStore"
"kv.SplittableStore" <|-- "tikv.tikvStore"
"kv.Storage" <|-- "tikv.tikvStore"
"kv.VersionProvider" <|-- "tikv.tikvStore"
"tikv.EtcdBackend" <|-- "tikv.tikvStore"
"tikv.Storage" <|-- "tikv.tikvStore"
"kv.BatchGetter" <|-- "tikv.tikvTxn"
"kv.Getter" <|-- "tikv.tikvTxn"
"kv.MemBuffer" <|-- "tikv.tikvTxn"
"kv.Mutator" <|-- "tikv.tikvTxn"
"kv.Retriever" <|-- "tikv.tikvTxn"
"kv.Snapshot" <|-- "tikv.tikvTxn"
"kv.Transaction" <|-- "tikv.tikvTxn"

namespace tikvrpc {
    class BatchCopStreamResponse << (S,Aquamarine) >> {
        + Timeout time.Duration

        + Recv() (*coprocessor.BatchResponse, error)
        + Close() 

    }
    class CmdType << (S,Aquamarine) >> {
        + String() string

    }
    class CopStreamResponse << (S,Aquamarine) >> {
        + Timeout time.Duration

        + Recv() (*coprocessor.Response, error)
        + Close() 

    }
    class Lease << (S,Aquamarine) >> {
        - deadline int64

        + Cancel context.CancelFunc

    }
    class Request << (S,Aquamarine) >> {
        - req <font color=blue>interface</font>{}

        + Type CmdType
        + ReplicaReadSeed uint32
        + StoreTp kv.StoreType

        + Get() *kvrpcpb.GetRequest
        + Scan() *kvrpcpb.ScanRequest
        + Prewrite() *kvrpcpb.PrewriteRequest
        + Commit() *kvrpcpb.CommitRequest
        + Cleanup() *kvrpcpb.CleanupRequest
        + BatchGet() *kvrpcpb.BatchGetRequest
        + BatchRollback() *kvrpcpb.BatchRollbackRequest
        + ScanLock() *kvrpcpb.ScanLockRequest
        + ResolveLock() *kvrpcpb.ResolveLockRequest
        + GC() *kvrpcpb.GCRequest
        + DeleteRange() *kvrpcpb.DeleteRangeRequest
        + RawGet() *kvrpcpb.RawGetRequest
        + RawBatchGet() *kvrpcpb.RawBatchGetRequest
        + RawPut() *kvrpcpb.RawPutRequest
        + RawBatchPut() *kvrpcpb.RawBatchPutRequest
        + RawDelete() *kvrpcpb.RawDeleteRequest
        + RawBatchDelete() *kvrpcpb.RawBatchDeleteRequest
        + RawDeleteRange() *kvrpcpb.RawDeleteRangeRequest
        + RawScan() *kvrpcpb.RawScanRequest
        + UnsafeDestroyRange() *kvrpcpb.UnsafeDestroyRangeRequest
        + RegisterLockObserver() *kvrpcpb.RegisterLockObserverRequest
        + CheckLockObserver() *kvrpcpb.CheckLockObserverRequest
        + RemoveLockObserver() *kvrpcpb.RemoveLockObserverRequest
        + PhysicalScanLock() *kvrpcpb.PhysicalScanLockRequest
        + Cop() *coprocessor.Request
        + BatchCop() *coprocessor.BatchRequest
        + MvccGetByKey() *kvrpcpb.MvccGetByKeyRequest
        + MvccGetByStartTs() *kvrpcpb.MvccGetByStartTsRequest
        + SplitRegion() *kvrpcpb.SplitRegionRequest
        + PessimisticLock() *kvrpcpb.PessimisticLockRequest
        + PessimisticRollback() *kvrpcpb.PessimisticRollbackRequest
        + DebugGetRegionProperties() *debugpb.GetRegionPropertiesRequest
        + Empty() *tikvpb.BatchCommandsEmptyRequest
        + CheckTxnStatus() *kvrpcpb.CheckTxnStatusRequest
        + TxnHeartBeat() *kvrpcpb.TxnHeartBeatRequest
        + ToBatchCommandsRequest() *tikvpb.BatchCommandsRequest_Request
        + IsDebugReq() bool

    }
    class Response << (S,Aquamarine) >> {
        + Resp <font color=blue>interface</font>{}

        + GetRegionError() (*errorpb.Error, error)

    }
    interface getRegionError  {
        + GetRegionError() *errorpb.Error

    }
    class tikvrpc.CmdType << (T, #FF7700) >>  {
    }
}
"coprocessor.BatchResponse" *-- "tikvrpc.BatchCopStreamResponse"
"tikvpb.Tikv_BatchCoprocessorClient" *-- "tikvrpc.BatchCopStreamResponse"
"tikvrpc.Lease" *-- "tikvrpc.BatchCopStreamResponse"
"coprocessor.Response" *-- "tikvrpc.CopStreamResponse"
"tikvpb.Tikv_CoprocessorStreamClient" *-- "tikvrpc.CopStreamResponse"
"tikvrpc.Lease" *-- "tikvrpc.CopStreamResponse"
"kvrpcpb.Context" *-- "tikvrpc.Request"


namespace timeutil {
    class locCache << (S,Aquamarine) >> {
        - locMap <font color=blue>map</font>[string]*time.Location

        - getLoc(name string) (*time.Location, error)

    }
}
"sync.RWMutex" *-- "timeutil.locCache"


namespace tracing {
    class CallbackRecorder << (S,Aquamarine) >> {
        + RecordSpan(sp basictracer.RawSpan) 

    }
    class tracing.CallbackRecorder << (T, #FF7700) >>  {
    }
    class "<font color=blue>func</font>(basictracer.RawSpan) " as fontcolorbluefuncfontbasictracerRawSpan {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace types {
    class BinaryLiteral << (S,Aquamarine) >> {
        + String() string
        + ToString() string
        + ToBitLiteralString(trimLeadingZero bool) string
        + ToInt(sc *stmtctx.StatementContext) (uint64, error)
        + Compare(b2 BinaryLiteral) int

    }
    class BitLiteral << (S,Aquamarine) >> {
        + ToString() string

    }
    class CoreTime << (S,Aquamarine) >> {
        - getYear() uint16
        - setYear(year uint16) 
        - getMonth() uint8
        - setMonth(month uint8) 
        - getDay() uint8
        - setDay(day uint8) 
        - getHour() uint8
        - setHour(hour uint8) 
        - getMinute() uint8
        - setMinute(minute uint8) 
        - getSecond() uint8
        - setSecond(second uint8) 
        - getMicrosecond() uint32
        - setMicrosecond(microsecond uint32) 

        + String() string
        + Year() int
        + Month() int
        + Day() int
        + Hour() int
        + Minute() int
        + Second() int
        + Microsecond() int
        + Weekday() "time.Weekday
        + YearWeek(mode int) (int, int)
        + Week(mode int) int
        + YearDay() int
        + GoTime(loc *"time.Location) ("time.Time, error)
        + IsLeapYear() bool

    }
    class Datum << (S,Aquamarine) >> {
        - k byte
        - collation string
        - decimal uint16
        - length uint32
        - i int64
        - b []byte
        - x <font color=blue>interface</font>{}

        - compareInt64(sc *stmtctx.StatementContext, i int64) (int, error)
        - compareUint64(sc *stmtctx.StatementContext, u uint64) (int, error)
        - compareFloat64(sc *stmtctx.StatementContext, f float64) (int, error)
        - compareString(sc *stmtctx.StatementContext, s string, retCollation string) (int, error)
        - compareBytes(sc *stmtctx.StatementContext, b []byte) (int, error)
        - compareMysqlDecimal(sc *stmtctx.StatementContext, dec *MyDecimal) (int, error)
        - compareMysqlDuration(sc *stmtctx.StatementContext, dur Duration) (int, error)
        - compareMysqlEnum(sc *stmtctx.StatementContext, enum Enum) (int, error)
        - compareBinaryLiteral(sc *stmtctx.StatementContext, b BinaryLiteral) (int, error)
        - compareMysqlSet(sc *stmtctx.StatementContext, set Set) (int, error)
        - compareMysqlJSON(sc *stmtctx.StatementContext, target json.BinaryJSON) (int, error)
        - compareMysqlTime(sc *stmtctx.StatementContext, time Time) (int, error)
        - convertToFloat(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        - convertToString(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        - convertToInt(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        - convertToUint(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        - convertToMysqlTimestamp(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        - convertToMysqlTime(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        - convertToMysqlDuration(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        - convertToMysqlDecimal(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        - convertToMysqlYear(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        - convertToMysqlBit(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        - convertToMysqlEnum(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        - convertToMysqlSet(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        - convertToMysqlJSON(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        - toSignedInteger(sc *stmtctx.StatementContext, tp byte) (int64, error)

        + Clone() *Datum
        + Copy(dst *Datum) 
        + Kind() byte
        + Collation() string
        + Frac() int
        + SetFrac(frac int) 
        + Length() int
        + SetLength(l int) 
        + IsNull() bool
        + GetInt64() int64
        + SetInt64(i int64) 
        + GetUint64() uint64
        + SetUint64(i uint64) 
        + GetFloat64() float64
        + SetFloat64(f float64) 
        + GetFloat32() float32
        + SetFloat32(f float32) 
        + GetString() string
        + SetString(s string, collation string) 
        + GetBytes() []byte
        + SetBytes(b []byte) 
        + SetBytesAsString(b []byte, collation string, length uint32) 
        + GetInterface() <font color=blue>interface</font>{}
        + SetInterface(x <font color=blue>interface</font>{}) 
        + SetNull() 
        + SetMinNotNull() 
        + GetBinaryLiteral() BinaryLiteral
        + GetMysqlBit() BinaryLiteral
        + SetBinaryLiteral(b BinaryLiteral) 
        + SetMysqlBit(b BinaryLiteral) 
        + GetMysqlDecimal() *MyDecimal
        + SetMysqlDecimal(b *MyDecimal) 
        + GetMysqlDuration() Duration
        + SetMysqlDuration(b Duration) 
        + GetMysqlEnum() Enum
        + SetMysqlEnum(b Enum, collation string) 
        + GetMysqlSet() Set
        + SetMysqlSet(b Set, collation string) 
        + GetMysqlJSON() json.BinaryJSON
        + SetMysqlJSON(b json.BinaryJSON) 
        + GetMysqlTime() Time
        + SetMysqlTime(b Time) 
        + SetRaw(b []byte) 
        + GetRaw() []byte
        + SetAutoID(id int64, flag uint) 
        + String() string
        + GetValue() <font color=blue>interface</font>{}
        + SetValueWithDefaultCollation(val <font color=blue>interface</font>{}) 
        + SetValue(val <font color=blue>interface</font>{}, tp *types.FieldType) 
        + CompareDatum(sc *stmtctx.StatementContext, ad *Datum) (int, error)
        + ConvertTo(sc *stmtctx.StatementContext, target *FieldType) (Datum, error)
        + ToBool(sc *stmtctx.StatementContext) (int64, error)
        + ToDecimal(sc *stmtctx.StatementContext) (*MyDecimal, error)
        + ToInt64(sc *stmtctx.StatementContext) (int64, error)
        + ToFloat64(sc *stmtctx.StatementContext) (float64, error)
        + ToString() (string, error)
        + ToBytes() ([]byte, error)
        + ToMysqlJSON() (json.BinaryJSON, error)

    }
    class Duration << (S,Aquamarine) >> {
        + Fsp int8

        - convertDateFormat(b rune, buf *bytes.Buffer) error
        - formatFrac(frac int) string

        + Neg() Duration
        + Add(v Duration) (Duration, error)
        + Sub(v Duration) (Duration, error)
        + DurationFormat(layout string) (string, error)
        + String() string
        + ToNumber() *MyDecimal
        + ConvertToTime(sc *stmtctx.StatementContext, tp uint8) (Time, error)
        + RoundFrac(fsp int8) (Duration, error)
        + Compare(o Duration) int
        + CompareString(sc *stmtctx.StatementContext, str string) (int, error)
        + Hour() int
        + Minute() int
        + Second() int
        + MicroSecond() int

    }
    class Enum << (S,Aquamarine) >> {
        + Name string
        + Value uint64

        + Copy() Enum
        + String() string
        + ToNumber() float64

    }
    class FieldName << (S,Aquamarine) >> {
        + OrigTblName model.CIStr
        + OrigColName model.CIStr
        + DBName model.CIStr
        + TblName model.CIStr
        + ColName model.CIStr
        + Hidden bool

        + String() string

    }
    class HexLiteral << (S,Aquamarine) >> {
        + ToString() string

    }
    class MyDecimal << (S,Aquamarine) >> {
        - digitsInt int8
        - digitsFrac int8
        - resultFrac int8
        - negative bool
        - wordBuf []int32

        - stringSize() int
        - removeLeadingZeros() (int, int)
        - removeTrailingZeros() (int, int)
        - digitBounds() int
        - doMiniLeftShift(shift int, beg int, end int) 
        - doMiniRightShift(shift int, beg int, end int) 

        + IsNegative() bool
        + GetDigitsFrac() int8
        + GetDigitsInt() int8
        + String() string
        + ToString() []byte
        + FromString(str []byte) error
        + Shift(shift int) error
        + Round(to *MyDecimal, frac int, roundMode RoundMode) error
        + FromInt(val int64) *MyDecimal
        + FromUint(val uint64) *MyDecimal
        + ToInt() (int64, error)
        + ToUint() (uint64, error)
        + FromFloat64(f float64) error
        + ToFloat64() (float64, error)
        + ToBin(precision int, frac int) ([]byte, error)
        + ToHashKey() ([]byte, error)
        + PrecisionAndFrac() int
        + IsZero() bool
        + FromBin(bin []byte, precision int, frac int) (int, error)
        + Compare(to *MyDecimal) int

    }
    class NameSlice << (S,Aquamarine) >> {
        + Shallow() NameSlice

    }
    class Set << (S,Aquamarine) >> {
        + Name string
        + Value uint64

        + String() string
        + ToNumber() float64
        + Copy() Set

    }
    class Time << (S,Aquamarine) >> {
        - getFspTt() uint8
        - setFspTt(fspTt uint8) 
        - check(sc *stmtctx.StatementContext) error
        - convertDateFormat(b rune, buf *bytes.Buffer) error

        + Clock() (int, int, int)
        + Type() uint8
        + Fsp() int8
        + SetType(tp uint8) 
        + SetFsp(fsp int8) 
        + CoreTime() CoreTime
        + SetCoreTime(ct CoreTime) 
        + ConvertTimeZone(from *"time.Location, to *"time.Location) error
        + String() string
        + IsZero() bool
        + InvalidZero() bool
        + ToNumber() *MyDecimal
        + FillNumber(dec *MyDecimal) 
        + Convert(sc *stmtctx.StatementContext, tp uint8) (Time, error)
        + ConvertToDuration() (Duration, error)
        + Compare(o Time) int
        + CompareString(sc *stmtctx.StatementContext, str string) (int, error)
        + RoundFrac(sc *stmtctx.StatementContext, fsp int8) (Time, error)
        + ToPackedUint() (uint64, error)
        + FromPackedUint(packed uint64) error
        + Check(sc *stmtctx.StatementContext) error
        + Sub(sc *stmtctx.StatementContext, t1 *Time) Duration
        + Add(sc *stmtctx.StatementContext, d Duration) (Time, error)
        + DateFormat(layout string) (string, error)
        + StrToDate(sc *stmtctx.StatementContext, date string, format string) bool

    }
    class datumsSorter << (S,Aquamarine) >> {
        - datums []Datum
        - sc *stmtctx.StatementContext
        - err error

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class types.BinaryLiteral << (T, #FF7700) >>  {
    }
    class types.BitLiteral << (T, #FF7700) >>  {
    }
    class types.CoreTime << (T, #FF7700) >>  {
    }
    class types.EvalType << (T, #FF7700) >>  {
    }
    class types.FieldType << (T, #FF7700) >>  {
    }
    class types.HexLiteral << (T, #FF7700) >>  {
    }
    class types.NameSlice << (T, #FF7700) >>  {
    }
    class types.RoundMode << (T, #FF7700) >>  {
    }
    class types.RoundingType << (T, #FF7700) >>  {
    }
    class types.coreTime << (T, #FF7700) >>  {
    }
    class types.dateFormatParser << (T, #FF7700) >>  {
    }
    class types.weekBehaviour << (T, #FF7700) >>  {
    }
    class weekBehaviour << (S,Aquamarine) >> {
        - test(flag weekBehaviour) bool

    }
    class "types.FieldType" as typesFieldType {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.EvalType" as typesEvalType {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
""time.Duration" *-- "types.Duration"
"types.coreTime" *-- "types.Time"


namespace util {
    class AccessPath << (S,Aquamarine) >> {
        + Index *model.IndexInfo
        + FullIdxCols []*expression.Column
        + FullIdxColLens []int
        + IdxCols []*expression.Column
        + IdxColLens []int
        + Ranges []*ranger.Range
        + CountAfterAccess float64
        + CountAfterIndex float64
        + AccessConds []expression.Expression
        + EqCondCount int
        + EqOrInCondCount int
        + IndexFilters []expression.Expression
        + TableFilters []expression.Expression
        + PartialIndexPaths []*AccessPath
        + StoreType kv.StoreType
        + IsDNFCond bool
        + IsTablePath bool
        + Forced bool
        + PkCol *expression.Column

        + SplitCorColAccessCondFromFilters(ctx sessionctx.Context, eqOrInCount int) []expression.Expression

    }
    class ByItems << (S,Aquamarine) >> {
        + Expr expression.Expression
        + Desc bool

        + String() string
        + Clone() *ByItems
        + Equal(ctx sessionctx.Context, other *ByItems) bool

    }
    class DelRangeTask << (S,Aquamarine) >> {
        + JobID int64
        + StartKey kv.Key

        + Range() (kv.Key, kv.Key)

    }
    class Event << (S,Aquamarine) >> {
        + Tp model.ActionType
        + TableInfo *model.TableInfo
        + PartInfo *model.PartitionInfo
        + ColumnInfo *model.ColumnInfo
        + IndexInfo *model.IndexInfo

        + String() string

    }
    class ProcessInfo << (S,Aquamarine) >> {
        + ID uint64
        + User string
        + Host string
        + DB string
        + Plan <font color=blue>interface</font>{}
        + PlanExplainRows [][]string
        + Time time.Time
        + Info string
        + CurTxnStartTS uint64
        + StmtCtx *stmtctx.StatementContext
        + StatsInfo <font color=blue>func</font>(<font color=blue>interface</font>{}) <font color=blue>map</font>[string]uint64
        + MaxExecutionTime uint64
        + State uint16
        + Command byte
        + ExceedExpensiveTimeThresh bool

        - txnStartTs(tz *time.Location) string

        + ToRowForShow(full bool) []<font color=blue>interface</font>{}
        + ToRow(tz *time.Location) []<font color=blue>interface</font>{}

    }
    interface SchemaSyncer  {
        + Init(ctx context.Context) error
        + UpdateSelfVersion(ctx context.Context, version int64) error
        + RemoveSelfVersionPath() error
        + OwnerUpdateGlobalVersion(ctx context.Context, version int64) error
        + GlobalVersionCh() clientv3.WatchChan
        + WatchGlobalSchemaVer(ctx context.Context) 
        + MustGetGlobalVersion(ctx context.Context) (int64, error)
        + Done() <font color=blue>chan</font> <font color=blue>struct</font>{}
        + Restart(ctx context.Context) error
        + OwnerCheckAllVersions(ctx context.Context, latestVer int64) error
        + NotifyCleanExpiredPaths() bool
        + StartCleanWork() 
        + CloseCleanWork() 

    }
    interface SequenceSchema  {
        + SequenceByName(schema model.CIStr, sequence model.CIStr) (SequenceTable, error)

    }
    interface SequenceTable  {
        + GetSequenceID() int64
        + GetSequenceNextVal(ctx <font color=blue>interface</font>{}, dbName string, seqName string) (int64, error)
        + SetSequenceVal(ctx <font color=blue>interface</font>{}, newVal int64, dbName string, seqName string) (int64, bool, error)

    }
    interface SessionManager  {
        + ShowProcessList() <font color=blue>map</font>[uint64]*ProcessInfo
        + GetProcessInfo(id uint64) (*ProcessInfo, bool)
        + Kill(connectionID uint64, query bool) 
        + UpdateTLSConfig(cfg *tls.Config) 

    }
    interface ownerChecker  {
        + IsOwner() bool

    }
    class schemaVersionSyncer << (S,Aquamarine) >> {
        - selfSchemaVerPath string
        - etcdCli *clientv3.Client
        - session unsafe.Pointer
        - mu <font color=blue>struct</font>{sync.RWMutex, clientv3.WatchChan}
        - ownerChecker ownerChecker
        - notifyCleanExpiredPathsCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - quiteCh <font color=blue>chan</font> <font color=blue>struct</font>{}

        - loadSession() *concurrency.Session
        - storeSession(session *concurrency.Session) 
        - doCleanExpirePaths(leases []clientv3.LeaseStatus) bool

        + Init(ctx context.Context) error
        + Done() <font color=blue>chan</font> <font color=blue>struct</font>{}
        + Restart(ctx context.Context) error
        + GlobalVersionCh() clientv3.WatchChan
        + WatchGlobalSchemaVer(ctx context.Context) 
        + UpdateSelfVersion(ctx context.Context, version int64) error
        + OwnerUpdateGlobalVersion(ctx context.Context, version int64) error
        + RemoveSelfVersionPath() error
        + MustGetGlobalVersion(ctx context.Context) (int64, error)
        + OwnerCheckAllVersions(ctx context.Context, latestVer int64) error
        + StartCleanWork() 
        + CloseCleanWork() 
        + NotifyCleanExpiredPaths() bool

    }
    class util.SANType << (T, #FF7700) >>  {
    }
}

"util.SchemaSyncer" <|-- "util.schemaVersionSyncer"

namespace variable {
    class BatchSize << (S,Aquamarine) >> {
        + DMLBatchSize int
        + IndexJoinBatchSize int
        + IndexLookupSize int
        + InitChunkSize int
        + MaxChunkSize int

    }
    class Concurrency << (S,Aquamarine) >> {
        + IndexLookupConcurrency int
        + IndexLookupJoinConcurrency int
        + DistSQLScanConcurrency int
        + HashJoinConcurrency int
        + ProjectionConcurrency int64
        + HashAggPartialConcurrency int
        + HashAggFinalConcurrency int
        + WindowConcurrency int
        + IndexSerialScanConcurrency int

    }
    class ConnectionInfo << (S,Aquamarine) >> {
        + ConnectionID uint32
        + ConnectionType string
        + Host string
        + ClientIP string
        + ClientPort string
        + ServerID int
        + ServerPort int
        + Duration float64
        + User string
        + ServerOSLoginUser string
        + OSVersion string
        + ClientVersion string
        + ServerVersion string
        + SSLVersion string
        + PID int
        + DB string

    }
    interface GlobalVarAccessor  {
        + GetAllSysVars() (<font color=blue>map</font>[string]string, error)
        + GetGlobalSysVar(name string) (string, error)
        + SetGlobalSysVar(name string, value string) error

    }
    class MemQuota << (S,Aquamarine) >> {
        + MemQuotaQuery int64
        + MemQuotaHashJoin int64
        + MemQuotaMergeJoin int64
        + MemQuotaSort int64
        + MemQuotaTopn int64
        + MemQuotaIndexLookupReader int64
        + MemQuotaIndexLookupJoin int64
        + MemQuotaNestedLoopApply int64
        + MemQuotaDistSQL int64

    }
    class MockGlobalAccessor << (S,Aquamarine) >> {
        + GetGlobalSysVar(name string) (string, error)
        + SetGlobalSysVar(name string, value string) error
        + GetAllSysVars() (<font color=blue>map</font>[string]string, error)

    }
    class PreparedParams << (S,Aquamarine) >> {
        + String() string

    }
    class RetryInfo << (S,Aquamarine) >> {
        - autoIncrementIDs retryInfoAutoIDs
        - autoRandomIDs retryInfoAutoIDs

        + Retrying bool
        + DroppedPreparedStmtIDs []uint32

        + Clean() 
        + ResetOffset() 
        + AddAutoIncrementID(id int64) 
        + GetCurrAutoIncrementID() (int64, error)
        + AddAutoRandomID(id int64) 
        + GetCurrAutoRandomID() (int64, error)

    }
    class SequenceState << (S,Aquamarine) >> {
        - mu sync.Mutex
        - latestValueMap <font color=blue>map</font>[int64]int64

        + UpdateState(sequenceID int64, value int64) 
        + GetLastValue(sequenceID int64) (int64, bool, error)

    }
    class SessionVars << (S,Aquamarine) >> {
        - systems <font color=blue>map</font>[string]string
        - preparedStmtID uint32
        - txnIsolationLevelOneShot <font color=blue>struct</font>{txnIsolationLevelOneShotState, string}
        - writeStmtBufs WriteStmtBufs
        - prevStmtDigest string
        - allowInSubqToJoinAndAgg bool
        - enableIndexMerge bool
        - replicaRead kv.ReplicaReadType

        + RetryLimit int64
        + DisableTxnAutoRetry bool
        + UsersLock sync.RWMutex
        + Users <font color=blue>map</font>[string]types.Datum
        + SysWarningCount int
        + SysErrorCount uint16
        + PreparedStmts <font color=blue>map</font>[uint32]<font color=blue>interface</font>{}
        + PreparedStmtNameToID <font color=blue>map</font>[string]uint32
        + PreparedParams PreparedParams
        + ActiveRoles []*auth.RoleIdentity
        + RetryInfo *RetryInfo
        + TxnCtx *TransactionContext
        + KVVars *kv.Variables
        + Status uint16
        + ClientCapability uint32
        + TLSConnectionState *tls.ConnectionState
        + ConnectionID uint64
        + PlanID int
        + PlanColumnID int64
        + User *auth.UserIdentity
        + CurrentDB string
        + StrictSQLMode bool
        + CommonGlobalLoaded bool
        + InRestrictedSQL bool
        + SnapshotTS uint64
        + SnapshotInfoschema <font color=blue>interface</font>{}
        + BinlogClient *pump_client.PumpsClient
        + GlobalVarsAccessor GlobalVarAccessor
        + LastFoundRows uint64
        + StmtCtx *stmtctx.StatementContext
        + AllowAggPushDown bool
        + AllowDistinctAggPushDown bool
        + AllowWriteRowID bool
        + AllowBatchCop int
        + CorrelationThreshold float64
        + CorrelationExpFactor int
        + CPUFactor float64
        + CopCPUFactor float64
        + NetworkFactor float64
        + ScanFactor float64
        + DescScanFactor float64
        + SeekFactor float64
        + MemoryFactor float64
        + DiskFactor float64
        + ConcurrencyFactor float64
        + CurrInsertValues chunk.Row
        + TimeZone *time.Location
        + SQLMode errno.SQLMode
        + AutoIncrementIncrement int
        + AutoIncrementOffset int
        + SkipUTF8Check bool
        + BatchInsert bool
        + BatchDelete bool
        + BatchCommit bool
        + IDAllocator autoid.Allocator
        + OptimizerSelectivityLevel int
        + EnableTablePartition string
        + EnableCascadesPlanner bool
        + EnableWindowFunction bool
        + EnableVectorizedExpression bool
        + DDLReorgPriority int
        + WaitSplitRegionFinish bool
        + WaitSplitRegionTimeout uint64
        + EnableStreaming bool
        + EnableChunkRPC bool
        + L2CacheSize int
        + EnableRadixJoin bool
        + ConstraintCheckInPlace bool
        + CommandValue uint32
        + TiDBOptJoinReorderThreshold int
        + SlowQueryFile string
        + EnableFastAnalyze bool
        + TxnMode string
        + LowResolutionTSO bool
        + MaxExecutionTime uint64
        + Killed uint32
        + ConnectionInfo *ConnectionInfo
        + EnableNoopFuncs bool
        + StartTime time.Time
        + DurationParse time.Duration
        + DurationCompile time.Duration
        + PrevStmt fmt.Stringer
        + AllowRemoveAutoInc bool
        + UsePlanBaselines bool
        + EvolvePlanBaselines bool
        + IsolationReadEngines <font color=blue>map</font>[kv.StoreType]<font color=blue>struct</font>{}
        + PlannerSelectBlockAsName []ast.HintTable
        + LockWaitTimeout int64
        + MetricSchemaStep int64
        + MetricSchemaRangeDuration int64
        + InspectionTableCache <font color=blue>map</font>[string]TableSnapshot
        + RowEncoder rowcodec.Encoder
        + SequenceState *SequenceState
        + WindowingUseHighPrecision bool
        + FoundInPlanCache bool
        + PrevFoundInPlanCache bool
        + SelectLimit uint64
        + EnableSlowLogMasking bool

        - setDDLReorgPriority(val string) 
        - setTxnMode(val string) error

        + GetAllowInSubqToJoinAndAgg() bool
        + SetAllowInSubqToJoinAndAgg(val bool) 
        + GetEnableCascadesPlanner() bool
        + SetEnableCascadesPlanner(val bool) 
        + GetEnableIndexMerge() bool
        + SetEnableIndexMerge(val bool) 
        + GetReplicaRead() kv.ReplicaReadType
        + SetReplicaRead(val kv.ReplicaReadType) 
        + GetWriteStmtBufs() *WriteStmtBufs
        + GetSplitRegionTimeout() time.Duration
        + GetIsolationReadEngines() <font color=blue>map</font>[kv.StoreType]<font color=blue>struct</font>{}
        + CleanBuffers() 
        + AllocPlanColumnID() int64
        + GetCharsetInfo() string
        + SetUserVar(varName string, svalue string, collation string) 
        + SetLastInsertID(insertID uint64) 
        + SetStatusFlag(flag uint16, on bool) 
        + GetStatusFlag(flag uint16) bool
        + InTxn() bool
        + IsAutocommit() bool
        + IsReadConsistencyTxn() bool
        + SetTxnIsolationLevelOneShotStateForNextTxn() 
        + IsPessimisticReadConsistency() bool
        + GetNextPreparedStmtID() uint32
        + Location() *time.Location
        + GetSystemVar(name string) (string, bool)
        + AddPreparedStmt(stmtID uint32, stmt <font color=blue>interface</font>{}) error
        + RemovePreparedStmt(stmtID uint32) 
        + WithdrawAllPreparedStmt() 
        + SetSystemVar(name string, val string) error
        + GetReadableTxnMode() string
        + SetPrevStmtDigest(prevStmtDigest string) 
        + GetPrevStmtDigest() string
        + SlowLogFormat(logItems *SlowQueryLogItems) string

    }
    class SlowQueryLogItems << (S,Aquamarine) >> {
        + TxnTS uint64
        + SQL string
        + Digest string
        + TimeTotal time.Duration
        + TimeParse time.Duration
        + TimeCompile time.Duration
        + IndexNames string
        + StatsInfos <font color=blue>map</font>[string]uint64
        + CopTasks *stmtctx.CopTasksDetails
        + ExecDetail execdetails.ExecDetails
        + MemMax int64
        + DiskMax int64
        + Succ bool
        + Prepared bool
        + PlanFromCache bool
        + HasMoreResults bool
        + PrevStmt string
        + Plan string
        + PlanDigest string

    }
    interface Statistics  {
        + GetScope(status string) ScopeFlag
        + Stats( *SessionVars) (<font color=blue>map</font>[string]<font color=blue>interface</font>{}, error)

    }
    class StatusVal << (S,Aquamarine) >> {
        + Scope ScopeFlag
        + Value <font color=blue>interface</font>{}

    }
    class SysVar << (S,Aquamarine) >> {
        + Scope ScopeFlag
        + Name string
        + Value string

    }
    class TableDelta << (S,Aquamarine) >> {
        + Delta int64
        + Count int64
        + ColSize <font color=blue>map</font>[int64]int64
        + InitTime time.Time

    }
    class TableSnapshot << (S,Aquamarine) >> {
        + Rows [][]types.Datum
        + Err error

    }
    class TransactionContext << (S,Aquamarine) >> {
        - forUpdateTS uint64
        - stmtFuture oracle.Future
        - unchangedRowKeys <font color=blue>map</font>[string]<font color=blue>struct</font>{}
        - pessimisticLockCache <font color=blue>map</font>[string][]byte

        + DirtyDB <font color=blue>interface</font>{}
        + Binlog <font color=blue>interface</font>{}
        + InfoSchema <font color=blue>interface</font>{}
        + History <font color=blue>interface</font>{}
        + SchemaVersion int64
        + StartTS uint64
        + Shard *int64
        + TableDeltaMap <font color=blue>map</font>[int64]TableDelta
        + CreateTime time.Time
        + StatementCount int
        + ForUpdate bool
        + CouldRetry bool
        + IsPessimistic bool
        + Isolation string
        + LockExpire uint32

        + AddUnchangedRowKey(key []byte) 
        + CollectUnchangedRowKeys(buf []kv.Key) []kv.Key
        + UpdateDeltaForTable(physicalTableID int64, delta int64, count int64, colSize <font color=blue>map</font>[int64]int64) 
        + GetKeyInPessimisticLockCache(key kv.Key) ([]byte, bool)
        + SetPessimisticLockCache(key kv.Key, val []byte) 
        + Cleanup() 
        + ClearDelta() 
        + GetForUpdateTS() uint64
        + SetForUpdateTS(forUpdateTS uint64) 
        + SetStmtFutureForRC(future oracle.Future) 
        + GetStmtFutureForRC() oracle.Future

    }
    class WriteStmtBufs << (S,Aquamarine) >> {
        + RowValBuf []byte
        + AddRowValues []types.Datum
        + IndexValsBuf []types.Datum
        + IndexKeyBuf []byte

        - clean() 

    }
    class defaultStatusStat << (S,Aquamarine) >> {
        + GetScope(status string) ScopeFlag
        + Stats(vars *SessionVars) (<font color=blue>map</font>[string]<font color=blue>interface</font>{}, error)

    }
    class retryInfoAutoIDs << (S,Aquamarine) >> {
        - currentOffset int
        - autoIDs []int64

        - resetOffset() 
        - clean() 
        - getCurrent() (int64, error)

    }
    class serverGlobalVariable << (S,Aquamarine) >> {
        - serverVal string
        - globalVal string

        + Set(val string, isServer bool) 
        + GetVal() string

    }
    class stmtFuture << (S,Aquamarine) >> {
        - future oracle.Future
        - cachedTS uint64

    }
    class variable.PreparedParams << (T, #FF7700) >>  {
    }
    class variable.ScopeFlag << (T, #FF7700) >>  {
    }
    class variable.txnIsolationLevelOneShotState << (T, #FF7700) >>  {
    }
    class "[]types.Datum" as typesDatum {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"variable.BatchSize" *-- "variable.SessionVars"
"variable.Concurrency" *-- "variable.SessionVars"
"variable.MemQuota" *-- "variable.SessionVars"
"sync.Mutex" *-- "variable.serverGlobalVariable"

"variable.GlobalVarAccessor" <|-- "variable.MockGlobalAccessor"
"variable.Statistics" <|-- "variable.defaultStatusStat"

"__builtin__.[][]byte" #.. "latch.bytesSlice"
"__builtin__.[]byte" #.. "kv.Key"
"__builtin__.[]byte" #.. "meta.JobListKeyType"
"__builtin__.[]byte" #.. "mocktikv.MvccKey"
"__builtin__.[]byte" #.. "types.BinaryLiteral"
"__builtin__.[]int64" #.. "domain.ids"
"__builtin__.bool" #.. "handle.dumpMode"
"__builtin__.byte" #.. "ddl.workerType"
"__builtin__.byte" #.. "executor.outerRowStatusFlag"
"__builtin__.byte" #.. "expression.weightStringPadding"
"__builtin__.byte" #.. "json.ModifyType"
"__builtin__.byte" #.. "json.TypeCode"
"__builtin__.byte" #.. "json.pathExpressionFlag"
"__builtin__.byte" #.. "json.pathLegType"
"__builtin__.byte" #.. "kv.ReplicaReadType"
"__builtin__.byte" #.. "plugin.ConnectionEvent"
"__builtin__.byte" #.. "plugin.GeneralEvent"
"__builtin__.byte" #.. "plugin.ParseEvent"
"__builtin__.byte" #.. "structure.TypeFlag"
"__builtin__.int" #.. "aggregation.AggFunctionMode"
"__builtin__.int" #.. "bindinfo.sessionBindInfoKeyType"
"__builtin__.int" #.. "binloginfo.BinlogStatus"
"__builtin__.int" #.. "core.AdminPluginsAction"
"__builtin__.int" #.. "core.JoinType"
"__builtin__.int" #.. "core.PartitionSplitterType"
"__builtin__.int" #.. "core.SQLBindOpType"
"__builtin__.int" #.. "core.clauseCode"
"__builtin__.int" #.. "domain.checkResult"
"__builtin__.int" #.. "domain.domainKeyType"
"__builtin__.int" #.. "domainutil.repairKeyType"
"__builtin__.int" #.. "executor.IndexAdviseVarKeyType"
"__builtin__.int" #.. "executor.loadDataVarKeyType"
"__builtin__.int" #.. "executor.loadStatsVarKeyType"
"__builtin__.int" #.. "executor.objectType"
"__builtin__.int" #.. "executor.taskType"
"__builtin__.int" #.. "expression.Coercibility"
"__builtin__.int" #.. "expression.inCastContext"
"__builtin__.int" #.. "hint.NodeType"
"__builtin__.int" #.. "kv.AssertionType"
"__builtin__.int" #.. "kv.IsoLevel"
"__builtin__.int" #.. "kv.Option"
"__builtin__.int" #.. "memo.ExploreMark"
"__builtin__.int" #.. "memo.Operand"
"__builtin__.int" #.. "mocktikv.mvccValueType"
"__builtin__.int" #.. "privilege.keyType"
"__builtin__.int" #.. "privileges.SSLType"
"__builtin__.int" #.. "privileges.checkResult"
"__builtin__.int" #.. "property.TaskType"
"__builtin__.int" #.. "ranger.RangeType"
"__builtin__.int" #.. "sessionctx.basicCtxType"
"__builtin__.int" #.. "table.WithReserveAutoIDHint"
"__builtin__.int" #.. "tablecodec.HandleStatus"
"__builtin__.int" #.. "tikv.AccessIndex"
"__builtin__.int" #.. "tikv.AccessMode"
"__builtin__.int" #.. "tikv.backoffType"
"__builtin__.int16" #.. "table.Type"
"__builtin__.int32" #.. "latch.acquireResult"
"__builtin__.int32" #.. "types.RoundMode"
"__builtin__.int64" #.. "aggfuncs.partialResult4Count"
"__builtin__.int64" #.. "autoid.CustomAutoIncCacheOption"
"__builtin__.int64" #.. "tables.getColsMode"
"__builtin__.string" #.. "driver.featureID"
"__builtin__.string" #.. "hack.MutableString"
"__builtin__.string" #.. "mock.HookKeyForTest"
"__builtin__.string" #.. "mocktikv.ErrAbort"
"__builtin__.string" #.. "mocktikv.ErrRetryable"
"__builtin__.string" #.. "plugin.ID"
"__builtin__.string" #.. "stringutil.StringerStr"
"__builtin__.string" #.. "util.SANType"
"__builtin__.uint" #.. "memo.EngineType"
"__builtin__.uint" #.. "memo.EngineTypeSet"
"__builtin__.uint" #.. "types.weekBehaviour"
"__builtin__.uint" #.. "variable.txnIsolationLevelOneShotState"
"__builtin__.uint16" #.. "tikvrpc.CmdType"
"__builtin__.uint32" #.. "aggfuncs.approxCountDistinctHashValue"
"__builtin__.uint32" #.. "tikv.livenessState"
"__builtin__.uint32" #.. "tikv.ttlManagerState"
"__builtin__.uint64" #.. "aggfuncs.partialResult4BitFunc"
"__builtin__.uint64" #.. "core.capFlagType"
"__builtin__.uint64" #.. "mocktikv.ErrAlreadyCommitted"
"__builtin__.uint64" #.. "oracles.lowResolutionTsFuture"
"__builtin__.uint64" #.. "tikv.resolveState"
"__builtin__.uint64" #.. "types.CoreTime"
"__builtin__.uint8" #.. "autoid.AllocatorType"
"__builtin__.uint8" #.. "core.preprocessorFlag"
"__builtin__.uint8" #.. "ddl.OnExist"
"__builtin__.uint8" #.. "kv.StoreType"
"__builtin__.uint8" #.. "plugin.Kind"
"__builtin__.uint8" #.. "plugin.State"
"__builtin__.uint8" #.. "types.RoundingType"
"__builtin__.uint8" #.. "variable.ScopeFlag"
"admin.modelJob" #.. "admin.jobArray"
"aggfuncs.unsafePointer" #.. "aggfuncs.PartialResult"
"autoid.[]Allocator" #.. "autoid.Allocators"
"bindinfo.<font color=blue>map</font>[string][]*BindRecord" #.. "bindinfo.cache"
"cascades.fontcolorbluemapfontmemoOperandTransformation" #.. "cascades.TransformationRuleBatch"
"chunk.<font color=blue>func</font>(Row) error" #.. "chunk.ListWalkFunc"
"chunk.<font color=blue>func</font>(Row, int, Row, int) int" #.. "chunk.CompareFunc"
"chunk.Row" #.. "chunk.MutRow"
"config.<font color=blue>func</font>(*Config, *Config) " #.. "config.ConfReloadFunc"
"core.<font color=blue>func</font>(*preprocessor) " #.. "core.PreprocessOpt"
"core.fontcolorbluemapfontexpressionExpressionexpressionColumn" #.. "core.ExprColumnMap"
"core.[]TblColPosInfo" #.. "core.TblColPosInfoSlice"
"core.[]partitionRange" #.. "core.partitionRangeOR"
"ddl.<font color=blue>func</font>(*Options) " #.. "ddl.Option"
"ddl.fontcolorbluefuncfontint64kvKeybyteboolerror" #.. "ddl.recordIterFunc"
"ddl.astColumnName" #.. "ddl.columnNameSlice"
"ddl.modelColumnInfo" #.. "ddl.columnInfoSlice"
"disk.memoryTracker" #.. "disk.Tracker"
"encrypt.ecb" #.. "encrypt.ecbDecrypter"
"encrypt.ecb" #.. "encrypt.ecbEncrypter"
"executor.fontcolorbluefuncfonttypesDatumerror" #.. "executor.TestShowClusterConfigFunc"
"executor.<font color=blue>func</font>([]byte, []byte) error" #.. "executor.processKVFunc"
"executor.fontcolorbluemapfontint64fontcolorbluemapfontint64typesDatum" #.. "executor.tableRowMapType"
"executor.fontcolorbluemapfontstringaggfuncsPartialResult" #.. "executor.aggPartialResultMapper"
"executor.[]logStreamResult" #.. "executor.logResponseHeap"
"executor.v1Range" #.. "executor.promQLQueryRange"
"expression.fontcolorbluefuncfontsessionctxContextExpressionExpressionchunkRowchunkRowint64boolerror" #.. "expression.CompareFunc"
"expression.[]*Column" #.. "expression.KeyInfo"
"expression.[]Expression" #.. "expression.CNFExprs"
"format.indentFormatter" #.. "format.flatFormatter"
"gcworker.[]*receiver" #.. "gcworker.mergeReceiver"
"handle.<font color=blue>map</font>[int64]errorRateDelta" #.. "handle.errorRateDeltaMap"
"handle.fontcolorbluemapfontint64variableTableDelta" #.. "handle.tableDeltaMap"
"helper.[]*RegionInfo" #.. "helper.byRegionStartKey"
"helper.[]tableInfoWithKeyRange" #.. "helper.byTableStartKey"
"infoschema.fontcolorbluefuncfontautoidAllocatorsmodelTableInfotableTableerror" #.. "infoschema.tableFromMetaFunc"
"infoschema.modelDBInfo" #.. "infoschema.SchemasSorter"
"infoschema.tableTable" #.. "infoschema.sortedTables"
"json.<font color=blue>func</font>(PathExpression, BinaryJSON) (bool, error)" #.. "json.BinaryJSONWalkFunc"
"json.<font color=blue>func</font>(PathExpression, BinaryJSON) (bool, error)" #.. "json.extractCallbackFn"
"kv.<font color=blue>func</font>(Key) bool" #.. "kv.FnKeyCmp"
"kv.<font color=blue>map</font>[Option]<font color=blue>interface</font>{}" #.. "kv.options"
"mockstore.<font color=blue>func</font>(*mockOptions) " #.. "mockstore.MockTiKVStoreOption"
"mocktikv.fontcolorbluemapfontstringaggregationAggEvaluateContext" #.. "mocktikv.aggCtxsMapper"
"plugin.<font color=blue>func</font>(*Plugin, string, ID) (<font color=blue>func</font>() *Manifest, error)" #.. "plugin.loadFn"
"privileges.[]UserRecord" #.. "privileges.sortedUserRecord"
"rowcodec.Encoder" #.. "rowcodec.largeNotNullSorter"
"rowcodec.Encoder" #.. "rowcodec.largeNullSorter"
"rowcodec.Encoder" #.. "rowcodec.smallNotNullSorter"
"rowcodec.Encoder" #.. "rowcodec.smallNullSorter"
"server.[]hotRegion" #.. "server.hotRegions"
"set.<font color=blue>map</font>[float64]<font color=blue>struct</font>{}" #.. "set.Float64Set"
"set.<font color=blue>map</font>[int64]<font color=blue>struct</font>{}" #.. "set.Int64Set"
"set.<font color=blue>map</font>[int]<font color=blue>struct</font>{}" #.. "set.IntSet"
"set.<font color=blue>map</font>[string]<font color=blue>struct</font>{}" #.. "set.StringSet"
"statistics.fontcolorbluefuncfontstmtctxStatementContextint64rangerRangefloat64error" #.. "statistics.countByRangeFunc"
"statistics.Feedback" #.. "statistics.bucket"
"statistics.[]bucketScore" #.. "statistics.bucketScores"
"stringutil.<font color=blue>func</font>() string" #.. "stringutil.StringerFunc"
"table.<font color=blue>func</font>(*CreateIdxOpt) " #.. "table.CreateIdxOptFunc"
"table.fontcolorbluefuncfontint64typesDatumColumnboolerror" #.. "table.RecordIterFunc"
"table.[]Table" #.. "table.Slice"
"tikv.fontcolorbluefuncfontcontextContextkvKeyRangeRangeTaskStaterror" #.. "tikv.RangeTaskHandler"
"tracing.fontcolorbluefuncfontbasictracerRawSpan" #.. "tracing.CallbackRecorder"
"types.<font color=blue>func</font>(*CoreTime, string, <font color=blue>map</font>[string]int) (string, bool)" #.. "types.dateFormatParser"
"types.BinaryLiteral" #.. "types.BitLiteral"
"types.BinaryLiteral" #.. "types.HexLiteral"
"types.CoreTime" #.. "types.coreTime"
"types.[]*FieldName" #.. "types.NameSlice"
"types.typesEvalType" #.. "types.EvalType"
"types.typesFieldType" #.. "types.FieldType"
"variable.typesDatum" #.. "variable.PreparedParams"
@enduml
